% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layers-layers.R
\name{AveragePooling}
\alias{AveragePooling}
\title{Average Pooling Layer}
\usage{
AveragePooling(filter_shape, strides = 1, pad = FALSE, name = "")
}
\arguments{
\item{filter_shape}{int or list of int - shape (spatial extent) of the
receptive field, not including the input feature-map depth. E.g. (3,3) for a
2D convolution.
receptive field, not including the input feature-map depth. E.g. (3,3) for a
2D convolution.}

\item{strides}{(int or tuple of ints, defaults to 1) – stride of the
operation. Use a list of ints to specify a per-axis value. (int or tuple of
ints, defaults to 1) – stride (increment when
sliding over the input). Use a tuple to specify a per-axis value.}

\item{pad}{(bool or list of bools) – if False, then the operation will be
shifted over the “valid” area of input, that is, no value outside the area
is used. If pad=True on the other hand, the operation will be applied to all
input positions, and positions outside the valid region will be considered
containing zero. Use a list to specify a per-axis value. (bool or tuple of
bools, defaults to False) – if False, then the}

\item{name}{string (optional) the name of the Function instance in the network}
}
\value{
A function that accepts one argument and applies the average-pooling
operation to it
}
\description{
Like Convolution(), AveragePooling() processes items arranged on an
N-dimensional grid, such as an image. Typically, each item is a vector. For
each item, average-pooling computes the element-wise mean over a window
(“receptive field”) of items surrounding the item’s position on the grid.
}
\details{
The size (spatial extent) of the receptive field is given by filter <-
shape. E.g. for 2D pooling, filter <- shape should be a tuple of two
integers, such as (5,5).
}
\examples{
(f <- AveragePooling(c(3, 3), strides = 2))
(h <- op_input_variable(c(shape = 4)))

}
