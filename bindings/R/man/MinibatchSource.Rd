% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/io.R
\name{MinibatchSource}
\alias{MinibatchSource}
\title{Minibatch Source}
\usage{
MinibatchSource(deserializers, max_samples = IO_INFINITELY_REPEAT,
  max_sweeps = IO_INFINITELY_REPEAT,
  randomization_window_in_chunks = IO_DEFAULT_RANDOMIZATION_WINDOW_IN_CHUNKS,
  randomization_window_in_samples = 0, randomization_seed = 0,
  trace_level = get_logging_trace_level(),
  multithreaded_deserializer = NULL, frame_mode = FALSE,
  truncation_length = 0, randomize = TRUE)
}
\arguments{
\item{deserializers}{(deserializer or list) deserializers to be used in the
composite reader}

\item{max_samples}{(int, defaults to IO_INFINITELY_REPEAT) The maximum
number of input samples (not ‘label samples’) the reader can produce. After
this number has been reached, the reader returns empty minibatches on
subsequent calls to next_minibatch(). max_samples and max_sweeps are
mutually exclusive, an exception will be raised if both have non-default
values.}

\item{max_sweeps}{(int, defaults to IO_INFINITELY_REPEAT) The maximum number
of of sweeps over the input dataset After this number has been reached, the
reader returns empty minibatches on subsequent calls to func:next_minibatch.
max_samples and max_sweeps are mutually exclusive, an exception will be
raised if both have non-default values.}

\item{randomization_window_in_chunks}{(int, defaults to
IO_DEFAULT_RANDOMIZATION_WINDOW_IN_CHUNKS) size of the randomization window
in chunks, non-zero value enables randomization.
randomization_window_in_chunks and randomization_window_in_samples are
mutually exclusive, an exception will be raised if both have non-zero
values.}

\item{randomization_window_in_samples}{(int, defaults to 0)  size of the
randomization window in samples, non-zero value enables randomization.
randomization_window_in_chunks and randomization_window_in_samples are
mutually exclusive, an exception will be raised if both have non-zero
values.}

\item{randomization_seed}{(int, defaults to 0) Initial randomization seed
value (incremented every sweep when the input data is re-randomized).}

\item{trace_level}{(TraceLevel) the output verbosity level, defaults to the
current logging verbosity level given by get_trace_level().}

\item{multithreaded_deserializer}{(bool) specifies if the deserialization
should be done on a single or multiple threads. Defaults to None, which is
effectively “auto” (multhithreading is disabled unless ImageDeserializer is
present in the deserializers list). False and True faithfully turn the
multithreading off/on.}

\item{frame_mode}{(bool) switches the frame mode on and off. If the frame
mode is enabled the input data will be processed as individual frames
ignoring all sequence information (this option cannot be used for BPTT, an
exception will be raised if frame mode is enabled and the truncation length
is non-zero).}

\item{truncation_length}{(int) truncation length in samples, non-zero value
enables the truncation (only applicable for BPTT, cannot be used in frame
mode, an exception will be raised if frame mode is enabled and the
truncation length is non-zero).}

\item{randomize}{(bool) Enables or disables randomization; use
randomization_window_in_chunks or randomization_window_in_samples to specify
the randomization range}
}
\description{
Source of minibatch data
}
\details{
****** Attributes: ******

current_position

is_distributed

streams

****** Associated Functions: ******

get_minibatch_checkpoint_state(minibatch_source)

next_minibatch(minibatch_source, minibatch_size_in_samples,
input_map = NULL, device = NULL, num_data_partitions = NULL,
partition_index = NULL)

restore_mb_from_checkpoint(minibatch_source, checkpoint)

mb_stream_info(minibatch_source, name)
mb_stream_infos(minibatch_source)
}
