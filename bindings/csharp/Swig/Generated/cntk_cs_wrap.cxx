/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.10
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGCSHARP
#define SWIGCSHARP
#endif

#define SWIG_DIRECTORS


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#include <stdlib.h>
#include <string.h>
#include <stdio.h>


/* Support for throwing C# exceptions from C/C++. There are two types: 
 * Exceptions that take a message and ArgumentExceptions that take a message and a parameter name. */
typedef enum {
  SWIG_CSharpApplicationException,
  SWIG_CSharpArithmeticException,
  SWIG_CSharpDivideByZeroException,
  SWIG_CSharpIndexOutOfRangeException,
  SWIG_CSharpInvalidCastException,
  SWIG_CSharpInvalidOperationException,
  SWIG_CSharpIOException,
  SWIG_CSharpNullReferenceException,
  SWIG_CSharpOutOfMemoryException,
  SWIG_CSharpOverflowException,
  SWIG_CSharpSystemException
} SWIG_CSharpExceptionCodes;

typedef enum {
  SWIG_CSharpArgumentException,
  SWIG_CSharpArgumentNullException,
  SWIG_CSharpArgumentOutOfRangeException
} SWIG_CSharpExceptionArgumentCodes;

typedef void (SWIGSTDCALL* SWIG_CSharpExceptionCallback_t)(const char *);
typedef void (SWIGSTDCALL* SWIG_CSharpExceptionArgumentCallback_t)(const char *, const char *);

typedef struct {
  SWIG_CSharpExceptionCodes code;
  SWIG_CSharpExceptionCallback_t callback;
} SWIG_CSharpException_t;

typedef struct {
  SWIG_CSharpExceptionArgumentCodes code;
  SWIG_CSharpExceptionArgumentCallback_t callback;
} SWIG_CSharpExceptionArgument_t;

static SWIG_CSharpException_t SWIG_csharp_exceptions[] = {
  { SWIG_CSharpApplicationException, NULL },
  { SWIG_CSharpArithmeticException, NULL },
  { SWIG_CSharpDivideByZeroException, NULL },
  { SWIG_CSharpIndexOutOfRangeException, NULL },
  { SWIG_CSharpInvalidCastException, NULL },
  { SWIG_CSharpInvalidOperationException, NULL },
  { SWIG_CSharpIOException, NULL },
  { SWIG_CSharpNullReferenceException, NULL },
  { SWIG_CSharpOutOfMemoryException, NULL },
  { SWIG_CSharpOverflowException, NULL },
  { SWIG_CSharpSystemException, NULL }
};

static SWIG_CSharpExceptionArgument_t SWIG_csharp_exceptions_argument[] = {
  { SWIG_CSharpArgumentException, NULL },
  { SWIG_CSharpArgumentNullException, NULL },
  { SWIG_CSharpArgumentOutOfRangeException, NULL }
};

static void SWIGUNUSED SWIG_CSharpSetPendingException(SWIG_CSharpExceptionCodes code, const char *msg) {
  SWIG_CSharpExceptionCallback_t callback = SWIG_csharp_exceptions[SWIG_CSharpApplicationException].callback;
  if ((size_t)code < sizeof(SWIG_csharp_exceptions)/sizeof(SWIG_CSharpException_t)) {
    callback = SWIG_csharp_exceptions[code].callback;
  }
  callback(msg);
}

static void SWIGUNUSED SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpExceptionArgumentCodes code, const char *msg, const char *param_name) {
  SWIG_CSharpExceptionArgumentCallback_t callback = SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentException].callback;
  if ((size_t)code < sizeof(SWIG_csharp_exceptions_argument)/sizeof(SWIG_CSharpExceptionArgument_t)) {
    callback = SWIG_csharp_exceptions_argument[code].callback;
  }
  callback(msg, param_name);
}


#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterExceptionCallbacks_CNTKLib(
                                                SWIG_CSharpExceptionCallback_t applicationCallback,
                                                SWIG_CSharpExceptionCallback_t arithmeticCallback,
                                                SWIG_CSharpExceptionCallback_t divideByZeroCallback, 
                                                SWIG_CSharpExceptionCallback_t indexOutOfRangeCallback, 
                                                SWIG_CSharpExceptionCallback_t invalidCastCallback,
                                                SWIG_CSharpExceptionCallback_t invalidOperationCallback,
                                                SWIG_CSharpExceptionCallback_t ioCallback,
                                                SWIG_CSharpExceptionCallback_t nullReferenceCallback,
                                                SWIG_CSharpExceptionCallback_t outOfMemoryCallback, 
                                                SWIG_CSharpExceptionCallback_t overflowCallback, 
                                                SWIG_CSharpExceptionCallback_t systemCallback) {
  SWIG_csharp_exceptions[SWIG_CSharpApplicationException].callback = applicationCallback;
  SWIG_csharp_exceptions[SWIG_CSharpArithmeticException].callback = arithmeticCallback;
  SWIG_csharp_exceptions[SWIG_CSharpDivideByZeroException].callback = divideByZeroCallback;
  SWIG_csharp_exceptions[SWIG_CSharpIndexOutOfRangeException].callback = indexOutOfRangeCallback;
  SWIG_csharp_exceptions[SWIG_CSharpInvalidCastException].callback = invalidCastCallback;
  SWIG_csharp_exceptions[SWIG_CSharpInvalidOperationException].callback = invalidOperationCallback;
  SWIG_csharp_exceptions[SWIG_CSharpIOException].callback = ioCallback;
  SWIG_csharp_exceptions[SWIG_CSharpNullReferenceException].callback = nullReferenceCallback;
  SWIG_csharp_exceptions[SWIG_CSharpOutOfMemoryException].callback = outOfMemoryCallback;
  SWIG_csharp_exceptions[SWIG_CSharpOverflowException].callback = overflowCallback;
  SWIG_csharp_exceptions[SWIG_CSharpSystemException].callback = systemCallback;
}

#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterExceptionArgumentCallbacks_CNTKLib(
                                                SWIG_CSharpExceptionArgumentCallback_t argumentCallback,
                                                SWIG_CSharpExceptionArgumentCallback_t argumentNullCallback,
                                                SWIG_CSharpExceptionArgumentCallback_t argumentOutOfRangeCallback) {
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentException].callback = argumentCallback;
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentNullException].callback = argumentNullCallback;
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentOutOfRangeException].callback = argumentOutOfRangeCallback;
}


/* Callback for returning strings to C# without leaking memory */
typedef char * (SWIGSTDCALL* SWIG_CSharpStringHelperCallback)(const char *);
static SWIG_CSharpStringHelperCallback SWIG_csharp_string_callback = NULL;


#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterStringCallback_CNTKLib(SWIG_CSharpStringHelperCallback callback) {
  SWIG_csharp_string_callback = callback;
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, msg, ""); return nullreturn; } else

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13




/* Callback for returning strings to C# without leaking memory */
typedef void * (SWIGSTDCALL* SWIG_CSharpWStringHelperCallback)(const wchar_t *);
static SWIG_CSharpWStringHelperCallback SWIG_csharp_wstring_callback = NULL;


#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterWStringCallback_CNTKLib(SWIG_CSharpWStringHelperCallback callback) {
  SWIG_csharp_wstring_callback = callback;
}

/* -----------------------------------------------------------------------------
 * director_common.swg
 *
 * This file contains support for director classes which is common between
 * languages.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_STATIC if you prefer to avoid the use of the
  'Swig' namespace. This could be useful for multi-modules projects.
*/
#ifdef SWIG_DIRECTOR_STATIC
/* Force anonymous (static) namespace */
#define Swig
#endif
/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that C# proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

#if defined(DEBUG_DIRECTOR_OWNED)
#include <iostream>
#endif
#include <string>
#include <exception>

namespace Swig {
  /* Director base class - not currently used in C# directors */
  class Director {
  };

  /* Base class for director exceptions */
  class DirectorException : public std::exception {
  protected:
    std::string swig_msg;

  public:
    DirectorException(const char *msg) : swig_msg(msg) {
    }

    DirectorException(const std::string &msg) : swig_msg(msg) {
    }

    virtual ~DirectorException() throw() {
    }

    const char *what() const throw() {
      return swig_msg.c_str();
    }
  };

  /* Pure virtual method exception */
  class DirectorPureVirtualException : public DirectorException {
  public:
    DirectorPureVirtualException(const char *msg) : DirectorException(std::string("Attempt to invoke pure virtual method ") + msg) {
    }
  };
}


#include <stdexcept>


#include <string>


#include <vector>
#include <algorithm>
#include <stdexcept>


#include <map>
#include <algorithm>
#include <stdexcept>


SWIGINTERN void SWIG_CSharpException(int code, const char *msg) {
  if (code == SWIG_ValueError) {
    SWIG_CSharpExceptionArgumentCodes exception_code = SWIG_CSharpArgumentOutOfRangeException;
    SWIG_CSharpSetPendingExceptionArgument(exception_code, msg, 0);
  } else {
    SWIG_CSharpExceptionCodes exception_code = SWIG_CSharpApplicationException;
    switch(code) {
    case SWIG_MemoryError:
      exception_code = SWIG_CSharpOutOfMemoryException;
      break;
    case SWIG_IndexError:
      exception_code = SWIG_CSharpIndexOutOfRangeException;
      break;
    case SWIG_DivisionByZero:
      exception_code = SWIG_CSharpDivideByZeroException;
      break;
    case SWIG_IOError:
      exception_code = SWIG_CSharpIOException;
      break;
    case SWIG_OverflowError:
      exception_code = SWIG_CSharpOverflowException;
      break;
    case SWIG_RuntimeError:
    case SWIG_TypeError:
    case SWIG_SyntaxError:
    case SWIG_SystemError:
    case SWIG_UnknownError:
    default:
      exception_code = SWIG_CSharpApplicationException;
      break;
    }
    SWIG_CSharpSetPendingException(exception_code, msg);
  }
}


#include <stdexcept>


#include <utility>


#include <string>


#include <stdio.h>


#include <unordered_map>
#include <algorithm>
#include <stdexcept>


    #include "CNTKLibrary.h"
    #pragma warning(disable : 4100) //unreferenced formal parameter

SWIGINTERN std::vector< char > *new_std_vector_Sl_char_Sg___SWIG_2(int capacity){
        std::vector< char >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< char >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN char std_vector_Sl_char_Sg__getitemcopy(std::vector< char > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN char const &std_vector_Sl_char_Sg__getitem(std::vector< char > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_char_Sg__setitem(std::vector< char > *self,int index,char const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_char_Sg__AddRange(std::vector< char > *self,std::vector< char > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< char > *std_vector_Sl_char_Sg__GetRange(std::vector< char > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< char >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_char_Sg__Insert(std::vector< char > *self,int index,char const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_char_Sg__InsertRange(std::vector< char > *self,int index,std::vector< char > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_char_Sg__RemoveAt(std::vector< char > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_char_Sg__RemoveRange(std::vector< char > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< char > *std_vector_Sl_char_Sg__Repeat(char const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< char >(count, value);
      }
SWIGINTERN void std_vector_Sl_char_Sg__Reverse__SWIG_0(std::vector< char > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_char_Sg__Reverse__SWIG_1(std::vector< char > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_char_Sg__SetRange(std::vector< char > *self,int index,std::vector< char > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_char_Sg__Contains(std::vector< char > *self,char const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_char_Sg__IndexOf(std::vector< char > *self,char const &value){
        int index = -1;
        std::vector< char >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_char_Sg__LastIndexOf(std::vector< char > *self,char const &value){
        int index = -1;
        std::vector< char >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_char_Sg__Remove(std::vector< char > *self,char const &value){
        std::vector< char >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< int > *new_std_vector_Sl_int_Sg___SWIG_2(int capacity){
        std::vector< int >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< int >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN int std_vector_Sl_int_Sg__getitemcopy(std::vector< int > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN int const &std_vector_Sl_int_Sg__getitem(std::vector< int > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__setitem(std::vector< int > *self,int index,int const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__AddRange(std::vector< int > *self,std::vector< int > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< int > *std_vector_Sl_int_Sg__GetRange(std::vector< int > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< int >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_int_Sg__Insert(std::vector< int > *self,int index,int const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__InsertRange(std::vector< int > *self,int index,std::vector< int > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__RemoveAt(std::vector< int > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__RemoveRange(std::vector< int > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< int > *std_vector_Sl_int_Sg__Repeat(int const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< int >(count, value);
      }
SWIGINTERN void std_vector_Sl_int_Sg__Reverse__SWIG_0(std::vector< int > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_int_Sg__Reverse__SWIG_1(std::vector< int > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_int_Sg__SetRange(std::vector< int > *self,int index,std::vector< int > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_int_Sg__Contains(std::vector< int > *self,int const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_int_Sg__IndexOf(std::vector< int > *self,int const &value){
        int index = -1;
        std::vector< int >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_int_Sg__LastIndexOf(std::vector< int > *self,int const &value){
        int index = -1;
        std::vector< int >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_int_Sg__Remove(std::vector< int > *self,int const &value){
        std::vector< int >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< size_t > *new_std_vector_Sl_size_t_Sg___SWIG_2(int capacity){
        std::vector< size_t >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< size_t >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN size_t std_vector_Sl_size_t_Sg__getitemcopy(std::vector< size_t > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN size_t const &std_vector_Sl_size_t_Sg__getitem(std::vector< size_t > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_size_t_Sg__setitem(std::vector< size_t > *self,int index,size_t const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_size_t_Sg__AddRange(std::vector< size_t > *self,std::vector< size_t > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< size_t > *std_vector_Sl_size_t_Sg__GetRange(std::vector< size_t > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< size_t >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_size_t_Sg__Insert(std::vector< size_t > *self,int index,size_t const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_size_t_Sg__InsertRange(std::vector< size_t > *self,int index,std::vector< size_t > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_size_t_Sg__RemoveAt(std::vector< size_t > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_size_t_Sg__RemoveRange(std::vector< size_t > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< size_t > *std_vector_Sl_size_t_Sg__Repeat(size_t const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< size_t >(count, value);
      }
SWIGINTERN void std_vector_Sl_size_t_Sg__Reverse__SWIG_0(std::vector< size_t > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_size_t_Sg__Reverse__SWIG_1(std::vector< size_t > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_size_t_Sg__SetRange(std::vector< size_t > *self,int index,std::vector< size_t > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_size_t_Sg__Contains(std::vector< size_t > *self,size_t const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_size_t_Sg__IndexOf(std::vector< size_t > *self,size_t const &value){
        int index = -1;
        std::vector< size_t >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_size_t_Sg__LastIndexOf(std::vector< size_t > *self,size_t const &value){
        int index = -1;
        std::vector< size_t >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_size_t_Sg__Remove(std::vector< size_t > *self,size_t const &value){
        std::vector< size_t >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< double > *new_std_vector_Sl_double_Sg___SWIG_2(int capacity){
        std::vector< double >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< double >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN double std_vector_Sl_double_Sg__getitemcopy(std::vector< double > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN double const &std_vector_Sl_double_Sg__getitem(std::vector< double > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__setitem(std::vector< double > *self,int index,double const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__AddRange(std::vector< double > *self,std::vector< double > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< double > *std_vector_Sl_double_Sg__GetRange(std::vector< double > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< double >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_double_Sg__Insert(std::vector< double > *self,int index,double const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__InsertRange(std::vector< double > *self,int index,std::vector< double > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__RemoveAt(std::vector< double > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__RemoveRange(std::vector< double > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< double > *std_vector_Sl_double_Sg__Repeat(double const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< double >(count, value);
      }
SWIGINTERN void std_vector_Sl_double_Sg__Reverse__SWIG_0(std::vector< double > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_double_Sg__Reverse__SWIG_1(std::vector< double > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_double_Sg__SetRange(std::vector< double > *self,int index,std::vector< double > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_double_Sg__Contains(std::vector< double > *self,double const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_double_Sg__IndexOf(std::vector< double > *self,double const &value){
        int index = -1;
        std::vector< double >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_double_Sg__LastIndexOf(std::vector< double > *self,double const &value){
        int index = -1;
        std::vector< double >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_double_Sg__Remove(std::vector< double > *self,double const &value){
        std::vector< double >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }

struct SWIG_null_deleter {
  void operator() (void const *) const {
  }
};
#define SWIG_NO_NULL_DELETER_0 , SWIG_null_deleter()
#define SWIG_NO_NULL_DELETER_1
#define SWIG_NO_NULL_DELETER_SWIG_POINTER_NEW
#define SWIG_NO_NULL_DELETER_SWIG_POINTER_OWN

SWIGINTERN std::vector< float > *new_std_vector_Sl_float_Sg___SWIG_2(int capacity){
        std::vector< float >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< float >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN float std_vector_Sl_float_Sg__getitemcopy(std::vector< float > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN float const &std_vector_Sl_float_Sg__getitem(std::vector< float > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_float_Sg__setitem(std::vector< float > *self,int index,float const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_float_Sg__AddRange(std::vector< float > *self,std::vector< float > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< float > *std_vector_Sl_float_Sg__GetRange(std::vector< float > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< float >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_float_Sg__Insert(std::vector< float > *self,int index,float const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_float_Sg__InsertRange(std::vector< float > *self,int index,std::vector< float > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_float_Sg__RemoveAt(std::vector< float > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_float_Sg__RemoveRange(std::vector< float > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< float > *std_vector_Sl_float_Sg__Repeat(float const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< float >(count, value);
      }
SWIGINTERN void std_vector_Sl_float_Sg__Reverse__SWIG_0(std::vector< float > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_float_Sg__Reverse__SWIG_1(std::vector< float > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_float_Sg__SetRange(std::vector< float > *self,int index,std::vector< float > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_float_Sg__Contains(std::vector< float > *self,float const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_float_Sg__IndexOf(std::vector< float > *self,float const &value){
        int index = -1;
        std::vector< float >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_float_Sg__LastIndexOf(std::vector< float > *self,float const &value){
        int index = -1;
        std::vector< float >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_float_Sg__Remove(std::vector< float > *self,float const &value){
        std::vector< float >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< CNTK::Variable > *new_std_vector_Sl_CNTK_Variable_Sg___SWIG_2(int capacity){
        std::vector< CNTK::Variable >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< CNTK::Variable >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN CNTK::Variable std_vector_Sl_CNTK_Variable_Sg__getitemcopy(std::vector< CNTK::Variable > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN CNTK::Variable const &std_vector_Sl_CNTK_Variable_Sg__getitem(std::vector< CNTK::Variable > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Variable_Sg__setitem(std::vector< CNTK::Variable > *self,int index,CNTK::Variable const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Variable_Sg__AddRange(std::vector< CNTK::Variable > *self,std::vector< CNTK::Variable > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< CNTK::Variable > *std_vector_Sl_CNTK_Variable_Sg__GetRange(std::vector< CNTK::Variable > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< CNTK::Variable >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_Variable_Sg__Insert(std::vector< CNTK::Variable > *self,int index,CNTK::Variable const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Variable_Sg__InsertRange(std::vector< CNTK::Variable > *self,int index,std::vector< CNTK::Variable > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Variable_Sg__RemoveAt(std::vector< CNTK::Variable > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Variable_Sg__RemoveRange(std::vector< CNTK::Variable > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< CNTK::Variable > *std_vector_Sl_CNTK_Variable_Sg__Repeat(CNTK::Variable const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< CNTK::Variable >(count, value);
      }
SWIGINTERN void std_vector_Sl_CNTK_Variable_Sg__Reverse__SWIG_0(std::vector< CNTK::Variable > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_CNTK_Variable_Sg__Reverse__SWIG_1(std::vector< CNTK::Variable > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_Variable_Sg__SetRange(std::vector< CNTK::Variable > *self,int index,std::vector< CNTK::Variable > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_CNTK_Variable_Sg__Contains(std::vector< CNTK::Variable > *self,CNTK::Variable const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_CNTK_Variable_Sg__IndexOf(std::vector< CNTK::Variable > *self,CNTK::Variable const &value){
        int index = -1;
        std::vector< CNTK::Variable >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_CNTK_Variable_Sg__LastIndexOf(std::vector< CNTK::Variable > *self,CNTK::Variable const &value){
        int index = -1;
        std::vector< CNTK::Variable >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_CNTK_Variable_Sg__Remove(std::vector< CNTK::Variable > *self,CNTK::Variable const &value){
        std::vector< CNTK::Variable >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< CNTK::Axis > *new_std_vector_Sl_CNTK_Axis_Sg___SWIG_2(int capacity){
        std::vector< CNTK::Axis >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< CNTK::Axis >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN CNTK::Axis std_vector_Sl_CNTK_Axis_Sg__getitemcopy(std::vector< CNTK::Axis > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN CNTK::Axis const &std_vector_Sl_CNTK_Axis_Sg__getitem(std::vector< CNTK::Axis > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Axis_Sg__setitem(std::vector< CNTK::Axis > *self,int index,CNTK::Axis const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Axis_Sg__AddRange(std::vector< CNTK::Axis > *self,std::vector< CNTK::Axis > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< CNTK::Axis > *std_vector_Sl_CNTK_Axis_Sg__GetRange(std::vector< CNTK::Axis > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< CNTK::Axis >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_Axis_Sg__Insert(std::vector< CNTK::Axis > *self,int index,CNTK::Axis const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Axis_Sg__InsertRange(std::vector< CNTK::Axis > *self,int index,std::vector< CNTK::Axis > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Axis_Sg__RemoveAt(std::vector< CNTK::Axis > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Axis_Sg__RemoveRange(std::vector< CNTK::Axis > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< CNTK::Axis > *std_vector_Sl_CNTK_Axis_Sg__Repeat(CNTK::Axis const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< CNTK::Axis >(count, value);
      }
SWIGINTERN void std_vector_Sl_CNTK_Axis_Sg__Reverse__SWIG_0(std::vector< CNTK::Axis > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_CNTK_Axis_Sg__Reverse__SWIG_1(std::vector< CNTK::Axis > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_Axis_Sg__SetRange(std::vector< CNTK::Axis > *self,int index,std::vector< CNTK::Axis > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_CNTK_Axis_Sg__Contains(std::vector< CNTK::Axis > *self,CNTK::Axis const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_CNTK_Axis_Sg__IndexOf(std::vector< CNTK::Axis > *self,CNTK::Axis const &value){
        int index = -1;
        std::vector< CNTK::Axis >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_CNTK_Axis_Sg__LastIndexOf(std::vector< CNTK::Axis > *self,CNTK::Axis const &value){
        int index = -1;
        std::vector< CNTK::Axis >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_CNTK_Axis_Sg__Remove(std::vector< CNTK::Axis > *self,CNTK::Axis const &value){
        std::vector< CNTK::Axis >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< std::shared_ptr< CNTK::NDArrayView > > *new_std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::shared_ptr<CNTK::NDArrayView> >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::shared_ptr<CNTK::NDArrayView> >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::shared_ptr< CNTK::NDArrayView > std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__getitemcopy(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::shared_ptr< CNTK::NDArrayView > const &std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__getitem(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__setitem(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,int index,std::shared_ptr< CNTK::NDArrayView > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__AddRange(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,std::vector< std::shared_ptr< CNTK::NDArrayView > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::shared_ptr< CNTK::NDArrayView > > *std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__GetRange(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::shared_ptr<CNTK::NDArrayView> >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Insert(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,int index,std::shared_ptr< CNTK::NDArrayView > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__InsertRange(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,int index,std::vector< std::shared_ptr< CNTK::NDArrayView > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__RemoveAt(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__RemoveRange(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::shared_ptr< CNTK::NDArrayView > > *std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Repeat(std::shared_ptr< CNTK::NDArrayView > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::shared_ptr<CNTK::NDArrayView> >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Reverse__SWIG_0(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Reverse__SWIG_1(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__SetRange(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,int index,std::vector< std::shared_ptr< CNTK::NDArrayView > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Contains(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,std::shared_ptr< CNTK::NDArrayView > const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__IndexOf(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,std::shared_ptr< CNTK::NDArrayView > const &value){
        int index = -1;
        std::vector< std::shared_ptr<CNTK::NDArrayView> >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__LastIndexOf(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,std::shared_ptr< CNTK::NDArrayView > const &value){
        int index = -1;
        std::vector< std::shared_ptr<CNTK::NDArrayView> >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Remove(std::vector< std::shared_ptr< CNTK::NDArrayView > > *self,std::shared_ptr< CNTK::NDArrayView > const &value){
        std::vector< std::shared_ptr<CNTK::NDArrayView> >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< bool > *new_std_vector_Sl_bool_Sg___SWIG_2(int capacity){
        std::vector< bool >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< bool >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN bool std_vector_Sl_bool_Sg__getitemcopy(std::vector< bool > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN bool std_vector_Sl_bool_Sg__getitem(std::vector< bool > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_bool_Sg__setitem(std::vector< bool > *self,int index,bool const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_bool_Sg__AddRange(std::vector< bool > *self,std::vector< bool > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< bool > *std_vector_Sl_bool_Sg__GetRange(std::vector< bool > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< bool >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_bool_Sg__Insert(std::vector< bool > *self,int index,bool const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_bool_Sg__InsertRange(std::vector< bool > *self,int index,std::vector< bool > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_bool_Sg__RemoveAt(std::vector< bool > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_bool_Sg__RemoveRange(std::vector< bool > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< bool > *std_vector_Sl_bool_Sg__Repeat(bool const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< bool >(count, value);
      }
SWIGINTERN void std_vector_Sl_bool_Sg__Reverse__SWIG_0(std::vector< bool > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_bool_Sg__Reverse__SWIG_1(std::vector< bool > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_bool_Sg__SetRange(std::vector< bool > *self,int index,std::vector< bool > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_bool_Sg__Contains(std::vector< bool > *self,bool const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_bool_Sg__IndexOf(std::vector< bool > *self,bool const &value){
        int index = -1;
        std::vector< bool >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_bool_Sg__LastIndexOf(std::vector< bool > *self,bool const &value){
        int index = -1;
        std::vector< bool >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_bool_Sg__Remove(std::vector< bool > *self,bool const &value){
        std::vector< bool >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< CNTK::DeviceDescriptor > *new_std_vector_Sl_CNTK_DeviceDescriptor_Sg___SWIG_2(int capacity){
        std::vector< CNTK::DeviceDescriptor >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< CNTK::DeviceDescriptor >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN CNTK::DeviceDescriptor std_vector_Sl_CNTK_DeviceDescriptor_Sg__getitemcopy(std::vector< CNTK::DeviceDescriptor > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN CNTK::DeviceDescriptor const &std_vector_Sl_CNTK_DeviceDescriptor_Sg__getitem(std::vector< CNTK::DeviceDescriptor > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_DeviceDescriptor_Sg__setitem(std::vector< CNTK::DeviceDescriptor > *self,int index,CNTK::DeviceDescriptor const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_DeviceDescriptor_Sg__AddRange(std::vector< CNTK::DeviceDescriptor > *self,std::vector< CNTK::DeviceDescriptor > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< CNTK::DeviceDescriptor > *std_vector_Sl_CNTK_DeviceDescriptor_Sg__GetRange(std::vector< CNTK::DeviceDescriptor > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< CNTK::DeviceDescriptor >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_DeviceDescriptor_Sg__Insert(std::vector< CNTK::DeviceDescriptor > *self,int index,CNTK::DeviceDescriptor const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_DeviceDescriptor_Sg__InsertRange(std::vector< CNTK::DeviceDescriptor > *self,int index,std::vector< CNTK::DeviceDescriptor > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_DeviceDescriptor_Sg__RemoveAt(std::vector< CNTK::DeviceDescriptor > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_DeviceDescriptor_Sg__RemoveRange(std::vector< CNTK::DeviceDescriptor > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< CNTK::DeviceDescriptor > *std_vector_Sl_CNTK_DeviceDescriptor_Sg__Repeat(CNTK::DeviceDescriptor const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< CNTK::DeviceDescriptor >(count, value);
      }
SWIGINTERN void std_vector_Sl_CNTK_DeviceDescriptor_Sg__Reverse__SWIG_0(std::vector< CNTK::DeviceDescriptor > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_CNTK_DeviceDescriptor_Sg__Reverse__SWIG_1(std::vector< CNTK::DeviceDescriptor > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_DeviceDescriptor_Sg__SetRange(std::vector< CNTK::DeviceDescriptor > *self,int index,std::vector< CNTK::DeviceDescriptor > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_CNTK_DeviceDescriptor_Sg__Contains(std::vector< CNTK::DeviceDescriptor > *self,CNTK::DeviceDescriptor const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_CNTK_DeviceDescriptor_Sg__IndexOf(std::vector< CNTK::DeviceDescriptor > *self,CNTK::DeviceDescriptor const &value){
        int index = -1;
        std::vector< CNTK::DeviceDescriptor >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_CNTK_DeviceDescriptor_Sg__LastIndexOf(std::vector< CNTK::DeviceDescriptor > *self,CNTK::DeviceDescriptor const &value){
        int index = -1;
        std::vector< CNTK::DeviceDescriptor >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_CNTK_DeviceDescriptor_Sg__Remove(std::vector< CNTK::DeviceDescriptor > *self,CNTK::DeviceDescriptor const &value){
        std::vector< CNTK::DeviceDescriptor >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< std::vector< size_t > > *new_std_vector_Sl_std_vector_Sl_size_t_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::vector< size_t > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::vector< size_t > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::vector< size_t > std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__getitemcopy(std::vector< std::vector< size_t > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< size_t > const &std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__getitem(std::vector< std::vector< size_t > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__setitem(std::vector< std::vector< size_t > > *self,int index,std::vector< size_t > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__AddRange(std::vector< std::vector< size_t > > *self,std::vector< std::vector< size_t > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::vector< size_t > > *std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__GetRange(std::vector< std::vector< size_t > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::vector< size_t > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__Insert(std::vector< std::vector< size_t > > *self,int index,std::vector< size_t > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__InsertRange(std::vector< std::vector< size_t > > *self,int index,std::vector< std::vector< size_t > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__RemoveAt(std::vector< std::vector< size_t > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__RemoveRange(std::vector< std::vector< size_t > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::vector< size_t > > *std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__Repeat(std::vector< size_t > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::vector< size_t > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__Reverse__SWIG_0(std::vector< std::vector< size_t > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__Reverse__SWIG_1(std::vector< std::vector< size_t > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__SetRange(std::vector< std::vector< size_t > > *self,int index,std::vector< std::vector< size_t > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< std::vector< float > > *new_std_vector_Sl_std_vector_Sl_float_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::vector< float > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::vector< float > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::vector< float > std_vector_Sl_std_vector_Sl_float_Sg__Sg__getitemcopy(std::vector< std::vector< float > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< float > const &std_vector_Sl_std_vector_Sl_float_Sg__Sg__getitem(std::vector< std::vector< float > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__setitem(std::vector< std::vector< float > > *self,int index,std::vector< float > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__AddRange(std::vector< std::vector< float > > *self,std::vector< std::vector< float > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::vector< float > > *std_vector_Sl_std_vector_Sl_float_Sg__Sg__GetRange(std::vector< std::vector< float > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::vector< float > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__Insert(std::vector< std::vector< float > > *self,int index,std::vector< float > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__InsertRange(std::vector< std::vector< float > > *self,int index,std::vector< std::vector< float > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__RemoveAt(std::vector< std::vector< float > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__RemoveRange(std::vector< std::vector< float > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::vector< float > > *std_vector_Sl_std_vector_Sl_float_Sg__Sg__Repeat(std::vector< float > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::vector< float > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__Reverse__SWIG_0(std::vector< std::vector< float > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__Reverse__SWIG_1(std::vector< std::vector< float > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__SetRange(std::vector< std::vector< float > > *self,int index,std::vector< std::vector< float > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< std::vector< double > > *new_std_vector_Sl_std_vector_Sl_double_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::vector< double > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::vector< double > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::vector< double > std_vector_Sl_std_vector_Sl_double_Sg__Sg__getitemcopy(std::vector< std::vector< double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< double > const &std_vector_Sl_std_vector_Sl_double_Sg__Sg__getitem(std::vector< std::vector< double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__setitem(std::vector< std::vector< double > > *self,int index,std::vector< double > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__AddRange(std::vector< std::vector< double > > *self,std::vector< std::vector< double > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::vector< double > > *std_vector_Sl_std_vector_Sl_double_Sg__Sg__GetRange(std::vector< std::vector< double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::vector< double > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__Insert(std::vector< std::vector< double > > *self,int index,std::vector< double > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__InsertRange(std::vector< std::vector< double > > *self,int index,std::vector< std::vector< double > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__RemoveAt(std::vector< std::vector< double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__RemoveRange(std::vector< std::vector< double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::vector< double > > *std_vector_Sl_std_vector_Sl_double_Sg__Sg__Repeat(std::vector< double > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::vector< double > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__Reverse__SWIG_0(std::vector< std::vector< double > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__Reverse__SWIG_1(std::vector< std::vector< double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__SetRange(std::vector< std::vector< double > > *self,int index,std::vector< std::vector< double > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::mapped_type const &std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__getitem(std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *self,std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type const &key){
            std::unordered_map< CNTK::Variable, std::shared_ptr< CNTK::Value >>::iterator iter = self->find(key);
            if (iter != self->end())
                return iter->second;
            else
                throw std::out_of_range("key not found");
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__setitem(std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *self,std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type const &key,std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::mapped_type const &x){
            (*self)[key] = x;
            }
SWIGINTERN bool std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__ContainsKey(std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *self,std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type const &key){
            std::unordered_map< CNTK::Variable, std::shared_ptr< CNTK::Value >>::iterator iter = self->find(key);
            return iter != self->end();
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__Add(std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *self,std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type const &key,std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::mapped_type const &val){
            std::unordered_map< CNTK::Variable, std::shared_ptr< CNTK::Value >>::iterator iter = self->find(key);
            if (iter != self->end())
                throw std::out_of_range("key already exists");
            self->insert(std::pair< CNTK::Variable, std::shared_ptr< CNTK::Value > >(key, val));
            }
SWIGINTERN bool std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__Remove(std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *self,std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type const &key){
            std::unordered_map< CNTK::Variable, std::shared_ptr< CNTK::Value >>::iterator iter = self->find(key);
            if (iter != self->end()) {
                self->erase(iter);
                return true;
            }                
            return false;
            }
SWIGINTERN std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::iterator *std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__create_iterator_begin(std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *self){
            return new std::unordered_map< CNTK::Variable, std::shared_ptr< CNTK::Value >>::iterator(self->begin());
            }
SWIGINTERN std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type const &std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__get_next_key(std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *self,std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::iterator *swigiterator){
            std::unordered_map< CNTK::Variable, std::shared_ptr< CNTK::Value >>::iterator iter = *swigiterator;
            (*swigiterator)++;
            return (*iter).first;
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__destroy_iterator(std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *self,std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::iterator *swigiterator){
            delete swigiterator;
            }
SWIGINTERN std::unordered_map< CNTK::Variable,CNTK::Variable >::mapped_type const &std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__getitem(std::unordered_map< CNTK::Variable,CNTK::Variable > *self,std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type const &key){
            std::unordered_map< CNTK::Variable, CNTK::Variable>::iterator iter = self->find(key);
            if (iter != self->end())
                return iter->second;
            else
                throw std::out_of_range("key not found");
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__setitem(std::unordered_map< CNTK::Variable,CNTK::Variable > *self,std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type const &key,std::unordered_map< CNTK::Variable,CNTK::Variable >::mapped_type const &x){
            (*self)[key] = x;
            }
SWIGINTERN bool std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__ContainsKey(std::unordered_map< CNTK::Variable,CNTK::Variable > *self,std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type const &key){
            std::unordered_map< CNTK::Variable, CNTK::Variable>::iterator iter = self->find(key);
            return iter != self->end();
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Add(std::unordered_map< CNTK::Variable,CNTK::Variable > *self,std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type const &key,std::unordered_map< CNTK::Variable,CNTK::Variable >::mapped_type const &val){
            std::unordered_map< CNTK::Variable, CNTK::Variable>::iterator iter = self->find(key);
            if (iter != self->end())
                throw std::out_of_range("key already exists");
            self->insert(std::pair< CNTK::Variable, CNTK::Variable >(key, val));
            }
SWIGINTERN bool std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Remove(std::unordered_map< CNTK::Variable,CNTK::Variable > *self,std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type const &key){
            std::unordered_map< CNTK::Variable, CNTK::Variable>::iterator iter = self->find(key);
            if (iter != self->end()) {
                self->erase(iter);
                return true;
            }                
            return false;
            }
SWIGINTERN std::unordered_map< CNTK::Variable,CNTK::Variable >::iterator *std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__create_iterator_begin(std::unordered_map< CNTK::Variable,CNTK::Variable > *self){
            return new std::unordered_map< CNTK::Variable, CNTK::Variable>::iterator(self->begin());
            }
SWIGINTERN std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type const &std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__get_next_key(std::unordered_map< CNTK::Variable,CNTK::Variable > *self,std::unordered_map< CNTK::Variable,CNTK::Variable >::iterator *swigiterator){
            std::unordered_map< CNTK::Variable, CNTK::Variable>::iterator iter = *swigiterator;
            (*swigiterator)++;
            return (*iter).first;
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__destroy_iterator(std::unordered_map< CNTK::Variable,CNTK::Variable > *self,std::unordered_map< CNTK::Variable,CNTK::Variable >::iterator *swigiterator){
            delete swigiterator;
            }
SWIGINTERN std::vector< std::shared_ptr< CNTK::Function > > *new_std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::shared_ptr< CNTK::Function > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::shared_ptr< CNTK::Function > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::shared_ptr< CNTK::Function > std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__getitemcopy(std::vector< std::shared_ptr< CNTK::Function > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::shared_ptr< CNTK::Function > const &std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__getitem(std::vector< std::shared_ptr< CNTK::Function > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__setitem(std::vector< std::shared_ptr< CNTK::Function > > *self,int index,std::shared_ptr< CNTK::Function > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__AddRange(std::vector< std::shared_ptr< CNTK::Function > > *self,std::vector< std::shared_ptr< CNTK::Function > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::shared_ptr< CNTK::Function > > *std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__GetRange(std::vector< std::shared_ptr< CNTK::Function > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::shared_ptr< CNTK::Function > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__Insert(std::vector< std::shared_ptr< CNTK::Function > > *self,int index,std::shared_ptr< CNTK::Function > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__InsertRange(std::vector< std::shared_ptr< CNTK::Function > > *self,int index,std::vector< std::shared_ptr< CNTK::Function > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__RemoveAt(std::vector< std::shared_ptr< CNTK::Function > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__RemoveRange(std::vector< std::shared_ptr< CNTK::Function > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::shared_ptr< CNTK::Function > > *std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__Repeat(std::shared_ptr< CNTK::Function > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::shared_ptr< CNTK::Function > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__Reverse__SWIG_0(std::vector< std::shared_ptr< CNTK::Function > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__Reverse__SWIG_1(std::vector< std::shared_ptr< CNTK::Function > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__SetRange(std::vector< std::shared_ptr< CNTK::Function > > *self,int index,std::vector< std::shared_ptr< CNTK::Function > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< unsigned char > *new_std_vector_Sl_unsigned_SS_char_Sg___SWIG_2(int capacity){
        std::vector< unsigned char >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< unsigned char >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN unsigned char std_vector_Sl_unsigned_SS_char_Sg__getitemcopy(std::vector< unsigned char > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN unsigned char const &std_vector_Sl_unsigned_SS_char_Sg__getitem(std::vector< unsigned char > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_char_Sg__setitem(std::vector< unsigned char > *self,int index,unsigned char const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_char_Sg__AddRange(std::vector< unsigned char > *self,std::vector< unsigned char > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< unsigned char > *std_vector_Sl_unsigned_SS_char_Sg__GetRange(std::vector< unsigned char > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< unsigned char >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_char_Sg__Insert(std::vector< unsigned char > *self,int index,unsigned char const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_char_Sg__InsertRange(std::vector< unsigned char > *self,int index,std::vector< unsigned char > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_char_Sg__RemoveAt(std::vector< unsigned char > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_char_Sg__RemoveRange(std::vector< unsigned char > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< unsigned char > *std_vector_Sl_unsigned_SS_char_Sg__Repeat(unsigned char const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< unsigned char >(count, value);
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_char_Sg__Reverse__SWIG_0(std::vector< unsigned char > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_char_Sg__Reverse__SWIG_1(std::vector< unsigned char > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_char_Sg__SetRange(std::vector< unsigned char > *self,int index,std::vector< unsigned char > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_unsigned_SS_char_Sg__Contains(std::vector< unsigned char > *self,unsigned char const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_unsigned_SS_char_Sg__IndexOf(std::vector< unsigned char > *self,unsigned char const &value){
        int index = -1;
        std::vector< unsigned char >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_unsigned_SS_char_Sg__LastIndexOf(std::vector< unsigned char > *self,unsigned char const &value){
        int index = -1;
        std::vector< unsigned char >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_unsigned_SS_char_Sg__Remove(std::vector< unsigned char > *self,unsigned char const &value){
        std::vector< unsigned char >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< CNTK::Dictionary > *new_std_vector_Sl_CNTK_Dictionary_Sg___SWIG_2(int capacity){
        std::vector< CNTK::Dictionary >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< CNTK::Dictionary >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN CNTK::Dictionary std_vector_Sl_CNTK_Dictionary_Sg__getitemcopy(std::vector< CNTK::Dictionary > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN CNTK::Dictionary const &std_vector_Sl_CNTK_Dictionary_Sg__getitem(std::vector< CNTK::Dictionary > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Dictionary_Sg__setitem(std::vector< CNTK::Dictionary > *self,int index,CNTK::Dictionary const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Dictionary_Sg__AddRange(std::vector< CNTK::Dictionary > *self,std::vector< CNTK::Dictionary > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< CNTK::Dictionary > *std_vector_Sl_CNTK_Dictionary_Sg__GetRange(std::vector< CNTK::Dictionary > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< CNTK::Dictionary >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_Dictionary_Sg__Insert(std::vector< CNTK::Dictionary > *self,int index,CNTK::Dictionary const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Dictionary_Sg__InsertRange(std::vector< CNTK::Dictionary > *self,int index,std::vector< CNTK::Dictionary > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Dictionary_Sg__RemoveAt(std::vector< CNTK::Dictionary > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Dictionary_Sg__RemoveRange(std::vector< CNTK::Dictionary > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< CNTK::Dictionary > *std_vector_Sl_CNTK_Dictionary_Sg__Repeat(CNTK::Dictionary const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< CNTK::Dictionary >(count, value);
      }
SWIGINTERN void std_vector_Sl_CNTK_Dictionary_Sg__Reverse__SWIG_0(std::vector< CNTK::Dictionary > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_CNTK_Dictionary_Sg__Reverse__SWIG_1(std::vector< CNTK::Dictionary > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_Dictionary_Sg__SetRange(std::vector< CNTK::Dictionary > *self,int index,std::vector< CNTK::Dictionary > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_CNTK_Dictionary_Sg__Contains(std::vector< CNTK::Dictionary > *self,CNTK::Dictionary const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_CNTK_Dictionary_Sg__IndexOf(std::vector< CNTK::Dictionary > *self,CNTK::Dictionary const &value){
        int index = -1;
        std::vector< CNTK::Dictionary >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_CNTK_Dictionary_Sg__LastIndexOf(std::vector< CNTK::Dictionary > *self,CNTK::Dictionary const &value){
        int index = -1;
        std::vector< CNTK::Dictionary >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_CNTK_Dictionary_Sg__Remove(std::vector< CNTK::Dictionary > *self,CNTK::Dictionary const &value){
        std::vector< CNTK::Dictionary >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::mapped_type const &std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__getitem(std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *self,std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type const &key){
            std::unordered_map< CNTK::StreamInformation, CNTK::MinibatchData>::iterator iter = self->find(key);
            if (iter != self->end())
                return iter->second;
            else
                throw std::out_of_range("key not found");
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__setitem(std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *self,std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type const &key,std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::mapped_type const &x){
            (*self)[key] = x;
            }
SWIGINTERN bool std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__ContainsKey(std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *self,std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type const &key){
            std::unordered_map< CNTK::StreamInformation, CNTK::MinibatchData>::iterator iter = self->find(key);
            return iter != self->end();
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__Add(std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *self,std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type const &key,std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::mapped_type const &val){
            std::unordered_map< CNTK::StreamInformation, CNTK::MinibatchData>::iterator iter = self->find(key);
            if (iter != self->end())
                throw std::out_of_range("key already exists");
            self->insert(std::pair< CNTK::StreamInformation, CNTK::MinibatchData >(key, val));
            }
SWIGINTERN bool std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__Remove(std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *self,std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type const &key){
            std::unordered_map< CNTK::StreamInformation, CNTK::MinibatchData>::iterator iter = self->find(key);
            if (iter != self->end()) {
                self->erase(iter);
                return true;
            }                
            return false;
            }
SWIGINTERN std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::iterator *std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__create_iterator_begin(std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *self){
            return new std::unordered_map< CNTK::StreamInformation, CNTK::MinibatchData>::iterator(self->begin());
            }
SWIGINTERN std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type const &std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__get_next_key(std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *self,std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::iterator *swigiterator){
            std::unordered_map< CNTK::StreamInformation, CNTK::MinibatchData>::iterator iter = *swigiterator;
            (*swigiterator)++;
            return (*iter).first;
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__destroy_iterator(std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *self,std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::iterator *swigiterator){
            delete swigiterator;
            }
SWIGINTERN std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::mapped_type const &std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__getitem(std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *self,std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type const &key){
            std::unordered_map< CNTK::Variable, CNTK::MinibatchData>::iterator iter = self->find(key);
            if (iter != self->end())
                return iter->second;
            else
                throw std::out_of_range("key not found");
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__setitem(std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *self,std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type const &key,std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::mapped_type const &x){
            (*self)[key] = x;
            }
SWIGINTERN bool std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__ContainsKey(std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *self,std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type const &key){
            std::unordered_map< CNTK::Variable, CNTK::MinibatchData>::iterator iter = self->find(key);
            return iter != self->end();
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__Add(std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *self,std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type const &key,std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::mapped_type const &val){
            std::unordered_map< CNTK::Variable, CNTK::MinibatchData>::iterator iter = self->find(key);
            if (iter != self->end())
                throw std::out_of_range("key already exists");
            self->insert(std::pair< CNTK::Variable, CNTK::MinibatchData >(key, val));
            }
SWIGINTERN bool std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__Remove(std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *self,std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type const &key){
            std::unordered_map< CNTK::Variable, CNTK::MinibatchData>::iterator iter = self->find(key);
            if (iter != self->end()) {
                self->erase(iter);
                return true;
            }                
            return false;
            }
SWIGINTERN std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::iterator *std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__create_iterator_begin(std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *self){
            return new std::unordered_map< CNTK::Variable, CNTK::MinibatchData>::iterator(self->begin());
            }
SWIGINTERN std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type const &std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__get_next_key(std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *self,std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::iterator *swigiterator){
            std::unordered_map< CNTK::Variable, CNTK::MinibatchData>::iterator iter = *swigiterator;
            (*swigiterator)++;
            return (*iter).first;
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__destroy_iterator(std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *self,std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::iterator *swigiterator){
            delete swigiterator;
            }
SWIGINTERN std::vector< CNTK::StreamConfiguration > *new_std_vector_Sl_CNTK_StreamConfiguration_Sg___SWIG_2(int capacity){
        std::vector< CNTK::StreamConfiguration >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< CNTK::StreamConfiguration >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN CNTK::StreamConfiguration std_vector_Sl_CNTK_StreamConfiguration_Sg__getitemcopy(std::vector< CNTK::StreamConfiguration > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN CNTK::StreamConfiguration const &std_vector_Sl_CNTK_StreamConfiguration_Sg__getitem(std::vector< CNTK::StreamConfiguration > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_StreamConfiguration_Sg__setitem(std::vector< CNTK::StreamConfiguration > *self,int index,CNTK::StreamConfiguration const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_StreamConfiguration_Sg__AddRange(std::vector< CNTK::StreamConfiguration > *self,std::vector< CNTK::StreamConfiguration > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< CNTK::StreamConfiguration > *std_vector_Sl_CNTK_StreamConfiguration_Sg__GetRange(std::vector< CNTK::StreamConfiguration > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< CNTK::StreamConfiguration >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_StreamConfiguration_Sg__Insert(std::vector< CNTK::StreamConfiguration > *self,int index,CNTK::StreamConfiguration const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_StreamConfiguration_Sg__InsertRange(std::vector< CNTK::StreamConfiguration > *self,int index,std::vector< CNTK::StreamConfiguration > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_StreamConfiguration_Sg__RemoveAt(std::vector< CNTK::StreamConfiguration > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_StreamConfiguration_Sg__RemoveRange(std::vector< CNTK::StreamConfiguration > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< CNTK::StreamConfiguration > *std_vector_Sl_CNTK_StreamConfiguration_Sg__Repeat(CNTK::StreamConfiguration const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< CNTK::StreamConfiguration >(count, value);
      }
SWIGINTERN void std_vector_Sl_CNTK_StreamConfiguration_Sg__Reverse__SWIG_0(std::vector< CNTK::StreamConfiguration > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_CNTK_StreamConfiguration_Sg__Reverse__SWIG_1(std::vector< CNTK::StreamConfiguration > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_StreamConfiguration_Sg__SetRange(std::vector< CNTK::StreamConfiguration > *self,int index,std::vector< CNTK::StreamConfiguration > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< CNTK::Parameter > *new_std_vector_Sl_CNTK_Parameter_Sg___SWIG_2(int capacity){
        std::vector< CNTK::Parameter >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< CNTK::Parameter >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN CNTK::Parameter std_vector_Sl_CNTK_Parameter_Sg__getitemcopy(std::vector< CNTK::Parameter > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN CNTK::Parameter const &std_vector_Sl_CNTK_Parameter_Sg__getitem(std::vector< CNTK::Parameter > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Parameter_Sg__setitem(std::vector< CNTK::Parameter > *self,int index,CNTK::Parameter const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Parameter_Sg__AddRange(std::vector< CNTK::Parameter > *self,std::vector< CNTK::Parameter > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< CNTK::Parameter > *std_vector_Sl_CNTK_Parameter_Sg__GetRange(std::vector< CNTK::Parameter > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< CNTK::Parameter >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_Parameter_Sg__Insert(std::vector< CNTK::Parameter > *self,int index,CNTK::Parameter const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Parameter_Sg__InsertRange(std::vector< CNTK::Parameter > *self,int index,std::vector< CNTK::Parameter > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Parameter_Sg__RemoveAt(std::vector< CNTK::Parameter > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Parameter_Sg__RemoveRange(std::vector< CNTK::Parameter > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< CNTK::Parameter > *std_vector_Sl_CNTK_Parameter_Sg__Repeat(CNTK::Parameter const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< CNTK::Parameter >(count, value);
      }
SWIGINTERN void std_vector_Sl_CNTK_Parameter_Sg__Reverse__SWIG_0(std::vector< CNTK::Parameter > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_CNTK_Parameter_Sg__Reverse__SWIG_1(std::vector< CNTK::Parameter > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_Parameter_Sg__SetRange(std::vector< CNTK::Parameter > *self,int index,std::vector< CNTK::Parameter > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_CNTK_Parameter_Sg__Contains(std::vector< CNTK::Parameter > *self,CNTK::Parameter const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_CNTK_Parameter_Sg__IndexOf(std::vector< CNTK::Parameter > *self,CNTK::Parameter const &value){
        int index = -1;
        std::vector< CNTK::Parameter >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_CNTK_Parameter_Sg__LastIndexOf(std::vector< CNTK::Parameter > *self,CNTK::Parameter const &value){
        int index = -1;
        std::vector< CNTK::Parameter >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_CNTK_Parameter_Sg__Remove(std::vector< CNTK::Parameter > *self,CNTK::Parameter const &value){
        std::vector< CNTK::Parameter >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< CNTK::Constant > *new_std_vector_Sl_CNTK_Constant_Sg___SWIG_2(int capacity){
        std::vector< CNTK::Constant >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< CNTK::Constant >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN CNTK::Constant std_vector_Sl_CNTK_Constant_Sg__getitemcopy(std::vector< CNTK::Constant > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN CNTK::Constant const &std_vector_Sl_CNTK_Constant_Sg__getitem(std::vector< CNTK::Constant > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Constant_Sg__setitem(std::vector< CNTK::Constant > *self,int index,CNTK::Constant const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Constant_Sg__AddRange(std::vector< CNTK::Constant > *self,std::vector< CNTK::Constant > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< CNTK::Constant > *std_vector_Sl_CNTK_Constant_Sg__GetRange(std::vector< CNTK::Constant > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< CNTK::Constant >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_Constant_Sg__Insert(std::vector< CNTK::Constant > *self,int index,CNTK::Constant const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Constant_Sg__InsertRange(std::vector< CNTK::Constant > *self,int index,std::vector< CNTK::Constant > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Constant_Sg__RemoveAt(std::vector< CNTK::Constant > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_Constant_Sg__RemoveRange(std::vector< CNTK::Constant > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< CNTK::Constant > *std_vector_Sl_CNTK_Constant_Sg__Repeat(CNTK::Constant const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< CNTK::Constant >(count, value);
      }
SWIGINTERN void std_vector_Sl_CNTK_Constant_Sg__Reverse__SWIG_0(std::vector< CNTK::Constant > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_CNTK_Constant_Sg__Reverse__SWIG_1(std::vector< CNTK::Constant > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_Constant_Sg__SetRange(std::vector< CNTK::Constant > *self,int index,std::vector< CNTK::Constant > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< std::wstring > *new_std_vector_Sl_std_wstring_Sg___SWIG_2(int capacity){
        std::vector< std::wstring >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::wstring >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::wstring std_vector_Sl_std_wstring_Sg__getitemcopy(std::vector< std::wstring > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::wstring const &std_vector_Sl_std_wstring_Sg__getitem(std::vector< std::wstring > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__setitem(std::vector< std::wstring > *self,int index,std::wstring const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__AddRange(std::vector< std::wstring > *self,std::vector< std::wstring > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::wstring > *std_vector_Sl_std_wstring_Sg__GetRange(std::vector< std::wstring > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::wstring >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__Insert(std::vector< std::wstring > *self,int index,std::wstring const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__InsertRange(std::vector< std::wstring > *self,int index,std::vector< std::wstring > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__RemoveAt(std::vector< std::wstring > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__RemoveRange(std::vector< std::wstring > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::wstring > *std_vector_Sl_std_wstring_Sg__Repeat(std::wstring const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::wstring >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__Reverse__SWIG_0(std::vector< std::wstring > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__Reverse__SWIG_1(std::vector< std::wstring > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__SetRange(std::vector< std::wstring > *self,int index,std::vector< std::wstring > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< CNTK::HTKFeatureConfiguration > *new_std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg___SWIG_2(int capacity){
        std::vector< CNTK::HTKFeatureConfiguration >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< CNTK::HTKFeatureConfiguration >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN CNTK::HTKFeatureConfiguration std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__getitemcopy(std::vector< CNTK::HTKFeatureConfiguration > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN CNTK::HTKFeatureConfiguration const &std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__getitem(std::vector< CNTK::HTKFeatureConfiguration > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__setitem(std::vector< CNTK::HTKFeatureConfiguration > *self,int index,CNTK::HTKFeatureConfiguration const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__AddRange(std::vector< CNTK::HTKFeatureConfiguration > *self,std::vector< CNTK::HTKFeatureConfiguration > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< CNTK::HTKFeatureConfiguration > *std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__GetRange(std::vector< CNTK::HTKFeatureConfiguration > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< CNTK::HTKFeatureConfiguration >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__Insert(std::vector< CNTK::HTKFeatureConfiguration > *self,int index,CNTK::HTKFeatureConfiguration const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__InsertRange(std::vector< CNTK::HTKFeatureConfiguration > *self,int index,std::vector< CNTK::HTKFeatureConfiguration > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__RemoveAt(std::vector< CNTK::HTKFeatureConfiguration > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__RemoveRange(std::vector< CNTK::HTKFeatureConfiguration > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< CNTK::HTKFeatureConfiguration > *std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__Repeat(CNTK::HTKFeatureConfiguration const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< CNTK::HTKFeatureConfiguration >(count, value);
      }
SWIGINTERN void std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__Reverse__SWIG_0(std::vector< CNTK::HTKFeatureConfiguration > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__Reverse__SWIG_1(std::vector< CNTK::HTKFeatureConfiguration > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__SetRange(std::vector< CNTK::HTKFeatureConfiguration > *self,int index,std::vector< CNTK::HTKFeatureConfiguration > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::mapped_type const &std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__getitem(std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *self,std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type const &key){
            std::unordered_map< CNTK::Parameter, std::shared_ptr< CNTK::NDArrayView >>::iterator iter = self->find(key);
            if (iter != self->end())
                return iter->second;
            else
                throw std::out_of_range("key not found");
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__setitem(std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *self,std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type const &key,std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::mapped_type const &x){
            (*self)[key] = x;
            }
SWIGINTERN bool std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__ContainsKey(std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *self,std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type const &key){
            std::unordered_map< CNTK::Parameter, std::shared_ptr< CNTK::NDArrayView >>::iterator iter = self->find(key);
            return iter != self->end();
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Add(std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *self,std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type const &key,std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::mapped_type const &val){
            std::unordered_map< CNTK::Parameter, std::shared_ptr< CNTK::NDArrayView >>::iterator iter = self->find(key);
            if (iter != self->end())
                throw std::out_of_range("key already exists");
            self->insert(std::pair< CNTK::Parameter, std::shared_ptr< CNTK::NDArrayView > >(key, val));
            }
SWIGINTERN bool std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Remove(std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *self,std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type const &key){
            std::unordered_map< CNTK::Parameter, std::shared_ptr< CNTK::NDArrayView >>::iterator iter = self->find(key);
            if (iter != self->end()) {
                self->erase(iter);
                return true;
            }                
            return false;
            }
SWIGINTERN std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::iterator *std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__create_iterator_begin(std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *self){
            return new std::unordered_map< CNTK::Parameter, std::shared_ptr< CNTK::NDArrayView >>::iterator(self->begin());
            }
SWIGINTERN std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type const &std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__get_next_key(std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *self,std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::iterator *swigiterator){
            std::unordered_map< CNTK::Parameter, std::shared_ptr< CNTK::NDArrayView >>::iterator iter = *swigiterator;
            (*swigiterator)++;
            return (*iter).first;
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__destroy_iterator(std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *self,std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::iterator *swigiterator){
            delete swigiterator;
            }
SWIGINTERN std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::mapped_type const &std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__getitem(std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *self,std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type const &key){
            std::unordered_map< CNTK::StreamInformation, std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > >>::iterator iter = self->find(key);
            if (iter != self->end())
                return iter->second;
            else
                throw std::out_of_range("key not found");
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__setitem(std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *self,std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type const &key,std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::mapped_type const &x){
            (*self)[key] = x;
            }
SWIGINTERN bool std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__ContainsKey(std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *self,std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type const &key){
            std::unordered_map< CNTK::StreamInformation, std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > >>::iterator iter = self->find(key);
            return iter != self->end();
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__Add(std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *self,std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type const &key,std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::mapped_type const &val){
            std::unordered_map< CNTK::StreamInformation, std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > >>::iterator iter = self->find(key);
            if (iter != self->end())
                throw std::out_of_range("key already exists");
            self->insert(std::pair< CNTK::StreamInformation, std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >(key, val));
            }
SWIGINTERN bool std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__Remove(std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *self,std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type const &key){
            std::unordered_map< CNTK::StreamInformation, std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > >>::iterator iter = self->find(key);
            if (iter != self->end()) {
                self->erase(iter);
                return true;
            }                
            return false;
            }
SWIGINTERN std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::iterator *std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__create_iterator_begin(std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *self){
            return new std::unordered_map< CNTK::StreamInformation, std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > >>::iterator(self->begin());
            }
SWIGINTERN std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type const &std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__get_next_key(std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *self,std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::iterator *swigiterator){
            std::unordered_map< CNTK::StreamInformation, std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > >>::iterator iter = *swigiterator;
            (*swigiterator)++;
            return (*iter).first;
            }
SWIGINTERN void std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__destroy_iterator(std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *self,std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::iterator *swigiterator){
            delete swigiterator;
            }
SWIGINTERN std::vector< std::shared_ptr< CNTK::ProgressWriter > > *new_std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::shared_ptr< CNTK::ProgressWriter > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::shared_ptr< CNTK::ProgressWriter > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::shared_ptr< CNTK::ProgressWriter > std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__getitemcopy(std::vector< std::shared_ptr< CNTK::ProgressWriter > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::shared_ptr< CNTK::ProgressWriter > const &std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__getitem(std::vector< std::shared_ptr< CNTK::ProgressWriter > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__setitem(std::vector< std::shared_ptr< CNTK::ProgressWriter > > *self,int index,std::shared_ptr< CNTK::ProgressWriter > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__AddRange(std::vector< std::shared_ptr< CNTK::ProgressWriter > > *self,std::vector< std::shared_ptr< CNTK::ProgressWriter > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::shared_ptr< CNTK::ProgressWriter > > *std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__GetRange(std::vector< std::shared_ptr< CNTK::ProgressWriter > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::shared_ptr< CNTK::ProgressWriter > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__Insert(std::vector< std::shared_ptr< CNTK::ProgressWriter > > *self,int index,std::shared_ptr< CNTK::ProgressWriter > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__InsertRange(std::vector< std::shared_ptr< CNTK::ProgressWriter > > *self,int index,std::vector< std::shared_ptr< CNTK::ProgressWriter > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__RemoveAt(std::vector< std::shared_ptr< CNTK::ProgressWriter > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__RemoveRange(std::vector< std::shared_ptr< CNTK::ProgressWriter > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::shared_ptr< CNTK::ProgressWriter > > *std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__Repeat(std::shared_ptr< CNTK::ProgressWriter > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::shared_ptr< CNTK::ProgressWriter > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__Reverse__SWIG_0(std::vector< std::shared_ptr< CNTK::ProgressWriter > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__Reverse__SWIG_1(std::vector< std::shared_ptr< CNTK::ProgressWriter > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__SetRange(std::vector< std::shared_ptr< CNTK::ProgressWriter > > *self,int index,std::vector< std::shared_ptr< CNTK::ProgressWriter > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< std::shared_ptr< CNTK::Learner > > *new_std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::shared_ptr< CNTK::Learner > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::shared_ptr< CNTK::Learner > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::shared_ptr< CNTK::Learner > std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__getitemcopy(std::vector< std::shared_ptr< CNTK::Learner > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::shared_ptr< CNTK::Learner > const &std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__getitem(std::vector< std::shared_ptr< CNTK::Learner > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__setitem(std::vector< std::shared_ptr< CNTK::Learner > > *self,int index,std::shared_ptr< CNTK::Learner > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__AddRange(std::vector< std::shared_ptr< CNTK::Learner > > *self,std::vector< std::shared_ptr< CNTK::Learner > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::shared_ptr< CNTK::Learner > > *std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__GetRange(std::vector< std::shared_ptr< CNTK::Learner > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::shared_ptr< CNTK::Learner > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__Insert(std::vector< std::shared_ptr< CNTK::Learner > > *self,int index,std::shared_ptr< CNTK::Learner > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__InsertRange(std::vector< std::shared_ptr< CNTK::Learner > > *self,int index,std::vector< std::shared_ptr< CNTK::Learner > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__RemoveAt(std::vector< std::shared_ptr< CNTK::Learner > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__RemoveRange(std::vector< std::shared_ptr< CNTK::Learner > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::shared_ptr< CNTK::Learner > > *std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__Repeat(std::shared_ptr< CNTK::Learner > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::shared_ptr< CNTK::Learner > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__Reverse__SWIG_0(std::vector< std::shared_ptr< CNTK::Learner > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__Reverse__SWIG_1(std::vector< std::shared_ptr< CNTK::Learner > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__SetRange(std::vector< std::shared_ptr< CNTK::Learner > > *self,int index,std::vector< std::shared_ptr< CNTK::Learner > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *new_std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::pair< CNTK::Variable,CNTK::Variable > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::pair< CNTK::Variable,CNTK::Variable > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::pair< CNTK::Variable,CNTK::Variable > std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__getitemcopy(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::pair< CNTK::Variable,CNTK::Variable > const &std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__getitem(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__setitem(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *self,int index,std::pair< CNTK::Variable,CNTK::Variable > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__AddRange(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *self,std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__GetRange(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::pair< CNTK::Variable,CNTK::Variable > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__Insert(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *self,int index,std::pair< CNTK::Variable,CNTK::Variable > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__InsertRange(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *self,int index,std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__RemoveAt(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__RemoveRange(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__Repeat(std::pair< CNTK::Variable,CNTK::Variable > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::pair< CNTK::Variable,CNTK::Variable > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__Reverse__SWIG_0(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__Reverse__SWIG_1(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__SetRange(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *self,int index,std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::unordered_map< std::wstring,CNTK::DictionaryValue >::mapped_type const &std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__getitem(std::unordered_map< std::wstring,CNTK::DictionaryValue > *self,std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type const &key){
            std::unordered_map< std::wstring, CNTK::DictionaryValue>::iterator iter = self->find(key);
            if (iter != self->end())
                return iter->second;
            else
                throw std::out_of_range("key not found");
            }
SWIGINTERN void std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__setitem(std::unordered_map< std::wstring,CNTK::DictionaryValue > *self,std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type const &key,std::unordered_map< std::wstring,CNTK::DictionaryValue >::mapped_type const &x){
            (*self)[key] = x;
            }
SWIGINTERN bool std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__ContainsKey(std::unordered_map< std::wstring,CNTK::DictionaryValue > *self,std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type const &key){
            std::unordered_map< std::wstring, CNTK::DictionaryValue>::iterator iter = self->find(key);
            return iter != self->end();
            }
SWIGINTERN void std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__Add(std::unordered_map< std::wstring,CNTK::DictionaryValue > *self,std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type const &key,std::unordered_map< std::wstring,CNTK::DictionaryValue >::mapped_type const &val){
            std::unordered_map< std::wstring, CNTK::DictionaryValue>::iterator iter = self->find(key);
            if (iter != self->end())
                throw std::out_of_range("key already exists");
            self->insert(std::pair< std::wstring, CNTK::DictionaryValue >(key, val));
            }
SWIGINTERN bool std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__Remove(std::unordered_map< std::wstring,CNTK::DictionaryValue > *self,std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type const &key){
            std::unordered_map< std::wstring, CNTK::DictionaryValue>::iterator iter = self->find(key);
            if (iter != self->end()) {
                self->erase(iter);
                return true;
            }                
            return false;
            }
SWIGINTERN std::unordered_map< std::wstring,CNTK::DictionaryValue >::iterator *std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__create_iterator_begin(std::unordered_map< std::wstring,CNTK::DictionaryValue > *self){
            return new std::unordered_map< std::wstring, CNTK::DictionaryValue>::iterator(self->begin());
            }
SWIGINTERN std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type const &std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__get_next_key(std::unordered_map< std::wstring,CNTK::DictionaryValue > *self,std::unordered_map< std::wstring,CNTK::DictionaryValue >::iterator *swigiterator){
            std::unordered_map< std::wstring, CNTK::DictionaryValue>::iterator iter = *swigiterator;
            (*swigiterator)++;
            return (*iter).first;
            }
SWIGINTERN void std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__destroy_iterator(std::unordered_map< std::wstring,CNTK::DictionaryValue > *self,std::unordered_map< std::wstring,CNTK::DictionaryValue >::iterator *swigiterator){
            delete swigiterator;
            }
SWIGINTERN std::vector< std::pair< size_t,double > > *new_std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::pair< size_t,double > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::pair< size_t,double > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::pair< size_t,double > std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__getitemcopy(std::vector< std::pair< size_t,double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::pair< size_t,double > const &std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__getitem(std::vector< std::pair< size_t,double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__setitem(std::vector< std::pair< size_t,double > > *self,int index,std::pair< size_t,double > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__AddRange(std::vector< std::pair< size_t,double > > *self,std::vector< std::pair< size_t,double > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::pair< size_t,double > > *std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__GetRange(std::vector< std::pair< size_t,double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::pair< size_t,double > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__Insert(std::vector< std::pair< size_t,double > > *self,int index,std::pair< size_t,double > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__InsertRange(std::vector< std::pair< size_t,double > > *self,int index,std::vector< std::pair< size_t,double > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__RemoveAt(std::vector< std::pair< size_t,double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__RemoveRange(std::vector< std::pair< size_t,double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::pair< size_t,double > > *std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__Repeat(std::pair< size_t,double > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::pair< size_t,double > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__Reverse__SWIG_0(std::vector< std::pair< size_t,double > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__Reverse__SWIG_1(std::vector< std::pair< size_t,double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__SetRange(std::vector< std::pair< size_t,double > > *self,int index,std::vector< std::pair< size_t,double > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }

    #include "ExceptionWithCallStack.h"

SWIGINTERN size_t CNTK_NDShape_DimensionSize(CNTK::NDShape *self,size_t axisId){
        return (*self)[axisId];
    }
SWIGINTERN void CNTK_NDShape_CSharp_SizeTVector_AddExt(std::vector< size_t > *vectorSizeT,unsigned long long dim){
        (*vectorSizeT).push_back(dim);
    }
SWIGINTERN CNTK::NDArrayView *new_CNTK_NDArrayView__SWIG_14(CNTK::NDShape const &viewShape,float *dataBuffer,size_t numBufferElements,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        if (device.Type() == CNTK::DeviceKind::GPU)
        {
            CNTK::NDArrayView cpuView(viewShape, dataBuffer, numBufferElements, CNTK::DeviceDescriptor::CPUDevice(), readOnly);
            auto gpuView = new CNTK::NDArrayView(cpuView.GetDataType(), cpuView.GetStorageFormat(), viewShape, device);
            gpuView->CopyFrom(cpuView);
            return gpuView;
        }
        else
            return new CNTK::NDArrayView(viewShape, dataBuffer, numBufferElements, device, readOnly);
    }
SWIGINTERN CNTK::NDArrayView *new_CNTK_NDArrayView__SWIG_16(CNTK::NDShape const &viewShape,double *dataBuffer,size_t numBufferElements,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        if (device.Type() == CNTK::DeviceKind::GPU)
        {
            CNTK::NDArrayView cpuView(viewShape, dataBuffer, numBufferElements, CNTK::DeviceDescriptor::CPUDevice(), readOnly);
            auto gpuView = new CNTK::NDArrayView(cpuView.GetDataType(), cpuView.GetStorageFormat(), viewShape, device);
            gpuView->CopyFrom(cpuView);
            return gpuView;
        }
        else
            return new CNTK::NDArrayView(viewShape, dataBuffer, numBufferElements, device, readOnly);
    }
SWIGINTERN CNTK::NDArrayView *new_CNTK_NDArrayView__SWIG_18(CNTK::NDShape const &viewShape,CNTK::SparseIndexType const *colStarts,CNTK::SparseIndexType const *rowIndices,float const *nonZeroValues,size_t numNonZeroValues,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return new CNTK::NDArrayView(CNTK::DataType::Float, viewShape, colStarts, rowIndices, nonZeroValues, numNonZeroValues, device, readOnly);
    }
SWIGINTERN CNTK::NDArrayView *new_CNTK_NDArrayView__SWIG_20(CNTK::NDShape const &viewShape,CNTK::SparseIndexType const *colStarts,CNTK::SparseIndexType const *rowIndices,double const *nonZeroValues,size_t numNonZeroValues,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return new CNTK::NDArrayView(CNTK::DataType::Double, viewShape, colStarts, rowIndices, nonZeroValues, numNonZeroValues, device, readOnly);
    }
SWIGINTERN CNTK::NDArrayView *new_CNTK_NDArrayView__SWIG_22(CNTK::NDShape const &viewShape,CNTK::SparseIndexType const *colStarts,CNTK::SparseIndexType const *rowIndices,int8_t const *nonZeroValues,size_t numNonZeroValues,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return new CNTK::NDArrayView(CNTK::DataType::Int8, viewShape, colStarts, rowIndices, nonZeroValues, numNonZeroValues, device, readOnly);
    }
SWIGINTERN CNTK::NDArrayView *new_CNTK_NDArrayView__SWIG_24(CNTK::NDShape const &viewShape,CNTK::SparseIndexType const *colStarts,CNTK::SparseIndexType const *rowIndices,int16_t const *nonZeroValues,size_t numNonZeroValues,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return new CNTK::NDArrayView(CNTK::DataType::Int16, viewShape, colStarts, rowIndices, nonZeroValues, numNonZeroValues, device, readOnly);
    }
SWIGINTERN CNTK::NDArrayViewPtr CNTK_NDArrayView_RandomNormalFloat(CNTK::NDShape const &shape,double mean,double stdDev,unsigned long seed,CNTK::DeviceDescriptor const &device){
        return CNTK::NDArrayView::RandomNormal<float>(shape, mean, stdDev, seed, device);
    }
SWIGINTERN CNTK::NDArrayViewPtr CNTK_NDArrayView_RandomNormalDouble(CNTK::NDShape const &shape,double mean,double stdDev,unsigned long seed,CNTK::DeviceDescriptor const &device){
        return CNTK::NDArrayView::RandomNormal<double>(shape, mean, stdDev, seed, device);
    }
SWIGINTERN CNTK::NDArrayViewPtr CNTK_NDArrayView_RandomUniformFloat(CNTK::NDShape const &shape,double rangeStart,double rangeEnd,unsigned long seed,CNTK::DeviceDescriptor const &device){
        return CNTK::NDArrayView::RandomUniform<float>(shape, rangeStart, rangeEnd, seed, device);
    }
SWIGINTERN CNTK::NDArrayViewPtr CNTK_NDArrayView_RandomUniformDouble(CNTK::NDShape const &shape,double rangeStart,double rangeEnd,unsigned long seed,CNTK::DeviceDescriptor const &device){
        return CNTK::NDArrayView::RandomUniform<double>(shape, rangeStart, rangeEnd, seed, device);
    }
SWIGINTERN CNTK::Constant CNTK_Constant_ScalarFloat__SWIG_0(float value,CNTK::DeviceDescriptor const &device=CNTK::DeviceDescriptor::CPUDevice()){
        return CNTK::Constant::Scalar<float>(value, device);
    }
SWIGINTERN CNTK::Constant CNTK_Constant_ScalarDouble__SWIG_0(double value,CNTK::DeviceDescriptor const &device=CNTK::DeviceDescriptor::CPUDevice()){
        return CNTK::Constant::Scalar<double>(value, device);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateDenseFloat__SWIG_0(CNTK::NDShape const &sampleShape,std::vector< std::vector< float > > const &sequences,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::Create<float>(sampleShape, sequences, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateDenseDouble__SWIG_0(CNTK::NDShape const &sampleShape,std::vector< std::vector< double > > const &sequences,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::Create<double>(sampleShape, sequences, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateDenseFloat__SWIG_2(CNTK::NDShape const &sampleShape,std::vector< std::vector< float > > const &sequences,std::vector< bool > const &sequenceStartFlags,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::Create<float>(sampleShape, sequences, sequenceStartFlags, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateDenseDouble__SWIG_2(CNTK::NDShape const &sampleShape,std::vector< std::vector< double > > const &sequences,std::vector< bool > const &sequenceStartFlags,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::Create<double>(sampleShape, sequences, sequenceStartFlags, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateBatchFloat__SWIG_0(CNTK::NDShape const &sampleShape,float const *dataBuffer,int dataStart,int dataSize,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        std::vector<float> batchData(dataBuffer + dataStart, dataBuffer + dataStart + dataSize);
        return CNTK::Value::CreateBatch<float>(sampleShape, batchData, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateBatchDouble__SWIG_0(CNTK::NDShape const &sampleShape,double const *dataBuffer,int dataStart,int dataSize,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        std::vector<double> batchData(dataBuffer + dataStart, dataBuffer + dataStart + dataSize);
        return CNTK::Value::CreateBatch<double>(sampleShape, batchData, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateSequenceFloat__SWIG_0(CNTK::NDShape const &sampleShape,float const *dataBuffer,int dataSize,bool sequenceStartFlag,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        std::vector<float> sequenceData(dataBuffer, dataBuffer + dataSize);
        return CNTK::Value::CreateSequence<float>(sampleShape, sequenceData, sequenceStartFlag, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateSequenceDouble__SWIG_0(CNTK::NDShape const &sampleShape,double const *dataBuffer,int dataSize,bool sequenceStartFlag,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        std::vector<double> sequenceData(dataBuffer, dataBuffer + dataSize);
        return CNTK::Value::CreateSequence<double>(sampleShape, sequenceData, sequenceStartFlag, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateOneHotFloat__SWIG_0(CNTK::NDShape const &sampleShape,std::vector< std::vector< size_t > > const &oneHotSequences,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::Create<float>(sampleShape, oneHotSequences, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateOneHotDouble__SWIG_0(CNTK::NDShape const &sampleShape,std::vector< std::vector< size_t > > const &oneHotSequences,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::Create<double>(sampleShape, oneHotSequences, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateOneHotFloat__SWIG_2(CNTK::NDShape const &sampleShape,std::vector< std::vector< size_t > > const &oneHotSequences,std::vector< bool > const &sequenceStartFlags,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::Create<float>(sampleShape, oneHotSequences, sequenceStartFlags, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateOneHotDouble__SWIG_2(CNTK::NDShape const &sampleShape,std::vector< std::vector< size_t > > const &oneHotSequences,std::vector< bool > const &sequenceStartFlags,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::Create<double>(sampleShape, oneHotSequences, sequenceStartFlags, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateOneHotFloat__SWIG_4(size_t dimension,std::vector< std::vector< size_t > > const &oneHotSequences,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::Create<float>(CNTK::NDShape({dimension}), oneHotSequences, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateOneHotDouble__SWIG_4(size_t dimension,std::vector< std::vector< size_t > > const &oneHotSequences,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::Create<double>(CNTK::NDShape({dimension}), oneHotSequences, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateOneHotFloat__SWIG_6(size_t dimension,std::vector< std::vector< size_t > > const &oneHotSequences,std::vector< bool > const &sequenceStartFlags,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::Create<float>(CNTK::NDShape({dimension}), oneHotSequences, sequenceStartFlags, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateOneHotDouble__SWIG_6(size_t dimension,std::vector< std::vector< size_t > > const &oneHotSequences,std::vector< bool > const &sequenceStartFlags,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::Create<double>(CNTK::NDShape({dimension}), oneHotSequences, sequenceStartFlags, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateBatchFloat__SWIG_2(size_t dimension,std::vector< size_t > const &batchData,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::CreateBatch<float>(dimension, batchData, device, false);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateBatchDouble__SWIG_2(size_t dimension,std::vector< size_t > const &batchData,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::CreateBatch<double>(dimension, batchData, device, false);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateSequenceFloat__SWIG_2(size_t dimension,std::vector< size_t > const &sequenceData,bool sequenceStartFlag,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::CreateSequence<float>(dimension, sequenceData, sequenceStartFlag, device, false);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateSequenceDouble__SWIG_2(size_t dimension,std::vector< size_t > const &sequenceData,bool sequenceStartFlag,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::CreateSequence<double>(dimension, sequenceData, sequenceStartFlag, device, false);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateSequenceFloat__SWIG_4(CNTK::NDShape const &sampleShape,size_t sequenceLength,CNTK::SparseIndexType const *colStarts,CNTK::SparseIndexType const *rowIndices,float const *nonZeroValues,size_t numNonZeroValues,bool sequenceStartFlag,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::CreateSequence<float>(sampleShape, sequenceLength, colStarts, rowIndices, nonZeroValues, numNonZeroValues, sequenceStartFlag, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateSequenceDouble__SWIG_4(CNTK::NDShape const &sampleShape,size_t sequenceLength,CNTK::SparseIndexType const *colStarts,CNTK::SparseIndexType const *rowIndices,double const *nonZeroValues,size_t numNonZeroValues,bool sequenceStartFlag,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::CreateSequence<double>(sampleShape, sequenceLength, colStarts, rowIndices, nonZeroValues, numNonZeroValues, sequenceStartFlag, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateSequenceFloat__SWIG_6(size_t dimension,size_t sequenceLength,CNTK::SparseIndexType const *colStarts,CNTK::SparseIndexType const *rowIndices,float const *nonZeroValues,size_t numNonZeroValues,bool sequenceStartFlag,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::CreateSequence<float>(dimension, sequenceLength, colStarts, rowIndices, nonZeroValues, numNonZeroValues, sequenceStartFlag, device, readOnly);
    }
SWIGINTERN CNTK::ValuePtr CNTK_Value_CreateSequenceDouble__SWIG_6(size_t dimension,size_t sequenceLength,CNTK::SparseIndexType const *colStarts,CNTK::SparseIndexType const *rowIndices,double const *nonZeroValues,size_t numNonZeroValues,bool sequenceStartFlag,CNTK::DeviceDescriptor const &device,bool readOnly=false){
        return CNTK::Value::CreateSequence<double>(dimension, sequenceLength, colStarts, rowIndices, nonZeroValues, numNonZeroValues, sequenceStartFlag, device, readOnly);
    }
SWIGINTERN void CNTK_Value_CopyVariableValueToFloat__SWIG_0(CNTK::Value *self,CNTK::Variable const &outputVariable,std::vector< std::vector< float > > &sequences){
        return self->CopyVariableValueTo<float>(outputVariable, sequences);
    }
SWIGINTERN void CNTK_Value_CopyVariableValueToDouble__SWIG_0(CNTK::Value *self,CNTK::Variable const &outputVariable,std::vector< std::vector< double > > &sequences){
        return self->CopyVariableValueTo<double>(outputVariable, sequences);
    }
SWIGINTERN void CNTK_Value_CopyVariableValueToFloat__SWIG_1(CNTK::Value *self,CNTK::Variable const &outputVariable,int *sequenceLength,std::vector< CNTK::SparseIndexType > &colStarts,std::vector< CNTK::SparseIndexType > &rowIndices,std::vector< float > &nonZeroValues,int *numNonZeroValues){
        size_t sequenceLengthSizeT, numNonZeroValuesSizeT;
        self->CopyVariableValueTo<float>(outputVariable, sequenceLengthSizeT, colStarts, rowIndices, nonZeroValues, numNonZeroValuesSizeT);
        *sequenceLength = (int)sequenceLengthSizeT;
        *numNonZeroValues = (int)numNonZeroValuesSizeT;
    }
SWIGINTERN void CNTK_Value_CopyVariableValueToDouble__SWIG_1(CNTK::Value *self,CNTK::Variable const &outputVariable,int *sequenceLength,std::vector< CNTK::SparseIndexType > &colStarts,std::vector< CNTK::SparseIndexType > &rowIndices,std::vector< double > &nonZeroValues,int *numNonZeroValues){
        size_t sequenceLengthSizeT, numNonZeroValuesSizeT;
        self->CopyVariableValueTo<double>(outputVariable, sequenceLengthSizeT, colStarts, rowIndices, nonZeroValues, numNonZeroValuesSizeT);
        *sequenceLength = (int)sequenceLengthSizeT;
        *numNonZeroValues = (int)numNonZeroValuesSizeT;
    }
SWIGINTERN std::shared_ptr< CNTK::MinibatchSource > CNTK_MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_0(std::wstring const &dataFilePath,std::vector< CNTK::StreamConfiguration > const &streamConfigs,unsigned long long epochSize=CNTK::MinibatchSource::InfinitelyRepeat,bool randomize=true,unsigned long long randomizationWindow=CNTK::MinibatchSource::DefaultRandomizationWindowInChunks,bool sampleBasedRandomizationWindow=false){
        return CNTK::TextFormatMinibatchSource(dataFilePath, streamConfigs,
            epochSize, randomize, randomizationWindow, sampleBasedRandomizationWindow);
    }
SWIGINTERN unsigned long long CNTK_MinibatchSource_GetFullDataSweep(){
        return CNTK::MinibatchSource::FullDataSweep;
    }
SWIGINTERN unsigned long long CNTK_MinibatchSource_GetInfinitelyRepeat(){
        return CNTK::MinibatchSource::InfinitelyRepeat;
    }
SWIGINTERN unsigned long long CNTK_MinibatchSource_GetDefaultRandomizationWindowInChunks(){
        return CNTK::MinibatchSource::DefaultRandomizationWindowInChunks;
    }
SWIGINTERN unsigned long long CNTK_MinibatchSourceConfig_GetMaxSamples(CNTK::MinibatchSourceConfig *self){
        return self->maxSamples;
    }
SWIGINTERN void CNTK_MinibatchSourceConfig_SetMaxSamples(CNTK::MinibatchSourceConfig *self,unsigned long long i_maxSamples){
        self->maxSamples = i_maxSamples;
    }
SWIGINTERN unsigned long long CNTK_MinibatchSourceConfig_GetMaxSweeps(CNTK::MinibatchSourceConfig *self){
        return self->maxSweeps;
    }
SWIGINTERN void CNTK_MinibatchSourceConfig_SetMaxSweeps(CNTK::MinibatchSourceConfig *self,unsigned long long i_maxSweeps){
        self->maxSweeps = i_maxSweeps;
    }


/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "cntk_cs_wrap.h"


#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CharVector_Clear(void * jarg1) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CharVector_Add(void * jarg1, char jarg2) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  char *arg2 = 0 ;
  char temp2 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  temp2 = (char)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((char const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_CharVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  std::vector< char >::size_type result;
  
  arg1 = (std::vector< char > *)jarg1; 
  result = ((std::vector< char > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_CharVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  std::vector< char >::size_type result;
  
  arg1 = (std::vector< char > *)jarg1; 
  result = ((std::vector< char > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CharVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  std::vector< char >::size_type arg2 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  arg2 = (std::vector< char >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_CharVector__SWIG_0() {
  void * jresult ;
  std::vector< char > *result = 0 ;
  
  result = (std::vector< char > *)new std::vector< char >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_CharVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< char > *arg1 = 0 ;
  std::vector< char > *result = 0 ;
  
  arg1 = (std::vector< char > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< char > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< char > *)new std::vector< char >((std::vector< char > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_CharVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< char > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< char > *)new_std_vector_Sl_char_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT char SWIGSTDCALL CSharp_CNTK_CharVector_getitemcopy(void * jarg1, int jarg2) {
  char jresult ;
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  int arg2 ;
  char result;
  
  arg1 = (std::vector< char > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (char)std_vector_Sl_char_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT char SWIGSTDCALL CSharp_CNTK_CharVector_getitem(void * jarg1, int jarg2) {
  char jresult ;
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  int arg2 ;
  char *result = 0 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (char *) &std_vector_Sl_char_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CharVector_setitem(void * jarg1, int jarg2, char jarg3) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  int arg2 ;
  char *arg3 = 0 ;
  char temp3 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (char)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_char_Sg__setitem(arg1,arg2,(char const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CharVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  std::vector< char > *arg2 = 0 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  arg2 = (std::vector< char > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< char > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_char_Sg__AddRange(arg1,(std::vector< char > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CharVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< char > *result = 0 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< char > *)std_vector_Sl_char_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CharVector_Insert(void * jarg1, int jarg2, char jarg3) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  int arg2 ;
  char *arg3 = 0 ;
  char temp3 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (char)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_char_Sg__Insert(arg1,arg2,(char const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CharVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  int arg2 ;
  std::vector< char > *arg3 = 0 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< char > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< char > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_char_Sg__InsertRange(arg1,arg2,(std::vector< char > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CharVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_char_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CharVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_char_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CharVector_Repeat(char jarg1, int jarg2) {
  void * jresult ;
  char *arg1 = 0 ;
  int arg2 ;
  char temp1 ;
  std::vector< char > *result = 0 ;
  
  temp1 = (char)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< char > *)std_vector_Sl_char_Sg__Repeat((char const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CharVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  std_vector_Sl_char_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CharVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_char_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CharVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  int arg2 ;
  std::vector< char > *arg3 = 0 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< char > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< char > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_char_Sg__SetRange(arg1,arg2,(std::vector< char > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_CharVector_Contains(void * jarg1, char jarg2) {
  unsigned int jresult ;
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  char *arg2 = 0 ;
  char temp2 ;
  bool result;
  
  arg1 = (std::vector< char > *)jarg1; 
  temp2 = (char)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_char_Sg__Contains(arg1,(char const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_CharVector_IndexOf(void * jarg1, char jarg2) {
  int jresult ;
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  char *arg2 = 0 ;
  char temp2 ;
  int result;
  
  arg1 = (std::vector< char > *)jarg1; 
  temp2 = (char)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_char_Sg__IndexOf(arg1,(char const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_CharVector_LastIndexOf(void * jarg1, char jarg2) {
  int jresult ;
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  char *arg2 = 0 ;
  char temp2 ;
  int result;
  
  arg1 = (std::vector< char > *)jarg1; 
  temp2 = (char)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_char_Sg__LastIndexOf(arg1,(char const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_CharVector_Remove(void * jarg1, char jarg2) {
  unsigned int jresult ;
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  char *arg2 = 0 ;
  char temp2 ;
  bool result;
  
  arg1 = (std::vector< char > *)jarg1; 
  temp2 = (char)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_char_Sg__Remove(arg1,(char const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_CharVector(void * jarg1) {
  std::vector< char > *arg1 = (std::vector< char > *) 0 ;
  
  arg1 = (std::vector< char > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_IntVector_Clear(void * jarg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_IntVector_Add(void * jarg1, int jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((int const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_IntVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type result;
  
  arg1 = (std::vector< int > *)jarg1; 
  result = ((std::vector< int > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_IntVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type result;
  
  arg1 = (std::vector< int > *)jarg1; 
  result = ((std::vector< int > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_IntVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (std::vector< int >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_IntVector__SWIG_0() {
  void * jresult ;
  std::vector< int > *result = 0 ;
  
  result = (std::vector< int > *)new std::vector< int >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_IntVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< int > *arg1 = 0 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< int > *)new std::vector< int >((std::vector< int > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_IntVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< int > *)new_std_vector_Sl_int_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_IntVector_getitemcopy(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int result;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (int)std_vector_Sl_int_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_IntVector_getitem(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (int *) &std_vector_Sl_int_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_IntVector_setitem(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int *arg3 = 0 ;
  int temp3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (int)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_int_Sg__setitem(arg1,arg2,(int const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_IntVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int > *arg2 = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (std::vector< int > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_int_Sg__AddRange(arg1,(std::vector< int > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_IntVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< int > *)std_vector_Sl_int_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_IntVector_Insert(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int *arg3 = 0 ;
  int temp3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (int)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_int_Sg__Insert(arg1,arg2,(int const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_IntVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  std::vector< int > *arg3 = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_int_Sg__InsertRange(arg1,arg2,(std::vector< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_IntVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_int_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_IntVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_int_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_IntVector_Repeat(int jarg1, int jarg2) {
  void * jresult ;
  int *arg1 = 0 ;
  int arg2 ;
  int temp1 ;
  std::vector< int > *result = 0 ;
  
  temp1 = (int)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< int > *)std_vector_Sl_int_Sg__Repeat((int const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_IntVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  std_vector_Sl_int_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_IntVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_int_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_IntVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  std::vector< int > *arg3 = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_int_Sg__SetRange(arg1,arg2,(std::vector< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_IntVector_Contains(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  bool result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_int_Sg__Contains(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_IntVector_IndexOf(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  int result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_int_Sg__IndexOf(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_IntVector_LastIndexOf(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  int result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_int_Sg__LastIndexOf(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_IntVector_Remove(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  bool result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_int_Sg__Remove(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_IntVector(void * jarg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVector_Clear(void * jarg1) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVector_Add(void * jarg1, unsigned long jarg2) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  size_t *arg2 = 0 ;
  size_t temp2 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  temp2 = (size_t)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((size_t const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_SizeTVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  std::vector< size_t >::size_type result;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  result = ((std::vector< size_t > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_SizeTVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  std::vector< size_t >::size_type result;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  result = ((std::vector< size_t > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  std::vector< size_t >::size_type arg2 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (std::vector< size_t >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_SizeTVector__SWIG_0() {
  void * jresult ;
  std::vector< size_t > *result = 0 ;
  
  result = (std::vector< size_t > *)new std::vector< size_t >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_SizeTVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< size_t > *arg1 = 0 ;
  std::vector< size_t > *result = 0 ;
  
  arg1 = (std::vector< size_t > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< size_t > *)new std::vector< size_t >((std::vector< size_t > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_SizeTVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< size_t > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< size_t > *)new_std_vector_Sl_size_t_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_SizeTVector_getitemcopy(void * jarg1, int jarg2) {
  unsigned long jresult ;
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  int arg2 ;
  size_t result;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_size_t_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_SizeTVector_getitem(void * jarg1, int jarg2) {
  unsigned long jresult ;
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  int arg2 ;
  size_t *result = 0 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (size_t *) &std_vector_Sl_size_t_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (unsigned long)*result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVector_setitem(void * jarg1, int jarg2, unsigned long jarg3) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  int arg2 ;
  size_t *arg3 = 0 ;
  size_t temp3 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (size_t)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_size_t_Sg__setitem(arg1,arg2,(size_t const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  std::vector< size_t > *arg2 = 0 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_size_t_Sg__AddRange(arg1,(std::vector< size_t > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SizeTVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< size_t > *result = 0 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< size_t > *)std_vector_Sl_size_t_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVector_Insert(void * jarg1, int jarg2, unsigned long jarg3) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  int arg2 ;
  size_t *arg3 = 0 ;
  size_t temp3 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (size_t)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_size_t_Sg__Insert(arg1,arg2,(size_t const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  int arg2 ;
  std::vector< size_t > *arg3 = 0 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< size_t > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_size_t_Sg__InsertRange(arg1,arg2,(std::vector< size_t > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_size_t_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_size_t_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SizeTVector_Repeat(unsigned long jarg1, int jarg2) {
  void * jresult ;
  size_t *arg1 = 0 ;
  int arg2 ;
  size_t temp1 ;
  std::vector< size_t > *result = 0 ;
  
  temp1 = (size_t)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< size_t > *)std_vector_Sl_size_t_Sg__Repeat((size_t const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  std_vector_Sl_size_t_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_size_t_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  int arg2 ;
  std::vector< size_t > *arg3 = 0 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< size_t > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_size_t_Sg__SetRange(arg1,arg2,(std::vector< size_t > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_SizeTVector_Contains(void * jarg1, unsigned long jarg2) {
  unsigned int jresult ;
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  size_t *arg2 = 0 ;
  size_t temp2 ;
  bool result;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  temp2 = (size_t)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_size_t_Sg__Contains(arg1,(size_t const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_SizeTVector_IndexOf(void * jarg1, unsigned long jarg2) {
  int jresult ;
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  size_t *arg2 = 0 ;
  size_t temp2 ;
  int result;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  temp2 = (size_t)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_size_t_Sg__IndexOf(arg1,(size_t const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_SizeTVector_LastIndexOf(void * jarg1, unsigned long jarg2) {
  int jresult ;
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  size_t *arg2 = 0 ;
  size_t temp2 ;
  int result;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  temp2 = (size_t)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_size_t_Sg__LastIndexOf(arg1,(size_t const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_SizeTVector_Remove(void * jarg1, unsigned long jarg2) {
  unsigned int jresult ;
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  size_t *arg2 = 0 ;
  size_t temp2 ;
  bool result;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  temp2 = (size_t)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_size_t_Sg__Remove(arg1,(size_t const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_SizeTVector(void * jarg1) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVector_Clear(void * jarg1) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVector_Add(void * jarg1, double jarg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((double const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_DoubleVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type result;
  
  arg1 = (std::vector< double > *)jarg1; 
  result = ((std::vector< double > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_DoubleVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type result;
  
  arg1 = (std::vector< double > *)jarg1; 
  result = ((std::vector< double > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (std::vector< double >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DoubleVector__SWIG_0() {
  void * jresult ;
  std::vector< double > *result = 0 ;
  
  result = (std::vector< double > *)new std::vector< double >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DoubleVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< double > *arg1 = 0 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (std::vector< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< double > *)new std::vector< double >((std::vector< double > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DoubleVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< double > *)new_std_vector_Sl_double_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_DoubleVector_getitemcopy(void * jarg1, int jarg2) {
  double jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  double result;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (double)std_vector_Sl_double_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_DoubleVector_getitem(void * jarg1, int jarg2) {
  double jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  double *result = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (double *) &std_vector_Sl_double_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVector_setitem(void * jarg1, int jarg2, double jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  double *arg3 = 0 ;
  double temp3 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (double)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_double_Sg__setitem(arg1,arg2,(double const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double > *arg2 = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (std::vector< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_double_Sg__AddRange(arg1,(std::vector< double > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DoubleVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< double > *)std_vector_Sl_double_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVector_Insert(void * jarg1, int jarg2, double jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  double *arg3 = 0 ;
  double temp3 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (double)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_double_Sg__Insert(arg1,arg2,(double const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  std::vector< double > *arg3 = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_double_Sg__InsertRange(arg1,arg2,(std::vector< double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_double_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_double_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DoubleVector_Repeat(double jarg1, int jarg2) {
  void * jresult ;
  double *arg1 = 0 ;
  int arg2 ;
  double temp1 ;
  std::vector< double > *result = 0 ;
  
  temp1 = (double)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< double > *)std_vector_Sl_double_Sg__Repeat((double const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  std_vector_Sl_double_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_double_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  std::vector< double > *arg3 = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_double_Sg__SetRange(arg1,arg2,(std::vector< double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DoubleVector_Contains(void * jarg1, double jarg2) {
  unsigned int jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  bool result;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_double_Sg__Contains(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_DoubleVector_IndexOf(void * jarg1, double jarg2) {
  int jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  int result;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_double_Sg__IndexOf(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_DoubleVector_LastIndexOf(void * jarg1, double jarg2) {
  int jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  int result;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_double_Sg__LastIndexOf(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DoubleVector_Remove(void * jarg1, double jarg2) {
  unsigned int jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  bool result;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_double_Sg__Remove(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_DoubleVector(void * jarg1) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVector_Clear(void * jarg1) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVector_Add(void * jarg1, float jarg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *arg2 = 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  float temp2 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((float const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_FloatVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::shared_ptr< std::vector< float > const > *smartarg1 = 0 ;
  std::vector< float >::size_type result;
  
  
  smartarg1 = (std::shared_ptr< const std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  result = ((std::vector< float > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_FloatVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::shared_ptr< std::vector< float > const > *smartarg1 = 0 ;
  std::vector< float >::size_type result;
  
  
  smartarg1 = (std::shared_ptr< const std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  result = ((std::vector< float > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::vector< float >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_FloatVector__SWIG_0() {
  void * jresult ;
  std::vector< float > *result = 0 ;
  
  result = (std::vector< float > *)new std::vector< float >();
  
  jresult = result ? new std::shared_ptr<  std::vector<float> >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_FloatVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< float > *arg1 = 0 ;
  std::vector< float > *result = 0 ;
  
  
  arg1 = (std::vector< float > *)(((std::shared_ptr< const std::vector<float> > *)jarg1) ? ((std::shared_ptr< const std::vector<float> > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & reference is null", 0);
    return 0;
  } 
  result = (std::vector< float > *)new std::vector< float >((std::vector< float > const &)*arg1);
  
  jresult = result ? new std::shared_ptr<  std::vector<float> >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_FloatVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< float > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< float > *)new_std_vector_Sl_float_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  
  jresult = result ? new std::shared_ptr<  std::vector<float> >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CNTK_FloatVector_getitemcopy(void * jarg1, int jarg2) {
  float jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  float result;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  try {
    result = (float)std_vector_Sl_float_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CNTK_FloatVector_getitem(void * jarg1, int jarg2) {
  float jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  float *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  try {
    result = (float *) &std_vector_Sl_float_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVector_setitem(void * jarg1, int jarg2, float jarg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  float *arg3 = 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  float temp3 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  temp3 = (float)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_float_Sg__setitem(arg1,arg2,(float const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float > *arg2 = 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  
  arg2 = (std::vector< float > *)(((std::shared_ptr< const std::vector<float> > *)jarg2) ? ((std::shared_ptr< const std::vector<float> > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & reference is null", 0);
    return ;
  } 
  std_vector_Sl_float_Sg__AddRange(arg1,(std::vector< float > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FloatVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  std::vector< float > *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< float > *)std_vector_Sl_float_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  
  jresult = result ? new std::shared_ptr<  std::vector<float> >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVector_Insert(void * jarg1, int jarg2, float jarg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  float *arg3 = 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  float temp3 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  temp3 = (float)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_float_Sg__Insert(arg1,arg2,(float const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  std::vector< float > *arg3 = 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  
  arg3 = (std::vector< float > *)(((std::shared_ptr< const std::vector<float> > *)jarg3) ? ((std::shared_ptr< const std::vector<float> > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & reference is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_float_Sg__InsertRange(arg1,arg2,(std::vector< float > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_float_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_float_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FloatVector_Repeat(float jarg1, int jarg2) {
  void * jresult ;
  float *arg1 = 0 ;
  int arg2 ;
  float temp1 ;
  std::vector< float > *result = 0 ;
  
  temp1 = (float)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< float > *)std_vector_Sl_float_Sg__Repeat((float const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  
  jresult = result ? new std::shared_ptr<  std::vector<float> >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  std_vector_Sl_float_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_float_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  std::vector< float > *arg3 = 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  
  arg3 = (std::vector< float > *)(((std::shared_ptr< const std::vector<float> > *)jarg3) ? ((std::shared_ptr< const std::vector<float> > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & reference is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_float_Sg__SetRange(arg1,arg2,(std::vector< float > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_FloatVector_Contains(void * jarg1, float jarg2) {
  unsigned int jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *arg2 = 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  float temp2 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_float_Sg__Contains(arg1,(float const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_FloatVector_IndexOf(void * jarg1, float jarg2) {
  int jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *arg2 = 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  float temp2 ;
  int result;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_float_Sg__IndexOf(arg1,(float const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_FloatVector_LastIndexOf(void * jarg1, float jarg2) {
  int jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *arg2 = 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  float temp2 ;
  int result;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_float_Sg__LastIndexOf(arg1,(float const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_FloatVector_Remove(void * jarg1, float jarg2) {
  unsigned int jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *arg2 = 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  float temp2 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_float_Sg__Remove(arg1,(float const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_FloatVector(void * jarg1) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::shared_ptr< std::vector< float > > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  std::vector<float> > *)jarg1;
  arg1 = (std::vector<float> *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (void)arg1; delete smartarg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariableVector_Clear(void * jarg1) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariableVector_Add(void * jarg1, void * jarg2) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  CNTK::Variable *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((CNTK::Variable const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_VariableVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  std::vector< CNTK::Variable >::size_type result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  result = ((std::vector< CNTK::Variable > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_VariableVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  std::vector< CNTK::Variable >::size_type result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  result = ((std::vector< CNTK::Variable > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariableVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  std::vector< CNTK::Variable >::size_type arg2 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (std::vector< CNTK::Variable >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_VariableVector__SWIG_0() {
  void * jresult ;
  std::vector< CNTK::Variable > *result = 0 ;
  
  result = (std::vector< CNTK::Variable > *)new std::vector< CNTK::Variable >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_VariableVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = 0 ;
  std::vector< CNTK::Variable > *result = 0 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< CNTK::Variable > *)new std::vector< CNTK::Variable >((std::vector< CNTK::Variable > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_VariableVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< CNTK::Variable > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< CNTK::Variable > *)new_std_vector_Sl_CNTK_Variable_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VariableVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  int arg2 ;
  CNTK::Variable result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_CNTK_Variable_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VariableVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  int arg2 ;
  CNTK::Variable *result = 0 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (CNTK::Variable *) &std_vector_Sl_CNTK_Variable_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariableVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  int arg2 ;
  CNTK::Variable *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Variable_Sg__setitem(arg1,arg2,(CNTK::Variable const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariableVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  std::vector< CNTK::Variable > *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (std::vector< CNTK::Variable > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_CNTK_Variable_Sg__AddRange(arg1,(std::vector< CNTK::Variable > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VariableVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< CNTK::Variable > *result = 0 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< CNTK::Variable > *)std_vector_Sl_CNTK_Variable_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariableVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  int arg2 ;
  CNTK::Variable *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Variable_Sg__Insert(arg1,arg2,(CNTK::Variable const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariableVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  int arg2 ;
  std::vector< CNTK::Variable > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::Variable > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Variable_Sg__InsertRange(arg1,arg2,(std::vector< CNTK::Variable > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariableVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_CNTK_Variable_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariableVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_Variable_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VariableVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  int arg2 ;
  std::vector< CNTK::Variable > *result = 0 ;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< CNTK::Variable > *)std_vector_Sl_CNTK_Variable_Sg__Repeat((CNTK::Variable const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariableVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  std_vector_Sl_CNTK_Variable_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariableVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_Variable_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariableVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  int arg2 ;
  std::vector< CNTK::Variable > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::Variable > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Variable_Sg__SetRange(arg1,arg2,(std::vector< CNTK::Variable > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_VariableVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  CNTK::Variable *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  result = (bool)std_vector_Sl_CNTK_Variable_Sg__Contains(arg1,(CNTK::Variable const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_VariableVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  CNTK::Variable *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  result = (int)std_vector_Sl_CNTK_Variable_Sg__IndexOf(arg1,(CNTK::Variable const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_VariableVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  CNTK::Variable *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  result = (int)std_vector_Sl_CNTK_Variable_Sg__LastIndexOf(arg1,(CNTK::Variable const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_VariableVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  CNTK::Variable *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  result = (bool)std_vector_Sl_CNTK_Variable_Sg__Remove(arg1,(CNTK::Variable const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_VariableVector(void * jarg1) {
  std::vector< CNTK::Variable > *arg1 = (std::vector< CNTK::Variable > *) 0 ;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AxisVector_Clear(void * jarg1) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AxisVector_Add(void * jarg1, void * jarg2) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  CNTK::Axis *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((CNTK::Axis const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_AxisVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  std::vector< CNTK::Axis >::size_type result;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  result = ((std::vector< CNTK::Axis > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_AxisVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  std::vector< CNTK::Axis >::size_type result;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  result = ((std::vector< CNTK::Axis > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AxisVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  std::vector< CNTK::Axis >::size_type arg2 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (std::vector< CNTK::Axis >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_AxisVector__SWIG_0() {
  void * jresult ;
  std::vector< CNTK::Axis > *result = 0 ;
  
  result = (std::vector< CNTK::Axis > *)new std::vector< CNTK::Axis >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_AxisVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::Axis > *arg1 = 0 ;
  std::vector< CNTK::Axis > *result = 0 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< CNTK::Axis > *)new std::vector< CNTK::Axis >((std::vector< CNTK::Axis > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_AxisVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< CNTK::Axis > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< CNTK::Axis > *)new_std_vector_Sl_CNTK_Axis_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AxisVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  int arg2 ;
  CNTK::Axis result;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_CNTK_Axis_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new CNTK::Axis((const CNTK::Axis &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AxisVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  int arg2 ;
  CNTK::Axis *result = 0 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (CNTK::Axis *) &std_vector_Sl_CNTK_Axis_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AxisVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  int arg2 ;
  CNTK::Axis *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Axis_Sg__setitem(arg1,arg2,(CNTK::Axis const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AxisVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_CNTK_Axis_Sg__AddRange(arg1,(std::vector< CNTK::Axis > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AxisVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< CNTK::Axis > *result = 0 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< CNTK::Axis > *)std_vector_Sl_CNTK_Axis_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AxisVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  int arg2 ;
  CNTK::Axis *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Axis_Sg__Insert(arg1,arg2,(CNTK::Axis const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AxisVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  int arg2 ;
  std::vector< CNTK::Axis > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::Axis > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Axis_Sg__InsertRange(arg1,arg2,(std::vector< CNTK::Axis > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AxisVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_CNTK_Axis_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AxisVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_Axis_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AxisVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::Axis *arg1 = 0 ;
  int arg2 ;
  std::vector< CNTK::Axis > *result = 0 ;
  
  arg1 = (CNTK::Axis *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< CNTK::Axis > *)std_vector_Sl_CNTK_Axis_Sg__Repeat((CNTK::Axis const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AxisVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  std_vector_Sl_CNTK_Axis_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AxisVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_Axis_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AxisVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  int arg2 ;
  std::vector< CNTK::Axis > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::Axis > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Axis_Sg__SetRange(arg1,arg2,(std::vector< CNTK::Axis > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_AxisVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  CNTK::Axis *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  result = (bool)std_vector_Sl_CNTK_Axis_Sg__Contains(arg1,(CNTK::Axis const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_AxisVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  CNTK::Axis *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  result = (int)std_vector_Sl_CNTK_Axis_Sg__IndexOf(arg1,(CNTK::Axis const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_AxisVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  CNTK::Axis *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  result = (int)std_vector_Sl_CNTK_Axis_Sg__LastIndexOf(arg1,(CNTK::Axis const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_AxisVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  CNTK::Axis *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  result = (bool)std_vector_Sl_CNTK_Axis_Sg__Remove(arg1,(CNTK::Axis const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_AxisVector(void * jarg1) {
  std::vector< CNTK::Axis > *arg1 = (std::vector< CNTK::Axis > *) 0 ;
  
  arg1 = (std::vector< CNTK::Axis > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_Clear(void * jarg1) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_Add(void * jarg1, void * jarg2) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::shared_ptr< CNTK::NDArrayView > *arg2 = 0 ;
  std::shared_ptr< CNTK::NDArrayView > tempnull2 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = jarg2 ? (std::shared_ptr< CNTK::NDArrayView > *)jarg2 : &tempnull2; 
  (arg1)->push_back((std::shared_ptr< CNTK::NDArrayView > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  result = ((std::vector< std::shared_ptr< CNTK::NDArrayView > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  result = ((std::vector< std::shared_ptr< CNTK::NDArrayView > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (std::vector< std::shared_ptr< CNTK::NDArrayView > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayViewPtrVector__SWIG_0() {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)new std::vector< std::shared_ptr< CNTK::NDArrayView > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayViewPtrVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = 0 ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::NDArrayView > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)new std::vector< std::shared_ptr< CNTK::NDArrayView > >((std::vector< std::shared_ptr< CNTK::NDArrayView > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayViewPtrVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)new_std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::NDArrayView > result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result ? new std::shared_ptr< CNTK::NDArrayView >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::NDArrayView > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::shared_ptr< CNTK::NDArrayView > *) &std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result ? new std::shared_ptr< CNTK::NDArrayView >(*result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::NDArrayView > *arg3 = 0 ;
  std::shared_ptr< CNTK::NDArrayView > tempnull3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = jarg3 ? (std::shared_ptr< CNTK::NDArrayView > *)jarg3 : &tempnull3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__setitem(arg1,arg2,(std::shared_ptr< CNTK::NDArrayView > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::NDArrayView > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__AddRange(arg1,(std::vector< std::shared_ptr< CNTK::NDArrayView > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::NDArrayView > *arg3 = 0 ;
  std::shared_ptr< CNTK::NDArrayView > tempnull3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = jarg3 ? (std::shared_ptr< CNTK::NDArrayView > *)jarg3 : &tempnull3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Insert(arg1,arg2,(std::shared_ptr< CNTK::NDArrayView > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::NDArrayView > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::shared_ptr< CNTK::NDArrayView > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::shared_ptr< CNTK::NDArrayView > *arg1 = 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::NDArrayView > tempnull1 ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *result = 0 ;
  
  arg1 = jarg1 ? (std::shared_ptr< CNTK::NDArrayView > *)jarg1 : &tempnull1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Repeat((std::shared_ptr< CNTK::NDArrayView > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::NDArrayView > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::shared_ptr< CNTK::NDArrayView > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::shared_ptr< CNTK::NDArrayView > *arg2 = 0 ;
  std::shared_ptr< CNTK::NDArrayView > tempnull2 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = jarg2 ? (std::shared_ptr< CNTK::NDArrayView > *)jarg2 : &tempnull2; 
  result = (bool)std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Contains(arg1,(std::shared_ptr< CNTK::NDArrayView > const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::shared_ptr< CNTK::NDArrayView > *arg2 = 0 ;
  std::shared_ptr< CNTK::NDArrayView > tempnull2 ;
  int result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = jarg2 ? (std::shared_ptr< CNTK::NDArrayView > *)jarg2 : &tempnull2; 
  result = (int)std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__IndexOf(arg1,(std::shared_ptr< CNTK::NDArrayView > const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::shared_ptr< CNTK::NDArrayView > *arg2 = 0 ;
  std::shared_ptr< CNTK::NDArrayView > tempnull2 ;
  int result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = jarg2 ? (std::shared_ptr< CNTK::NDArrayView > *)jarg2 : &tempnull2; 
  result = (int)std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__LastIndexOf(arg1,(std::shared_ptr< CNTK::NDArrayView > const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_NDArrayViewPtrVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::shared_ptr< CNTK::NDArrayView > *arg2 = 0 ;
  std::shared_ptr< CNTK::NDArrayView > tempnull2 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = jarg2 ? (std::shared_ptr< CNTK::NDArrayView > *)jarg2 : &tempnull2; 
  result = (bool)std_vector_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Remove(arg1,(std::shared_ptr< CNTK::NDArrayView > const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_NDArrayViewPtrVector(void * jarg1) {
  std::vector< std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_BoolVector_Clear(void * jarg1) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_BoolVector_Add(void * jarg1, unsigned int jarg2) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  bool *arg2 = 0 ;
  bool temp2 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  temp2 = jarg2 ? true : false; 
  arg2 = &temp2; 
  (arg1)->push_back((bool const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_BoolVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  std::vector< bool >::size_type result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  result = ((std::vector< bool > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_BoolVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  std::vector< bool >::size_type result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  result = ((std::vector< bool > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_BoolVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  std::vector< bool >::size_type arg2 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (std::vector< bool >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_BoolVector__SWIG_0() {
  void * jresult ;
  std::vector< bool > *result = 0 ;
  
  result = (std::vector< bool > *)new std::vector< bool >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_BoolVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< bool > *arg1 = 0 ;
  std::vector< bool > *result = 0 ;
  
  arg1 = (std::vector< bool > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< bool > *)new std::vector< bool >((std::vector< bool > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_BoolVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< bool > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< bool > *)new_std_vector_Sl_bool_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_BoolVector_getitemcopy(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (bool)std_vector_Sl_bool_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_BoolVector_getitem(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (bool)std_vector_Sl_bool_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_BoolVector_setitem(void * jarg1, int jarg2, unsigned int jarg3) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  bool *arg3 = 0 ;
  bool temp3 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = jarg3 ? true : false; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_bool_Sg__setitem(arg1,arg2,(bool const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_BoolVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  std::vector< bool > *arg2 = 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (std::vector< bool > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_bool_Sg__AddRange(arg1,(std::vector< bool > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BoolVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< bool > *result = 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< bool > *)std_vector_Sl_bool_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_BoolVector_Insert(void * jarg1, int jarg2, unsigned int jarg3) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  bool *arg3 = 0 ;
  bool temp3 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = jarg3 ? true : false; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_bool_Sg__Insert(arg1,arg2,(bool const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_BoolVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  std::vector< bool > *arg3 = 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_bool_Sg__InsertRange(arg1,arg2,(std::vector< bool > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_BoolVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_bool_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_BoolVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_bool_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BoolVector_Repeat(unsigned int jarg1, int jarg2) {
  void * jresult ;
  bool *arg1 = 0 ;
  int arg2 ;
  bool temp1 ;
  std::vector< bool > *result = 0 ;
  
  temp1 = jarg1 ? true : false; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< bool > *)std_vector_Sl_bool_Sg__Repeat((bool const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_BoolVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  std_vector_Sl_bool_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_BoolVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_bool_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_BoolVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  int arg2 ;
  std::vector< bool > *arg3 = 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_bool_Sg__SetRange(arg1,arg2,(std::vector< bool > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_BoolVector_Contains(void * jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  bool *arg2 = 0 ;
  bool temp2 ;
  bool result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  temp2 = jarg2 ? true : false; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_bool_Sg__Contains(arg1,(bool const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_BoolVector_IndexOf(void * jarg1, unsigned int jarg2) {
  int jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  bool *arg2 = 0 ;
  bool temp2 ;
  int result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  temp2 = jarg2 ? true : false; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_bool_Sg__IndexOf(arg1,(bool const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_BoolVector_LastIndexOf(void * jarg1, unsigned int jarg2) {
  int jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  bool *arg2 = 0 ;
  bool temp2 ;
  int result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  temp2 = jarg2 ? true : false; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_bool_Sg__LastIndexOf(arg1,(bool const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_BoolVector_Remove(void * jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  bool *arg2 = 0 ;
  bool temp2 ;
  bool result;
  
  arg1 = (std::vector< bool > *)jarg1; 
  temp2 = jarg2 ? true : false; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_bool_Sg__Remove(arg1,(bool const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_BoolVector(void * jarg1) {
  std::vector< bool > *arg1 = (std::vector< bool > *) 0 ;
  
  arg1 = (std::vector< bool > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_Clear(void * jarg1) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_Add(void * jarg1, void * jarg2) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((CNTK::DeviceDescriptor const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  std::vector< CNTK::DeviceDescriptor >::size_type result;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  result = ((std::vector< CNTK::DeviceDescriptor > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  std::vector< CNTK::DeviceDescriptor >::size_type result;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  result = ((std::vector< CNTK::DeviceDescriptor > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  std::vector< CNTK::DeviceDescriptor >::size_type arg2 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (std::vector< CNTK::DeviceDescriptor >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DeviceDescriptorVector__SWIG_0() {
  void * jresult ;
  std::vector< CNTK::DeviceDescriptor > *result = 0 ;
  
  result = (std::vector< CNTK::DeviceDescriptor > *)new std::vector< CNTK::DeviceDescriptor >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DeviceDescriptorVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::DeviceDescriptor > *arg1 = 0 ;
  std::vector< CNTK::DeviceDescriptor > *result = 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::DeviceDescriptor > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< CNTK::DeviceDescriptor > *)new std::vector< CNTK::DeviceDescriptor >((std::vector< CNTK::DeviceDescriptor > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DeviceDescriptorVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< CNTK::DeviceDescriptor > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< CNTK::DeviceDescriptor > *)new_std_vector_Sl_CNTK_DeviceDescriptor_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  int arg2 ;
  SwigValueWrapper< CNTK::DeviceDescriptor > result;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_CNTK_DeviceDescriptor_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new CNTK::DeviceDescriptor((const CNTK::DeviceDescriptor &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  int arg2 ;
  CNTK::DeviceDescriptor *result = 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (CNTK::DeviceDescriptor *) &std_vector_Sl_CNTK_DeviceDescriptor_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  int arg2 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_DeviceDescriptor_Sg__setitem(arg1,arg2,(CNTK::DeviceDescriptor const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  std::vector< CNTK::DeviceDescriptor > *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (std::vector< CNTK::DeviceDescriptor > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::DeviceDescriptor > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_CNTK_DeviceDescriptor_Sg__AddRange(arg1,(std::vector< CNTK::DeviceDescriptor > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< CNTK::DeviceDescriptor > *result = 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< CNTK::DeviceDescriptor > *)std_vector_Sl_CNTK_DeviceDescriptor_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  int arg2 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_DeviceDescriptor_Sg__Insert(arg1,arg2,(CNTK::DeviceDescriptor const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  int arg2 ;
  std::vector< CNTK::DeviceDescriptor > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::DeviceDescriptor > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::DeviceDescriptor > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_DeviceDescriptor_Sg__InsertRange(arg1,arg2,(std::vector< CNTK::DeviceDescriptor > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_CNTK_DeviceDescriptor_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_DeviceDescriptor_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::DeviceDescriptor *arg1 = 0 ;
  int arg2 ;
  std::vector< CNTK::DeviceDescriptor > *result = 0 ;
  
  arg1 = (CNTK::DeviceDescriptor *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< CNTK::DeviceDescriptor > *)std_vector_Sl_CNTK_DeviceDescriptor_Sg__Repeat((CNTK::DeviceDescriptor const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  std_vector_Sl_CNTK_DeviceDescriptor_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_DeviceDescriptor_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  int arg2 ;
  std::vector< CNTK::DeviceDescriptor > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::DeviceDescriptor > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::DeviceDescriptor > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_DeviceDescriptor_Sg__SetRange(arg1,arg2,(std::vector< CNTK::DeviceDescriptor > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  result = (bool)std_vector_Sl_CNTK_DeviceDescriptor_Sg__Contains(arg1,(CNTK::DeviceDescriptor const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  result = (int)std_vector_Sl_CNTK_DeviceDescriptor_Sg__IndexOf(arg1,(CNTK::DeviceDescriptor const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  result = (int)std_vector_Sl_CNTK_DeviceDescriptor_Sg__LastIndexOf(arg1,(CNTK::DeviceDescriptor const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DeviceDescriptorVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  result = (bool)std_vector_Sl_CNTK_DeviceDescriptor_Sg__Remove(arg1,(CNTK::DeviceDescriptor const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_DeviceDescriptorVector(void * jarg1) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = (std::vector< CNTK::DeviceDescriptor > *) 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_Clear(void * jarg1) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_Add(void * jarg1, void * jarg2) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  std::vector< size_t > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((std::vector< size_t > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  std::vector< std::vector< size_t > >::size_type result;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  result = ((std::vector< std::vector< size_t > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  std::vector< std::vector< size_t > >::size_type result;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  result = ((std::vector< std::vector< size_t > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  std::vector< std::vector< size_t > >::size_type arg2 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (std::vector< std::vector< size_t > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_SizeTVectorVector__SWIG_0() {
  void * jresult ;
  std::vector< std::vector< size_t > > *result = 0 ;
  
  result = (std::vector< std::vector< size_t > > *)new std::vector< std::vector< size_t > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_SizeTVectorVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::vector< size_t > > *arg1 = 0 ;
  std::vector< std::vector< size_t > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::vector< size_t > > *)new std::vector< std::vector< size_t > >((std::vector< std::vector< size_t > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_SizeTVectorVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::vector< size_t > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::vector< size_t > > *)new_std_vector_Sl_std_vector_Sl_size_t_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  int arg2 ;
  std::vector< size_t > result;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::vector< size_t >((const std::vector< size_t > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  int arg2 ;
  std::vector< size_t > *result = 0 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< size_t > *) &std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  int arg2 ;
  std::vector< size_t > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< size_t > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__setitem(arg1,arg2,(std::vector< size_t > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__AddRange(arg1,(std::vector< std::vector< size_t > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::vector< size_t > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::vector< size_t > > *)std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  int arg2 ;
  std::vector< size_t > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< size_t > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__Insert(arg1,arg2,(std::vector< size_t > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< size_t > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< size_t > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::vector< size_t > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< size_t > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::vector< size_t > > *result = 0 ;
  
  arg1 = (std::vector< size_t > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::vector< size_t > > *)std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__Repeat((std::vector< size_t > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SizeTVectorVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< size_t > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< size_t > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_size_t_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::vector< size_t > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_SizeTVectorVector(void * jarg1) {
  std::vector< std::vector< size_t > > *arg1 = (std::vector< std::vector< size_t > > *) 0 ;
  
  arg1 = (std::vector< std::vector< size_t > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVectorVector_Clear(void * jarg1) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVectorVector_Add(void * jarg1, void * jarg2) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  std::vector< float > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  
  arg2 = (std::vector< float > *)(((std::shared_ptr< const std::vector<float> > *)jarg2) ? ((std::shared_ptr< const std::vector<float> > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & reference is null", 0);
    return ;
  } 
  (arg1)->push_back((std::vector< float > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_FloatVectorVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  std::vector< std::vector< float > >::size_type result;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  result = ((std::vector< std::vector< float > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_FloatVectorVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  std::vector< std::vector< float > >::size_type result;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  result = ((std::vector< std::vector< float > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVectorVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  std::vector< std::vector< float > >::size_type arg2 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (std::vector< std::vector< float > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_FloatVectorVector__SWIG_0() {
  void * jresult ;
  std::vector< std::vector< float > > *result = 0 ;
  
  result = (std::vector< std::vector< float > > *)new std::vector< std::vector< float > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_FloatVectorVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::vector< float > > *arg1 = 0 ;
  std::vector< std::vector< float > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::vector< float > > *)new std::vector< std::vector< float > >((std::vector< std::vector< float > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_FloatVectorVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::vector< float > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::vector< float > > *)new_std_vector_Sl_std_vector_Sl_float_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FloatVectorVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  std::vector< float > result;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_vector_Sl_float_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::shared_ptr<  std::vector<float> >(new std::vector< float >((std::vector< float > &)result)); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FloatVectorVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  std::vector< float > *result = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< float > *) &std_vector_Sl_std_vector_Sl_float_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::shared_ptr< const std::vector<float> >(result SWIG_NO_NULL_DELETER_0); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVectorVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  std::vector< float > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  
  arg3 = (std::vector< float > *)(((std::shared_ptr< const std::vector<float> > *)jarg3) ? ((std::shared_ptr< const std::vector<float> > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & reference is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__setitem(arg1,arg2,(std::vector< float > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVectorVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  std::vector< std::vector< float > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (std::vector< std::vector< float > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_vector_Sl_float_Sg__Sg__AddRange(arg1,(std::vector< std::vector< float > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FloatVectorVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::vector< float > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::vector< float > > *)std_vector_Sl_std_vector_Sl_float_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVectorVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  std::vector< float > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  
  arg3 = (std::vector< float > *)(((std::shared_ptr< const std::vector<float> > *)jarg3) ? ((std::shared_ptr< const std::vector<float> > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & reference is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__Insert(arg1,arg2,(std::vector< float > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVectorVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< float > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< float > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::vector< float > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVectorVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVectorVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FloatVectorVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< float > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::vector< float > > *result = 0 ;
  
  
  arg1 = (std::vector< float > *)(((std::shared_ptr< const std::vector<float> > *)jarg1) ? ((std::shared_ptr< const std::vector<float> > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & reference is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::vector< float > > *)std_vector_Sl_std_vector_Sl_float_Sg__Sg__Repeat((std::vector< float > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVectorVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  std_vector_Sl_std_vector_Sl_float_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVectorVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FloatVectorVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< float > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< float > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::vector< float > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_FloatVectorVector(void * jarg1) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_Clear(void * jarg1) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_Add(void * jarg1, void * jarg2) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  std::vector< double > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (std::vector< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((std::vector< double > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  std::vector< std::vector< double > >::size_type result;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  result = ((std::vector< std::vector< double > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  std::vector< std::vector< double > >::size_type result;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  result = ((std::vector< std::vector< double > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  std::vector< std::vector< double > >::size_type arg2 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (std::vector< std::vector< double > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DoubleVectorVector__SWIG_0() {
  void * jresult ;
  std::vector< std::vector< double > > *result = 0 ;
  
  result = (std::vector< std::vector< double > > *)new std::vector< std::vector< double > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DoubleVectorVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::vector< double > > *arg1 = 0 ;
  std::vector< std::vector< double > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::vector< double > > *)new std::vector< std::vector< double > >((std::vector< std::vector< double > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DoubleVectorVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::vector< double > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::vector< double > > *)new_std_vector_Sl_std_vector_Sl_double_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  std::vector< double > result;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_vector_Sl_double_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::vector< double >((const std::vector< double > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< double > *) &std_vector_Sl_std_vector_Sl_double_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  std::vector< double > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__setitem(arg1,arg2,(std::vector< double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  std::vector< std::vector< double > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (std::vector< std::vector< double > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_vector_Sl_double_Sg__Sg__AddRange(arg1,(std::vector< std::vector< double > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::vector< double > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::vector< double > > *)std_vector_Sl_std_vector_Sl_double_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  std::vector< double > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__Insert(arg1,arg2,(std::vector< double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< double > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::vector< double > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< double > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::vector< double > > *result = 0 ;
  
  arg1 = (std::vector< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::vector< double > > *)std_vector_Sl_std_vector_Sl_double_Sg__Sg__Repeat((std::vector< double > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  std_vector_Sl_std_vector_Sl_double_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DoubleVectorVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< double > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::vector< double > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_DoubleVectorVector(void * jarg1) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapVariableValuePtr__SWIG_0() {
  void * jresult ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *result = 0 ;
  
  result = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)new std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapVariableValuePtr__SWIG_1(void * jarg1) {
  void * jresult ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > const & type is null", 0);
    return 0;
  } 
  result = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)new std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >((std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableValuePtr_size(void * jarg1) {
  unsigned long jresult ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *) 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::size_type result;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1; 
  result = ((std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableValuePtr_empty(void * jarg1) {
  unsigned int jresult ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *) 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1; 
  result = (bool)((std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableValuePtr_Clear(void * jarg1) {
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableValuePtr_getitem(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *) 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::mapped_type *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type const & type is null", 0);
    return 0;
  } 
  try {
    result = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::mapped_type *) &std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__getitem(arg1,(CNTK::Variable const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result ? new std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::mapped_type(*result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableValuePtr_setitem(void * jarg1, void * jarg2, void * jarg3) {
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *) 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::mapped_type *arg3 = 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::mapped_type tempnull3 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type const & type is null", 0);
    return ;
  } 
  arg3 = jarg3 ? (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::mapped_type *)jarg3 : &tempnull3; 
  std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__setitem(arg1,(CNTK::Variable const &)*arg2,(std::shared_ptr< CNTK::Value > const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableValuePtr_ContainsKey(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *) 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type const & type is null", 0);
    return 0;
  } 
  result = (bool)std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__ContainsKey(arg1,(CNTK::Variable const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableValuePtr_Add(void * jarg1, void * jarg2, void * jarg3) {
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *) 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::mapped_type *arg3 = 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::mapped_type tempnull3 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type const & type is null", 0);
    return ;
  } 
  arg3 = jarg3 ? (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::mapped_type *)jarg3 : &tempnull3; 
  try {
    std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__Add(arg1,(CNTK::Variable const &)*arg2,(std::shared_ptr< CNTK::Value > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableValuePtr_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *) 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type const & type is null", 0);
    return 0;
  } 
  result = (bool)std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__Remove(arg1,(CNTK::Variable const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableValuePtr_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *) 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::iterator *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1; 
  result = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::iterator *)std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableValuePtr_get_next_key(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *) 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::iterator *arg2 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::iterator *) 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::iterator *)jarg2; 
  result = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::key_type *) &std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__get_next_key(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableValuePtr_destroy_iterator(void * jarg1, void * jarg2) {
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *) 0 ;
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::iterator *arg2 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::iterator *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > >::iterator *)jarg2; 
  std_unordered_map_Sl_CNTK_Variable_Sc_std_shared_ptr_Sl_CNTK_Value_Sg__Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_UnorderedMapVariableValuePtr(void * jarg1) {
  std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,std::shared_ptr< CNTK::Value > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapVariableVariable__SWIG_0() {
  void * jresult ;
  std::unordered_map< CNTK::Variable,CNTK::Variable > *result = 0 ;
  
  result = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)new std::unordered_map< CNTK::Variable,CNTK::Variable >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapVariableVariable__SWIG_1(void * jarg1) {
  void * jresult ;
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable > *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  result = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)new std::unordered_map< CNTK::Variable,CNTK::Variable >((std::unordered_map< CNTK::Variable,CNTK::Variable > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableVariable_size(void * jarg1) {
  unsigned long jresult ;
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::size_type result;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1; 
  result = ((std::unordered_map< CNTK::Variable,CNTK::Variable > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableVariable_empty(void * jarg1) {
  unsigned int jresult ;
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *) 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1; 
  result = (bool)((std::unordered_map< CNTK::Variable,CNTK::Variable > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableVariable_Clear(void * jarg1) {
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableVariable_getitem(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::mapped_type *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type const & type is null", 0);
    return 0;
  } 
  try {
    result = (std::unordered_map< CNTK::Variable,CNTK::Variable >::mapped_type *) &std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__getitem(arg1,(CNTK::Variable const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableVariable_setitem(void * jarg1, void * jarg2, void * jarg3) {
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::mapped_type *arg3 = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type const & type is null", 0);
    return ;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::Variable >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::Variable >::mapped_type const & type is null", 0);
    return ;
  } 
  std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__setitem(arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableVariable_ContainsKey(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type const & type is null", 0);
    return 0;
  } 
  result = (bool)std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__ContainsKey(arg1,(CNTK::Variable const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableVariable_Add(void * jarg1, void * jarg2, void * jarg3) {
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::mapped_type *arg3 = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type const & type is null", 0);
    return ;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::Variable >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::Variable >::mapped_type const & type is null", 0);
    return ;
  } 
  try {
    std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Add(arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableVariable_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type const & type is null", 0);
    return 0;
  } 
  result = (bool)std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Remove(arg1,(CNTK::Variable const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableVariable_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::iterator *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1; 
  result = (std::unordered_map< CNTK::Variable,CNTK::Variable >::iterator *)std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableVariable_get_next_key(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::iterator *arg2 = (std::unordered_map< CNTK::Variable,CNTK::Variable >::iterator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::Variable >::iterator *)jarg2; 
  result = (std::unordered_map< CNTK::Variable,CNTK::Variable >::key_type *) &std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__get_next_key(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableVariable_destroy_iterator(void * jarg1, void * jarg2) {
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable >::iterator *arg2 = (std::unordered_map< CNTK::Variable,CNTK::Variable >::iterator *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::Variable >::iterator *)jarg2; 
  std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_UnorderedMapVariableVariable(void * jarg1) {
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_Clear(void * jarg1) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_Add(void * jarg1, void * jarg2) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  std::shared_ptr< CNTK::Function > *arg2 = 0 ;
  std::shared_ptr< CNTK::Function > tempnull2 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = jarg2 ? (std::shared_ptr< CNTK::Function > *)jarg2 : &tempnull2; 
  (arg1)->push_back((std::shared_ptr< CNTK::Function > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::Function > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  result = ((std::vector< std::shared_ptr< CNTK::Function > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::Function > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  result = ((std::vector< std::shared_ptr< CNTK::Function > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::Function > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = (std::vector< std::shared_ptr< CNTK::Function > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_FunctionPtrVector__SWIG_0() {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::Function > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< CNTK::Function > > *)new std::vector< std::shared_ptr< CNTK::Function > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_FunctionPtrVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = 0 ;
  std::vector< std::shared_ptr< CNTK::Function > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::Function > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::shared_ptr< CNTK::Function > > *)new std::vector< std::shared_ptr< CNTK::Function > >((std::vector< std::shared_ptr< CNTK::Function > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_FunctionPtrVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::shared_ptr< CNTK::Function > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::shared_ptr< CNTK::Function > > *)new_std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::Function > result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result ? new std::shared_ptr< CNTK::Function >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::Function > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::shared_ptr< CNTK::Function > *) &std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result ? new std::shared_ptr< CNTK::Function >(*result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::Function > *arg3 = 0 ;
  std::shared_ptr< CNTK::Function > tempnull3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = jarg3 ? (std::shared_ptr< CNTK::Function > *)jarg3 : &tempnull3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__setitem(arg1,arg2,(std::shared_ptr< CNTK::Function > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::Function > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::Function > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__AddRange(arg1,(std::vector< std::shared_ptr< CNTK::Function > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::shared_ptr< CNTK::Function > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::shared_ptr< CNTK::Function > > *)std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::Function > *arg3 = 0 ;
  std::shared_ptr< CNTK::Function > tempnull3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = jarg3 ? (std::shared_ptr< CNTK::Function > *)jarg3 : &tempnull3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__Insert(arg1,arg2,(std::shared_ptr< CNTK::Function > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< CNTK::Function > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::Function > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::shared_ptr< CNTK::Function > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::shared_ptr< CNTK::Function > *arg1 = 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::Function > tempnull1 ;
  std::vector< std::shared_ptr< CNTK::Function > > *result = 0 ;
  
  arg1 = jarg1 ? (std::shared_ptr< CNTK::Function > *)jarg1 : &tempnull1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::shared_ptr< CNTK::Function > > *)std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__Repeat((std::shared_ptr< CNTK::Function > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_FunctionPtrVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< CNTK::Function > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::Function > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Function_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::shared_ptr< CNTK::Function > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_FunctionPtrVector(void * jarg1) {
  std::vector< std::shared_ptr< CNTK::Function > > *arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Function > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_Clear(void * jarg1) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_Add(void * jarg1, unsigned char jarg2) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  unsigned char *arg2 = 0 ;
  unsigned char temp2 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  temp2 = (unsigned char)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((unsigned char const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  std::vector< unsigned char >::size_type result;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  result = ((std::vector< unsigned char > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  std::vector< unsigned char >::size_type result;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  result = ((std::vector< unsigned char > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  std::vector< unsigned char >::size_type arg2 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  arg2 = (std::vector< unsigned char >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnsignedCharVector__SWIG_0() {
  void * jresult ;
  std::vector< unsigned char > *result = 0 ;
  
  result = (std::vector< unsigned char > *)new std::vector< unsigned char >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnsignedCharVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< unsigned char > *arg1 = 0 ;
  std::vector< unsigned char > *result = 0 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< unsigned char > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< unsigned char > *)new std::vector< unsigned char >((std::vector< unsigned char > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnsignedCharVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< unsigned char > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< unsigned char > *)new_std_vector_Sl_unsigned_SS_char_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned char SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_getitemcopy(void * jarg1, int jarg2) {
  unsigned char jresult ;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  int arg2 ;
  unsigned char result;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (unsigned char)std_vector_Sl_unsigned_SS_char_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned char SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_getitem(void * jarg1, int jarg2) {
  unsigned char jresult ;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  int arg2 ;
  unsigned char *result = 0 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (unsigned char *) &std_vector_Sl_unsigned_SS_char_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_setitem(void * jarg1, int jarg2, unsigned char jarg3) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  int arg2 ;
  unsigned char *arg3 = 0 ;
  unsigned char temp3 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (unsigned char)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_unsigned_SS_char_Sg__setitem(arg1,arg2,(unsigned char const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  std::vector< unsigned char > *arg2 = 0 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  arg2 = (std::vector< unsigned char > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< unsigned char > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_unsigned_SS_char_Sg__AddRange(arg1,(std::vector< unsigned char > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< unsigned char > *result = 0 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< unsigned char > *)std_vector_Sl_unsigned_SS_char_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_Insert(void * jarg1, int jarg2, unsigned char jarg3) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  int arg2 ;
  unsigned char *arg3 = 0 ;
  unsigned char temp3 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (unsigned char)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_unsigned_SS_char_Sg__Insert(arg1,arg2,(unsigned char const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  int arg2 ;
  std::vector< unsigned char > *arg3 = 0 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< unsigned char > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< unsigned char > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_unsigned_SS_char_Sg__InsertRange(arg1,arg2,(std::vector< unsigned char > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_unsigned_SS_char_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_unsigned_SS_char_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_Repeat(unsigned char jarg1, int jarg2) {
  void * jresult ;
  unsigned char *arg1 = 0 ;
  int arg2 ;
  unsigned char temp1 ;
  std::vector< unsigned char > *result = 0 ;
  
  temp1 = (unsigned char)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< unsigned char > *)std_vector_Sl_unsigned_SS_char_Sg__Repeat((unsigned char const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  std_vector_Sl_unsigned_SS_char_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_unsigned_SS_char_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  int arg2 ;
  std::vector< unsigned char > *arg3 = 0 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< unsigned char > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< unsigned char > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_unsigned_SS_char_Sg__SetRange(arg1,arg2,(std::vector< unsigned char > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_Contains(void * jarg1, unsigned char jarg2) {
  unsigned int jresult ;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  unsigned char *arg2 = 0 ;
  unsigned char temp2 ;
  bool result;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  temp2 = (unsigned char)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_unsigned_SS_char_Sg__Contains(arg1,(unsigned char const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_IndexOf(void * jarg1, unsigned char jarg2) {
  int jresult ;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  unsigned char *arg2 = 0 ;
  unsigned char temp2 ;
  int result;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  temp2 = (unsigned char)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_unsigned_SS_char_Sg__IndexOf(arg1,(unsigned char const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_LastIndexOf(void * jarg1, unsigned char jarg2) {
  int jresult ;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  unsigned char *arg2 = 0 ;
  unsigned char temp2 ;
  int result;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  temp2 = (unsigned char)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_unsigned_SS_char_Sg__LastIndexOf(arg1,(unsigned char const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnsignedCharVector_Remove(void * jarg1, unsigned char jarg2) {
  unsigned int jresult ;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  unsigned char *arg2 = 0 ;
  unsigned char temp2 ;
  bool result;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  temp2 = (unsigned char)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_unsigned_SS_char_Sg__Remove(arg1,(unsigned char const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_UnsignedCharVector(void * jarg1) {
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  
  arg1 = (std::vector< unsigned char > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryVector_Clear(void * jarg1) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryVector_Add(void * jarg1, void * jarg2) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  CNTK::Dictionary *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (CNTK::Dictionary *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((CNTK::Dictionary const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_DictionaryVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  std::vector< CNTK::Dictionary >::size_type result;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  result = ((std::vector< CNTK::Dictionary > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_DictionaryVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  std::vector< CNTK::Dictionary >::size_type result;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  result = ((std::vector< CNTK::Dictionary > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  std::vector< CNTK::Dictionary >::size_type arg2 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (std::vector< CNTK::Dictionary >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DictionaryVector__SWIG_0() {
  void * jresult ;
  std::vector< CNTK::Dictionary > *result = 0 ;
  
  result = (std::vector< CNTK::Dictionary > *)new std::vector< CNTK::Dictionary >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DictionaryVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::Dictionary > *arg1 = 0 ;
  std::vector< CNTK::Dictionary > *result = 0 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Dictionary > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< CNTK::Dictionary > *)new std::vector< CNTK::Dictionary >((std::vector< CNTK::Dictionary > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DictionaryVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< CNTK::Dictionary > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< CNTK::Dictionary > *)new_std_vector_Sl_CNTK_Dictionary_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DictionaryVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  int arg2 ;
  CNTK::Dictionary result;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_CNTK_Dictionary_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new CNTK::Dictionary((const CNTK::Dictionary &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DictionaryVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  int arg2 ;
  CNTK::Dictionary *result = 0 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (CNTK::Dictionary *) &std_vector_Sl_CNTK_Dictionary_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  int arg2 ;
  CNTK::Dictionary *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::Dictionary *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Dictionary_Sg__setitem(arg1,arg2,(CNTK::Dictionary const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  std::vector< CNTK::Dictionary > *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (std::vector< CNTK::Dictionary > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Dictionary > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_CNTK_Dictionary_Sg__AddRange(arg1,(std::vector< CNTK::Dictionary > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DictionaryVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< CNTK::Dictionary > *result = 0 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< CNTK::Dictionary > *)std_vector_Sl_CNTK_Dictionary_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  int arg2 ;
  CNTK::Dictionary *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::Dictionary *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Dictionary_Sg__Insert(arg1,arg2,(CNTK::Dictionary const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  int arg2 ;
  std::vector< CNTK::Dictionary > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::Dictionary > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Dictionary > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Dictionary_Sg__InsertRange(arg1,arg2,(std::vector< CNTK::Dictionary > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_CNTK_Dictionary_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_Dictionary_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DictionaryVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::Dictionary *arg1 = 0 ;
  int arg2 ;
  std::vector< CNTK::Dictionary > *result = 0 ;
  
  arg1 = (CNTK::Dictionary *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< CNTK::Dictionary > *)std_vector_Sl_CNTK_Dictionary_Sg__Repeat((CNTK::Dictionary const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  std_vector_Sl_CNTK_Dictionary_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_Dictionary_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  int arg2 ;
  std::vector< CNTK::Dictionary > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::Dictionary > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Dictionary > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Dictionary_Sg__SetRange(arg1,arg2,(std::vector< CNTK::Dictionary > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DictionaryVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  CNTK::Dictionary *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (CNTK::Dictionary *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return 0;
  } 
  result = (bool)std_vector_Sl_CNTK_Dictionary_Sg__Contains(arg1,(CNTK::Dictionary const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_DictionaryVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  CNTK::Dictionary *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (CNTK::Dictionary *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return 0;
  } 
  result = (int)std_vector_Sl_CNTK_Dictionary_Sg__IndexOf(arg1,(CNTK::Dictionary const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_DictionaryVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  CNTK::Dictionary *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (CNTK::Dictionary *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return 0;
  } 
  result = (int)std_vector_Sl_CNTK_Dictionary_Sg__LastIndexOf(arg1,(CNTK::Dictionary const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DictionaryVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  CNTK::Dictionary *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  arg2 = (CNTK::Dictionary *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return 0;
  } 
  result = (bool)std_vector_Sl_CNTK_Dictionary_Sg__Remove(arg1,(CNTK::Dictionary const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_DictionaryVector(void * jarg1) {
  std::vector< CNTK::Dictionary > *arg1 = (std::vector< CNTK::Dictionary > *) 0 ;
  
  arg1 = (std::vector< CNTK::Dictionary > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapStreamInformationMinibatchData__SWIG_0() {
  void * jresult ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *result = 0 ;
  
  result = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)new std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapStreamInformationMinibatchData__SWIG_1(void * jarg1) {
  void * jresult ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > const & type is null", 0);
    return 0;
  } 
  result = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)new std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >((std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationMinibatchData_size(void * jarg1) {
  unsigned long jresult ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::size_type result;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1; 
  result = ((std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationMinibatchData_empty(void * jarg1) {
  unsigned int jresult ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1; 
  result = (bool)((std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationMinibatchData_Clear(void * jarg1) {
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationMinibatchData_getitem(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::mapped_type *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type const & type is null", 0);
    return 0;
  } 
  try {
    result = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::mapped_type *) &std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__getitem(arg1,(CNTK::StreamInformation const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationMinibatchData_setitem(void * jarg1, void * jarg2, void * jarg3) {
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::mapped_type *arg3 = 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type const & type is null", 0);
    return ;
  } 
  arg3 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::mapped_type const & type is null", 0);
    return ;
  } 
  std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__setitem(arg1,(CNTK::StreamInformation const &)*arg2,(CNTK::MinibatchData const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationMinibatchData_ContainsKey(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type const & type is null", 0);
    return 0;
  } 
  result = (bool)std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__ContainsKey(arg1,(CNTK::StreamInformation const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationMinibatchData_Add(void * jarg1, void * jarg2, void * jarg3) {
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::mapped_type *arg3 = 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type const & type is null", 0);
    return ;
  } 
  arg3 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::mapped_type const & type is null", 0);
    return ;
  } 
  try {
    std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__Add(arg1,(CNTK::StreamInformation const &)*arg2,(CNTK::MinibatchData const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationMinibatchData_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type const & type is null", 0);
    return 0;
  } 
  result = (bool)std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__Remove(arg1,(CNTK::StreamInformation const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationMinibatchData_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::iterator *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1; 
  result = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::iterator *)std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationMinibatchData_get_next_key(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::iterator *arg2 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::iterator *) 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::iterator *)jarg2; 
  result = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::key_type *) &std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__get_next_key(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationMinibatchData_destroy_iterator(void * jarg1, void * jarg2) {
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::iterator *arg2 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::iterator *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData >::iterator *)jarg2; 
  std_unordered_map_Sl_CNTK_StreamInformation_Sc_CNTK_MinibatchData_Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_UnorderedMapStreamInformationMinibatchData(void * jarg1) {
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapVariableMinibatchData__SWIG_0() {
  void * jresult ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *result = 0 ;
  
  result = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)new std::unordered_map< CNTK::Variable,CNTK::MinibatchData >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapVariableMinibatchData__SWIG_1(void * jarg1) {
  void * jresult ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const & type is null", 0);
    return 0;
  } 
  result = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)new std::unordered_map< CNTK::Variable,CNTK::MinibatchData >((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableMinibatchData_size(void * jarg1) {
  unsigned long jresult ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::size_type result;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1; 
  result = ((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableMinibatchData_empty(void * jarg1) {
  unsigned int jresult ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *) 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1; 
  result = (bool)((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableMinibatchData_Clear(void * jarg1) {
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableMinibatchData_getitem(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::mapped_type *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type const & type is null", 0);
    return 0;
  } 
  try {
    result = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::mapped_type *) &std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__getitem(arg1,(CNTK::Variable const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableMinibatchData_setitem(void * jarg1, void * jarg2, void * jarg3) {
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::mapped_type *arg3 = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type const & type is null", 0);
    return ;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::mapped_type const & type is null", 0);
    return ;
  } 
  std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__setitem(arg1,(CNTK::Variable const &)*arg2,(CNTK::MinibatchData const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableMinibatchData_ContainsKey(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type const & type is null", 0);
    return 0;
  } 
  result = (bool)std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__ContainsKey(arg1,(CNTK::Variable const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableMinibatchData_Add(void * jarg1, void * jarg2, void * jarg3) {
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::mapped_type *arg3 = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type const & type is null", 0);
    return ;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::mapped_type const & type is null", 0);
    return ;
  } 
  try {
    std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__Add(arg1,(CNTK::Variable const &)*arg2,(CNTK::MinibatchData const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableMinibatchData_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type const & type is null", 0);
    return 0;
  } 
  result = (bool)std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__Remove(arg1,(CNTK::Variable const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableMinibatchData_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::iterator *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1; 
  result = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::iterator *)std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableMinibatchData_get_next_key(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::iterator *arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::iterator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::iterator *)jarg2; 
  result = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::key_type *) &std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__get_next_key(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapVariableMinibatchData_destroy_iterator(void * jarg1, void * jarg2) {
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::iterator *arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::iterator *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData >::iterator *)jarg2; 
  std_unordered_map_Sl_CNTK_Variable_Sc_CNTK_MinibatchData_Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_UnorderedMapVariableMinibatchData(void * jarg1) {
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_Clear(void * jarg1) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_Add(void * jarg1, void * jarg2) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  CNTK::StreamConfiguration *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (CNTK::StreamConfiguration *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::StreamConfiguration const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((CNTK::StreamConfiguration const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  std::vector< CNTK::StreamConfiguration >::size_type result;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  result = ((std::vector< CNTK::StreamConfiguration > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  std::vector< CNTK::StreamConfiguration >::size_type result;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  result = ((std::vector< CNTK::StreamConfiguration > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  std::vector< CNTK::StreamConfiguration >::size_type arg2 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (std::vector< CNTK::StreamConfiguration >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_StreamConfigurationVector__SWIG_0() {
  void * jresult ;
  std::vector< CNTK::StreamConfiguration > *result = 0 ;
  
  result = (std::vector< CNTK::StreamConfiguration > *)new std::vector< CNTK::StreamConfiguration >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_StreamConfigurationVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::StreamConfiguration > *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *result = 0 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< CNTK::StreamConfiguration > *)new std::vector< CNTK::StreamConfiguration >((std::vector< CNTK::StreamConfiguration > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_StreamConfigurationVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< CNTK::StreamConfiguration > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< CNTK::StreamConfiguration > *)new_std_vector_Sl_CNTK_StreamConfiguration_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  int arg2 ;
  SwigValueWrapper< CNTK::StreamConfiguration > result;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_CNTK_StreamConfiguration_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new CNTK::StreamConfiguration((const CNTK::StreamConfiguration &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  int arg2 ;
  CNTK::StreamConfiguration *result = 0 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (CNTK::StreamConfiguration *) &std_vector_Sl_CNTK_StreamConfiguration_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  int arg2 ;
  CNTK::StreamConfiguration *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::StreamConfiguration *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::StreamConfiguration const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_StreamConfiguration_Sg__setitem(arg1,arg2,(CNTK::StreamConfiguration const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_CNTK_StreamConfiguration_Sg__AddRange(arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< CNTK::StreamConfiguration > *result = 0 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< CNTK::StreamConfiguration > *)std_vector_Sl_CNTK_StreamConfiguration_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  int arg2 ;
  CNTK::StreamConfiguration *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::StreamConfiguration *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::StreamConfiguration const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_StreamConfiguration_Sg__Insert(arg1,arg2,(CNTK::StreamConfiguration const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  int arg2 ;
  std::vector< CNTK::StreamConfiguration > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::StreamConfiguration > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_StreamConfiguration_Sg__InsertRange(arg1,arg2,(std::vector< CNTK::StreamConfiguration > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_CNTK_StreamConfiguration_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_StreamConfiguration_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::StreamConfiguration *arg1 = 0 ;
  int arg2 ;
  std::vector< CNTK::StreamConfiguration > *result = 0 ;
  
  arg1 = (CNTK::StreamConfiguration *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::StreamConfiguration const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< CNTK::StreamConfiguration > *)std_vector_Sl_CNTK_StreamConfiguration_Sg__Repeat((CNTK::StreamConfiguration const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  std_vector_Sl_CNTK_StreamConfiguration_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_StreamConfiguration_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfigurationVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  int arg2 ;
  std::vector< CNTK::StreamConfiguration > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::StreamConfiguration > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_StreamConfiguration_Sg__SetRange(arg1,arg2,(std::vector< CNTK::StreamConfiguration > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_StreamConfigurationVector(void * jarg1) {
  std::vector< CNTK::StreamConfiguration > *arg1 = (std::vector< CNTK::StreamConfiguration > *) 0 ;
  
  arg1 = (std::vector< CNTK::StreamConfiguration > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ParameterVector_Clear(void * jarg1) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ParameterVector_Add(void * jarg1, void * jarg2) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  CNTK::Parameter *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (CNTK::Parameter *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Parameter const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((CNTK::Parameter const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_ParameterVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  std::vector< CNTK::Parameter >::size_type result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  result = ((std::vector< CNTK::Parameter > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_ParameterVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  std::vector< CNTK::Parameter >::size_type result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  result = ((std::vector< CNTK::Parameter > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ParameterVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  std::vector< CNTK::Parameter >::size_type arg2 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (std::vector< CNTK::Parameter >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_ParameterVector__SWIG_0() {
  void * jresult ;
  std::vector< CNTK::Parameter > *result = 0 ;
  
  result = (std::vector< CNTK::Parameter > *)new std::vector< CNTK::Parameter >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_ParameterVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  std::vector< CNTK::Parameter > *result = 0 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< CNTK::Parameter > *)new std::vector< CNTK::Parameter >((std::vector< CNTK::Parameter > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_ParameterVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< CNTK::Parameter > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< CNTK::Parameter > *)new_std_vector_Sl_CNTK_Parameter_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ParameterVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  int arg2 ;
  SwigValueWrapper< CNTK::Parameter > result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_CNTK_Parameter_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new CNTK::Parameter((const CNTK::Parameter &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ParameterVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  int arg2 ;
  CNTK::Parameter *result = 0 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (CNTK::Parameter *) &std_vector_Sl_CNTK_Parameter_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ParameterVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  int arg2 ;
  CNTK::Parameter *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::Parameter *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Parameter const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Parameter_Sg__setitem(arg1,arg2,(CNTK::Parameter const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ParameterVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  std::vector< CNTK::Parameter > *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (std::vector< CNTK::Parameter > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_CNTK_Parameter_Sg__AddRange(arg1,(std::vector< CNTK::Parameter > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ParameterVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< CNTK::Parameter > *result = 0 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< CNTK::Parameter > *)std_vector_Sl_CNTK_Parameter_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ParameterVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  int arg2 ;
  CNTK::Parameter *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::Parameter *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Parameter const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Parameter_Sg__Insert(arg1,arg2,(CNTK::Parameter const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ParameterVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  int arg2 ;
  std::vector< CNTK::Parameter > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::Parameter > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Parameter_Sg__InsertRange(arg1,arg2,(std::vector< CNTK::Parameter > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ParameterVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_CNTK_Parameter_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ParameterVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_Parameter_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ParameterVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::Parameter *arg1 = 0 ;
  int arg2 ;
  std::vector< CNTK::Parameter > *result = 0 ;
  
  arg1 = (CNTK::Parameter *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Parameter const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< CNTK::Parameter > *)std_vector_Sl_CNTK_Parameter_Sg__Repeat((CNTK::Parameter const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ParameterVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  std_vector_Sl_CNTK_Parameter_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ParameterVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_Parameter_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ParameterVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  int arg2 ;
  std::vector< CNTK::Parameter > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::Parameter > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Parameter_Sg__SetRange(arg1,arg2,(std::vector< CNTK::Parameter > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_ParameterVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  CNTK::Parameter *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (CNTK::Parameter *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Parameter const & type is null", 0);
    return 0;
  } 
  result = (bool)std_vector_Sl_CNTK_Parameter_Sg__Contains(arg1,(CNTK::Parameter const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_ParameterVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  CNTK::Parameter *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (CNTK::Parameter *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Parameter const & type is null", 0);
    return 0;
  } 
  result = (int)std_vector_Sl_CNTK_Parameter_Sg__IndexOf(arg1,(CNTK::Parameter const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_ParameterVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  CNTK::Parameter *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (CNTK::Parameter *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Parameter const & type is null", 0);
    return 0;
  } 
  result = (int)std_vector_Sl_CNTK_Parameter_Sg__LastIndexOf(arg1,(CNTK::Parameter const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_ParameterVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  CNTK::Parameter *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  arg2 = (CNTK::Parameter *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Parameter const & type is null", 0);
    return 0;
  } 
  result = (bool)std_vector_Sl_CNTK_Parameter_Sg__Remove(arg1,(CNTK::Parameter const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_ParameterVector(void * jarg1) {
  std::vector< CNTK::Parameter > *arg1 = (std::vector< CNTK::Parameter > *) 0 ;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ConstantVector_Clear(void * jarg1) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ConstantVector_Add(void * jarg1, void * jarg2) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  CNTK::Constant *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (CNTK::Constant *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Constant const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((CNTK::Constant const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_ConstantVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  std::vector< CNTK::Constant >::size_type result;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  result = ((std::vector< CNTK::Constant > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_ConstantVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  std::vector< CNTK::Constant >::size_type result;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  result = ((std::vector< CNTK::Constant > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ConstantVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  std::vector< CNTK::Constant >::size_type arg2 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (std::vector< CNTK::Constant >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_ConstantVector__SWIG_0() {
  void * jresult ;
  std::vector< CNTK::Constant > *result = 0 ;
  
  result = (std::vector< CNTK::Constant > *)new std::vector< CNTK::Constant >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_ConstantVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::Constant > *arg1 = 0 ;
  std::vector< CNTK::Constant > *result = 0 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Constant > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< CNTK::Constant > *)new std::vector< CNTK::Constant >((std::vector< CNTK::Constant > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_ConstantVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< CNTK::Constant > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< CNTK::Constant > *)new_std_vector_Sl_CNTK_Constant_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConstantVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  int arg2 ;
  SwigValueWrapper< CNTK::Constant > result;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_CNTK_Constant_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new CNTK::Constant((const CNTK::Constant &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConstantVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  int arg2 ;
  CNTK::Constant *result = 0 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (CNTK::Constant *) &std_vector_Sl_CNTK_Constant_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ConstantVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  int arg2 ;
  CNTK::Constant *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::Constant *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Constant const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Constant_Sg__setitem(arg1,arg2,(CNTK::Constant const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ConstantVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  std::vector< CNTK::Constant > *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (std::vector< CNTK::Constant > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Constant > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_CNTK_Constant_Sg__AddRange(arg1,(std::vector< CNTK::Constant > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConstantVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< CNTK::Constant > *result = 0 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< CNTK::Constant > *)std_vector_Sl_CNTK_Constant_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ConstantVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  int arg2 ;
  CNTK::Constant *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::Constant *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Constant const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Constant_Sg__Insert(arg1,arg2,(CNTK::Constant const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ConstantVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  int arg2 ;
  std::vector< CNTK::Constant > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::Constant > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Constant > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Constant_Sg__InsertRange(arg1,arg2,(std::vector< CNTK::Constant > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ConstantVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_CNTK_Constant_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ConstantVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_Constant_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConstantVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::Constant *arg1 = 0 ;
  int arg2 ;
  std::vector< CNTK::Constant > *result = 0 ;
  
  arg1 = (CNTK::Constant *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Constant const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< CNTK::Constant > *)std_vector_Sl_CNTK_Constant_Sg__Repeat((CNTK::Constant const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ConstantVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  std_vector_Sl_CNTK_Constant_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ConstantVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_Constant_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ConstantVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  int arg2 ;
  std::vector< CNTK::Constant > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::Constant > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Constant > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_Constant_Sg__SetRange(arg1,arg2,(std::vector< CNTK::Constant > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_ConstantVector(void * jarg1) {
  std::vector< CNTK::Constant > *arg1 = (std::vector< CNTK::Constant > *) 0 ;
  
  arg1 = (std::vector< CNTK::Constant > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StringVector_Clear(void * jarg1) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StringVector_Add(void * jarg1, wchar_t * jarg2) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::wstring *arg2 = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  (arg1)->push_back((std::wstring const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_StringVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::vector< std::wstring >::size_type result;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  result = ((std::vector< std::wstring > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_StringVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::vector< std::wstring >::size_type result;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  result = ((std::vector< std::wstring > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StringVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::vector< std::wstring >::size_type arg2 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (std::vector< std::wstring >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_StringVector__SWIG_0() {
  void * jresult ;
  std::vector< std::wstring > *result = 0 ;
  
  result = (std::vector< std::wstring > *)new std::vector< std::wstring >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_StringVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::wstring > *arg1 = 0 ;
  std::vector< std::wstring > *result = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::wstring > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::wstring > *)new std::vector< std::wstring >((std::vector< std::wstring > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_StringVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::wstring > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::wstring > *)new_std_vector_Sl_std_wstring_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StringVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  std::wstring result;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_wstring_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StringVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  std::wstring *result = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::wstring *) &std_vector_Sl_std_wstring_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StringVector_setitem(void * jarg1, int jarg2, wchar_t * jarg3) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  std::wstring *arg3 = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  try {
    std_vector_Sl_std_wstring_Sg__setitem(arg1,arg2,(std::wstring const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StringVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::vector< std::wstring > *arg2 = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (std::vector< std::wstring > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::wstring > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_wstring_Sg__AddRange(arg1,(std::vector< std::wstring > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StringVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::wstring > *result = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::wstring > *)std_vector_Sl_std_wstring_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StringVector_Insert(void * jarg1, int jarg2, wchar_t * jarg3) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  std::wstring *arg3 = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  try {
    std_vector_Sl_std_wstring_Sg__Insert(arg1,arg2,(std::wstring const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StringVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  std::vector< std::wstring > *arg3 = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::wstring > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::wstring > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_wstring_Sg__InsertRange(arg1,arg2,(std::vector< std::wstring > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StringVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_wstring_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StringVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_wstring_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StringVector_Repeat(wchar_t * jarg1, int jarg2) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  int arg2 ;
  std::vector< std::wstring > *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::wstring > *)std_vector_Sl_std_wstring_Sg__Repeat((std::wstring const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StringVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  std_vector_Sl_std_wstring_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StringVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_wstring_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StringVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  std::vector< std::wstring > *arg3 = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::wstring > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::wstring > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_wstring_Sg__SetRange(arg1,arg2,(std::vector< std::wstring > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_StringVector(void * jarg1) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_Clear(void * jarg1) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_Add(void * jarg1, void * jarg2) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  CNTK::HTKFeatureConfiguration *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (CNTK::HTKFeatureConfiguration *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::HTKFeatureConfiguration const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((CNTK::HTKFeatureConfiguration const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  std::vector< CNTK::HTKFeatureConfiguration >::size_type result;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  result = ((std::vector< CNTK::HTKFeatureConfiguration > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  std::vector< CNTK::HTKFeatureConfiguration >::size_type result;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  result = ((std::vector< CNTK::HTKFeatureConfiguration > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  std::vector< CNTK::HTKFeatureConfiguration >::size_type arg2 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (std::vector< CNTK::HTKFeatureConfiguration >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_HTKFeatureConfigurationVector__SWIG_0() {
  void * jresult ;
  std::vector< CNTK::HTKFeatureConfiguration > *result = 0 ;
  
  result = (std::vector< CNTK::HTKFeatureConfiguration > *)new std::vector< CNTK::HTKFeatureConfiguration >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_HTKFeatureConfigurationVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = 0 ;
  std::vector< CNTK::HTKFeatureConfiguration > *result = 0 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::HTKFeatureConfiguration > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< CNTK::HTKFeatureConfiguration > *)new std::vector< CNTK::HTKFeatureConfiguration >((std::vector< CNTK::HTKFeatureConfiguration > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_HTKFeatureConfigurationVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< CNTK::HTKFeatureConfiguration > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< CNTK::HTKFeatureConfiguration > *)new_std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  int arg2 ;
  SwigValueWrapper< CNTK::HTKFeatureConfiguration > result;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new CNTK::HTKFeatureConfiguration((const CNTK::HTKFeatureConfiguration &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  int arg2 ;
  CNTK::HTKFeatureConfiguration *result = 0 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (CNTK::HTKFeatureConfiguration *) &std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  int arg2 ;
  CNTK::HTKFeatureConfiguration *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::HTKFeatureConfiguration *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::HTKFeatureConfiguration const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__setitem(arg1,arg2,(CNTK::HTKFeatureConfiguration const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  std::vector< CNTK::HTKFeatureConfiguration > *arg2 = 0 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::HTKFeatureConfiguration > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__AddRange(arg1,(std::vector< CNTK::HTKFeatureConfiguration > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< CNTK::HTKFeatureConfiguration > *result = 0 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< CNTK::HTKFeatureConfiguration > *)std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  int arg2 ;
  CNTK::HTKFeatureConfiguration *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (CNTK::HTKFeatureConfiguration *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::HTKFeatureConfiguration const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__Insert(arg1,arg2,(CNTK::HTKFeatureConfiguration const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  int arg2 ;
  std::vector< CNTK::HTKFeatureConfiguration > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::HTKFeatureConfiguration > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__InsertRange(arg1,arg2,(std::vector< CNTK::HTKFeatureConfiguration > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::HTKFeatureConfiguration *arg1 = 0 ;
  int arg2 ;
  std::vector< CNTK::HTKFeatureConfiguration > *result = 0 ;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::HTKFeatureConfiguration const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< CNTK::HTKFeatureConfiguration > *)std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__Repeat((CNTK::HTKFeatureConfiguration const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfigurationVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  int arg2 ;
  std::vector< CNTK::HTKFeatureConfiguration > *arg3 = 0 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::HTKFeatureConfiguration > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CNTK_HTKFeatureConfiguration_Sg__SetRange(arg1,arg2,(std::vector< CNTK::HTKFeatureConfiguration > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_HTKFeatureConfigurationVector(void * jarg1) {
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *) 0 ;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapParameterNDArrayViewPtr__SWIG_0() {
  void * jresult ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *result = 0 ;
  
  result = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)new std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapParameterNDArrayViewPtr__SWIG_1(void * jarg1) {
  void * jresult ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > const & type is null", 0);
    return 0;
  } 
  result = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)new std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >((std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_UnorderedMapParameterNDArrayViewPtr_size(void * jarg1) {
  unsigned long jresult ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::size_type result;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  result = ((std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapParameterNDArrayViewPtr_empty(void * jarg1) {
  unsigned int jresult ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  result = (bool)((std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapParameterNDArrayViewPtr_Clear(void * jarg1) {
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapParameterNDArrayViewPtr_getitem(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::mapped_type *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type const & type is null", 0);
    return 0;
  } 
  try {
    result = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::mapped_type *) &std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__getitem(arg1,(CNTK::Parameter const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result ? new std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::mapped_type(*result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapParameterNDArrayViewPtr_setitem(void * jarg1, void * jarg2, void * jarg3) {
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::mapped_type *arg3 = 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::mapped_type tempnull3 ;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type const & type is null", 0);
    return ;
  } 
  arg3 = jarg3 ? (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::mapped_type *)jarg3 : &tempnull3; 
  std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__setitem(arg1,(CNTK::Parameter const &)*arg2,(std::shared_ptr< CNTK::NDArrayView > const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapParameterNDArrayViewPtr_ContainsKey(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type const & type is null", 0);
    return 0;
  } 
  result = (bool)std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__ContainsKey(arg1,(CNTK::Parameter const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapParameterNDArrayViewPtr_Add(void * jarg1, void * jarg2, void * jarg3) {
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::mapped_type *arg3 = 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::mapped_type tempnull3 ;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type const & type is null", 0);
    return ;
  } 
  arg3 = jarg3 ? (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::mapped_type *)jarg3 : &tempnull3; 
  try {
    std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Add(arg1,(CNTK::Parameter const &)*arg2,(std::shared_ptr< CNTK::NDArrayView > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapParameterNDArrayViewPtr_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type const & type is null", 0);
    return 0;
  } 
  result = (bool)std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Remove(arg1,(CNTK::Parameter const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapParameterNDArrayViewPtr_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::iterator *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  result = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::iterator *)std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapParameterNDArrayViewPtr_get_next_key(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::iterator *arg2 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::iterator *) 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::iterator *)jarg2; 
  result = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::key_type *) &std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__get_next_key(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapParameterNDArrayViewPtr_destroy_iterator(void * jarg1, void * jarg2) {
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::iterator *arg2 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::iterator *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > >::iterator *)jarg2; 
  std_unordered_map_Sl_CNTK_Parameter_Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_UnorderedMapParameterNDArrayViewPtr(void * jarg1) {
  std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::Parameter,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairNDArrayViewPtrNDArrayViewPtr__SWIG_0() {
  void * jresult ;
  std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *result = 0 ;
  
  result = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *)new std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairNDArrayViewPtrNDArrayViewPtr__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  std::shared_ptr< CNTK::NDArrayView > arg1 ;
  std::shared_ptr< CNTK::NDArrayView > arg2 ;
  std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *result = 0 ;
  
  if (jarg1) arg1 = *(std::shared_ptr< CNTK::NDArrayView > *)jarg1; 
  if (jarg2) arg2 = *(std::shared_ptr< CNTK::NDArrayView > *)jarg2; 
  result = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *)new std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > >(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairNDArrayViewPtrNDArrayViewPtr__SWIG_2(void * jarg1) {
  void * jresult ;
  std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *arg1 = 0 ;
  std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *result = 0 ;
  
  arg1 = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > const & type is null", 0);
    return 0;
  } 
  result = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *)new std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > >((std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairNDArrayViewPtrNDArrayViewPtr_first_set(void * jarg1, void * jarg2) {
  std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::shared_ptr< CNTK::NDArrayView > *arg2 = 0 ;
  std::shared_ptr< CNTK::NDArrayView > tempnull2 ;
  
  arg1 = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = jarg2 ? (std::shared_ptr< CNTK::NDArrayView > *)jarg2 : &tempnull2; 
  if (arg1) (arg1)->first = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PairNDArrayViewPtrNDArrayViewPtr_first_get(void * jarg1) {
  void * jresult ;
  std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::shared_ptr< CNTK::NDArrayView > *result = 0 ;
  
  arg1 = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  result = (std::shared_ptr< CNTK::NDArrayView > *) & ((arg1)->first);
  jresult = *result ? new std::shared_ptr< CNTK::NDArrayView >(*result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairNDArrayViewPtrNDArrayViewPtr_second_set(void * jarg1, void * jarg2) {
  std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::shared_ptr< CNTK::NDArrayView > *arg2 = 0 ;
  std::shared_ptr< CNTK::NDArrayView > tempnull2 ;
  
  arg1 = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  arg2 = jarg2 ? (std::shared_ptr< CNTK::NDArrayView > *)jarg2 : &tempnull2; 
  if (arg1) (arg1)->second = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PairNDArrayViewPtrNDArrayViewPtr_second_get(void * jarg1) {
  void * jresult ;
  std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  std::shared_ptr< CNTK::NDArrayView > *result = 0 ;
  
  arg1 = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  result = (std::shared_ptr< CNTK::NDArrayView > *) & ((arg1)->second);
  jresult = *result ? new std::shared_ptr< CNTK::NDArrayView >(*result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_PairNDArrayViewPtrNDArrayViewPtr(void * jarg1) {
  std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *arg1 = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *) 0 ;
  
  arg1 = (std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr__SWIG_0() {
  void * jresult ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *result = 0 ;
  
  result = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)new std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr__SWIG_1(void * jarg1) {
  void * jresult ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > const & type is null", 0);
    return 0;
  } 
  result = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)new std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >((std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr_size(void * jarg1) {
  unsigned long jresult ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::size_type result;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1; 
  result = ((std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr_empty(void * jarg1) {
  unsigned int jresult ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *) 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1; 
  result = (bool)((std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr_Clear(void * jarg1) {
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr_getitem(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::mapped_type *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type const & type is null", 0);
    return 0;
  } 
  try {
    result = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::mapped_type *) &std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__getitem(arg1,(CNTK::StreamInformation const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr_setitem(void * jarg1, void * jarg2, void * jarg3) {
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::mapped_type *arg3 = 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type const & type is null", 0);
    return ;
  } 
  arg3 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::mapped_type const & type is null", 0);
    return ;
  } 
  std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__setitem(arg1,(CNTK::StreamInformation const &)*arg2,(std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr_ContainsKey(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type const & type is null", 0);
    return 0;
  } 
  result = (bool)std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__ContainsKey(arg1,(CNTK::StreamInformation const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr_Add(void * jarg1, void * jarg2, void * jarg3) {
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type *arg2 = 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::mapped_type *arg3 = 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type const & type is null", 0);
    return ;
  } 
  arg3 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::mapped_type const & type is null", 0);
    return ;
  } 
  try {
    std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__Add(arg1,(CNTK::StreamInformation const &)*arg2,(std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type const & type is null", 0);
    return 0;
  } 
  result = (bool)std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__Remove(arg1,(CNTK::StreamInformation const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::iterator *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1; 
  result = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::iterator *)std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr_get_next_key(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::iterator *arg2 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::iterator *) 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type *result = 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::iterator *)jarg2; 
  result = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::key_type *) &std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__get_next_key(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr_destroy_iterator(void * jarg1, void * jarg2) {
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *) 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::iterator *arg2 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::iterator *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > >::iterator *)jarg2; 
  std_unordered_map_Sl_CNTK_StreamInformation_Sc_std_pair_Sl_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sc_std_shared_ptr_Sl_CNTK_NDArrayView_Sg__Sg__Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_UnorderedMapStreamInformationPairNDArrayViewPtrNDArrayViewPtr(void * jarg1) {
  std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *) 0 ;
  
  arg1 = (std::unordered_map< CNTK::StreamInformation,std::pair< std::shared_ptr< CNTK::NDArrayView >,std::shared_ptr< CNTK::NDArrayView > > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_Clear(void * jarg1) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_Add(void * jarg1, void * jarg2) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  std::shared_ptr< CNTK::ProgressWriter > *arg2 = 0 ;
  std::shared_ptr< CNTK::ProgressWriter > tempnull2 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = jarg2 ? (std::shared_ptr< CNTK::ProgressWriter > *)jarg2 : &tempnull2; 
  (arg1)->push_back((std::shared_ptr< CNTK::ProgressWriter > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  result = ((std::vector< std::shared_ptr< CNTK::ProgressWriter > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  result = ((std::vector< std::shared_ptr< CNTK::ProgressWriter > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_ProgressWriterVector__SWIG_0() {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)new std::vector< std::shared_ptr< CNTK::ProgressWriter > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_ProgressWriterVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = 0 ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::ProgressWriter > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)new std::vector< std::shared_ptr< CNTK::ProgressWriter > >((std::vector< std::shared_ptr< CNTK::ProgressWriter > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_ProgressWriterVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)new_std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::ProgressWriter > result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result ? new std::shared_ptr< CNTK::ProgressWriter >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::ProgressWriter > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::shared_ptr< CNTK::ProgressWriter > *) &std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result ? new std::shared_ptr< CNTK::ProgressWriter >(*result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::ProgressWriter > *arg3 = 0 ;
  std::shared_ptr< CNTK::ProgressWriter > tempnull3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = jarg3 ? (std::shared_ptr< CNTK::ProgressWriter > *)jarg3 : &tempnull3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__setitem(arg1,arg2,(std::shared_ptr< CNTK::ProgressWriter > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::ProgressWriter > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__AddRange(arg1,(std::vector< std::shared_ptr< CNTK::ProgressWriter > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::ProgressWriter > *arg3 = 0 ;
  std::shared_ptr< CNTK::ProgressWriter > tempnull3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = jarg3 ? (std::shared_ptr< CNTK::ProgressWriter > *)jarg3 : &tempnull3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__Insert(arg1,arg2,(std::shared_ptr< CNTK::ProgressWriter > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::ProgressWriter > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::shared_ptr< CNTK::ProgressWriter > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::shared_ptr< CNTK::ProgressWriter > *arg1 = 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::ProgressWriter > tempnull1 ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *result = 0 ;
  
  arg1 = jarg1 ? (std::shared_ptr< CNTK::ProgressWriter > *)jarg1 : &tempnull1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__Repeat((std::shared_ptr< CNTK::ProgressWriter > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriterVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::ProgressWriter > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_ProgressWriter_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::shared_ptr< CNTK::ProgressWriter > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_ProgressWriterVector(void * jarg1) {
  std::vector< std::shared_ptr< CNTK::ProgressWriter > > *arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::ProgressWriter > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_LearnerVector_Clear(void * jarg1) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_LearnerVector_Add(void * jarg1, void * jarg2) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  std::shared_ptr< CNTK::Learner > *arg2 = 0 ;
  std::shared_ptr< CNTK::Learner > tempnull2 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = jarg2 ? (std::shared_ptr< CNTK::Learner > *)jarg2 : &tempnull2; 
  (arg1)->push_back((std::shared_ptr< CNTK::Learner > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_LearnerVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::Learner > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  result = ((std::vector< std::shared_ptr< CNTK::Learner > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_LearnerVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::Learner > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  result = ((std::vector< std::shared_ptr< CNTK::Learner > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_LearnerVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::Learner > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = (std::vector< std::shared_ptr< CNTK::Learner > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_LearnerVector__SWIG_0() {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::Learner > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< CNTK::Learner > > *)new std::vector< std::shared_ptr< CNTK::Learner > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_LearnerVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = 0 ;
  std::vector< std::shared_ptr< CNTK::Learner > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::Learner > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::shared_ptr< CNTK::Learner > > *)new std::vector< std::shared_ptr< CNTK::Learner > >((std::vector< std::shared_ptr< CNTK::Learner > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_LearnerVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::shared_ptr< CNTK::Learner > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::shared_ptr< CNTK::Learner > > *)new_std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LearnerVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::Learner > result;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result ? new std::shared_ptr< CNTK::Learner >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LearnerVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::Learner > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::shared_ptr< CNTK::Learner > *) &std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result ? new std::shared_ptr< CNTK::Learner >(*result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_LearnerVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::Learner > *arg3 = 0 ;
  std::shared_ptr< CNTK::Learner > tempnull3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = jarg3 ? (std::shared_ptr< CNTK::Learner > *)jarg3 : &tempnull3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__setitem(arg1,arg2,(std::shared_ptr< CNTK::Learner > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_LearnerVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  std::vector< std::shared_ptr< CNTK::Learner > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::Learner > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__AddRange(arg1,(std::vector< std::shared_ptr< CNTK::Learner > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LearnerVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::shared_ptr< CNTK::Learner > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::shared_ptr< CNTK::Learner > > *)std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_LearnerVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::Learner > *arg3 = 0 ;
  std::shared_ptr< CNTK::Learner > tempnull3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = jarg3 ? (std::shared_ptr< CNTK::Learner > *)jarg3 : &tempnull3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__Insert(arg1,arg2,(std::shared_ptr< CNTK::Learner > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_LearnerVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< CNTK::Learner > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::Learner > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::shared_ptr< CNTK::Learner > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_LearnerVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_LearnerVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LearnerVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::shared_ptr< CNTK::Learner > *arg1 = 0 ;
  int arg2 ;
  std::shared_ptr< CNTK::Learner > tempnull1 ;
  std::vector< std::shared_ptr< CNTK::Learner > > *result = 0 ;
  
  arg1 = jarg1 ? (std::shared_ptr< CNTK::Learner > *)jarg1 : &tempnull1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::shared_ptr< CNTK::Learner > > *)std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__Repeat((std::shared_ptr< CNTK::Learner > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_LearnerVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_LearnerVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_LearnerVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< CNTK::Learner > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::shared_ptr< CNTK::Learner > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_shared_ptr_Sl_CNTK_Learner_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::shared_ptr< CNTK::Learner > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_LearnerVector(void * jarg1) {
  std::vector< std::shared_ptr< CNTK::Learner > > *arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< CNTK::Learner > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_VariablePair__SWIG_0() {
  void * jresult ;
  std::pair< CNTK::Variable,CNTK::Variable > *result = 0 ;
  
  result = (std::pair< CNTK::Variable,CNTK::Variable > *)new std::pair< CNTK::Variable,CNTK::Variable >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_VariablePair__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable arg1 ;
  CNTK::Variable arg2 ;
  CNTK::Variable *argp1 ;
  CNTK::Variable *argp2 ;
  std::pair< CNTK::Variable,CNTK::Variable > *result = 0 ;
  
  argp1 = (CNTK::Variable *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null CNTK::Variable", 0);
    return 0;
  }
  arg1 = *argp1; 
  argp2 = (CNTK::Variable *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null CNTK::Variable", 0);
    return 0;
  }
  arg2 = *argp2; 
  result = (std::pair< CNTK::Variable,CNTK::Variable > *)new std::pair< CNTK::Variable,CNTK::Variable >(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_VariablePair__SWIG_2(void * jarg1) {
  void * jresult ;
  std::pair< CNTK::Variable,CNTK::Variable > *arg1 = 0 ;
  std::pair< CNTK::Variable,CNTK::Variable > *result = 0 ;
  
  arg1 = (std::pair< CNTK::Variable,CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< CNTK::Variable,CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  result = (std::pair< CNTK::Variable,CNTK::Variable > *)new std::pair< CNTK::Variable,CNTK::Variable >((std::pair< CNTK::Variable,CNTK::Variable > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePair_first_set(void * jarg1, void * jarg2) {
  std::pair< CNTK::Variable,CNTK::Variable > *arg1 = (std::pair< CNTK::Variable,CNTK::Variable > *) 0 ;
  CNTK::Variable *arg2 = (CNTK::Variable *) 0 ;
  
  arg1 = (std::pair< CNTK::Variable,CNTK::Variable > *)jarg1; 
  arg2 = (CNTK::Variable *)jarg2; 
  if (arg1) (arg1)->first = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VariablePair_first_get(void * jarg1) {
  void * jresult ;
  std::pair< CNTK::Variable,CNTK::Variable > *arg1 = (std::pair< CNTK::Variable,CNTK::Variable > *) 0 ;
  CNTK::Variable *result = 0 ;
  
  arg1 = (std::pair< CNTK::Variable,CNTK::Variable > *)jarg1; 
  result = (CNTK::Variable *)& ((arg1)->first);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePair_second_set(void * jarg1, void * jarg2) {
  std::pair< CNTK::Variable,CNTK::Variable > *arg1 = (std::pair< CNTK::Variable,CNTK::Variable > *) 0 ;
  CNTK::Variable *arg2 = (CNTK::Variable *) 0 ;
  
  arg1 = (std::pair< CNTK::Variable,CNTK::Variable > *)jarg1; 
  arg2 = (CNTK::Variable *)jarg2; 
  if (arg1) (arg1)->second = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VariablePair_second_get(void * jarg1) {
  void * jresult ;
  std::pair< CNTK::Variable,CNTK::Variable > *arg1 = (std::pair< CNTK::Variable,CNTK::Variable > *) 0 ;
  CNTK::Variable *result = 0 ;
  
  arg1 = (std::pair< CNTK::Variable,CNTK::Variable > *)jarg1; 
  result = (CNTK::Variable *)& ((arg1)->second);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_VariablePair(void * jarg1) {
  std::pair< CNTK::Variable,CNTK::Variable > *arg1 = (std::pair< CNTK::Variable,CNTK::Variable > *) 0 ;
  
  arg1 = (std::pair< CNTK::Variable,CNTK::Variable > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePairVector_Clear(void * jarg1) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePairVector_Add(void * jarg1, void * jarg2) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  std::pair< CNTK::Variable,CNTK::Variable > *arg2 = 0 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (std::pair< CNTK::Variable,CNTK::Variable > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< CNTK::Variable,CNTK::Variable > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((std::pair< CNTK::Variable,CNTK::Variable > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_VariablePairVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > >::size_type result;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  result = ((std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_VariablePairVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > >::size_type result;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  result = ((std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePairVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > >::size_type arg2 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_VariablePairVector__SWIG_0() {
  void * jresult ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *result = 0 ;
  
  result = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)new std::vector< std::pair< CNTK::Variable,CNTK::Variable > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_VariablePairVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = 0 ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *result = 0 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)new std::vector< std::pair< CNTK::Variable,CNTK::Variable > >((std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_VariablePairVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)new_std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VariablePairVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  int arg2 ;
  std::pair< CNTK::Variable,CNTK::Variable > result;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::pair< CNTK::Variable,CNTK::Variable >((const std::pair< CNTK::Variable,CNTK::Variable > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VariablePairVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  int arg2 ;
  std::pair< CNTK::Variable,CNTK::Variable > *result = 0 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::pair< CNTK::Variable,CNTK::Variable > *) &std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePairVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  int arg2 ;
  std::pair< CNTK::Variable,CNTK::Variable > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::pair< CNTK::Variable,CNTK::Variable > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< CNTK::Variable,CNTK::Variable > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__setitem(arg1,arg2,(std::pair< CNTK::Variable,CNTK::Variable > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePairVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__AddRange(arg1,(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VariablePairVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *result = 0 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePairVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  int arg2 ;
  std::pair< CNTK::Variable,CNTK::Variable > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::pair< CNTK::Variable,CNTK::Variable > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< CNTK::Variable,CNTK::Variable > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__Insert(arg1,arg2,(std::pair< CNTK::Variable,CNTK::Variable > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePairVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  int arg2 ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePairVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePairVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VariablePairVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::pair< CNTK::Variable,CNTK::Variable > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *result = 0 ;
  
  arg1 = (std::pair< CNTK::Variable,CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< CNTK::Variable,CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__Repeat((std::pair< CNTK::Variable,CNTK::Variable > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePairVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePairVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VariablePairVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  int arg2 ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_CNTK_Variable_Sc_CNTK_Variable_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::pair< CNTK::Variable,CNTK::Variable > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_VariablePairVector(void * jarg1) {
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *) 0 ;
  
  arg1 = (std::vector< std::pair< CNTK::Variable,CNTK::Variable > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapStringDictionaryValue__SWIG_0() {
  void * jresult ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *result = 0 ;
  
  result = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)new std::unordered_map< std::wstring,CNTK::DictionaryValue >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_UnorderedMapStringDictionaryValue__SWIG_1(void * jarg1) {
  void * jresult ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *result = 0 ;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< std::wstring,CNTK::DictionaryValue > const & type is null", 0);
    return 0;
  } 
  result = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)new std::unordered_map< std::wstring,CNTK::DictionaryValue >((std::unordered_map< std::wstring,CNTK::DictionaryValue > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_UnorderedMapStringDictionaryValue_size(void * jarg1) {
  unsigned long jresult ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *) 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::size_type result;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1; 
  result = ((std::unordered_map< std::wstring,CNTK::DictionaryValue > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapStringDictionaryValue_empty(void * jarg1) {
  unsigned int jresult ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *) 0 ;
  bool result;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1; 
  result = (bool)((std::unordered_map< std::wstring,CNTK::DictionaryValue > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapStringDictionaryValue_Clear(void * jarg1) {
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *) 0 ;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapStringDictionaryValue_getitem(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *) 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type *arg2 = 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::mapped_type *result = 0 ;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  try {
    result = (std::unordered_map< std::wstring,CNTK::DictionaryValue >::mapped_type *) &std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__getitem(arg1,(std::wstring const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapStringDictionaryValue_setitem(void * jarg1, wchar_t * jarg2, void * jarg3) {
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *) 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type *arg2 = 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::mapped_type *arg3 = 0 ;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (std::unordered_map< std::wstring,CNTK::DictionaryValue >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< std::wstring,CNTK::DictionaryValue >::mapped_type const & type is null", 0);
    return ;
  } 
  std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__setitem(arg1,(std::wstring const &)*arg2,(CNTK::DictionaryValue const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapStringDictionaryValue_ContainsKey(void * jarg1, wchar_t * jarg2) {
  unsigned int jresult ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *) 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__ContainsKey(arg1,(std::wstring const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapStringDictionaryValue_Add(void * jarg1, wchar_t * jarg2, void * jarg3) {
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *) 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type *arg2 = 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::mapped_type *arg3 = 0 ;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (std::unordered_map< std::wstring,CNTK::DictionaryValue >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< std::wstring,CNTK::DictionaryValue >::mapped_type const & type is null", 0);
    return ;
  } 
  try {
    std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__Add(arg1,(std::wstring const &)*arg2,(CNTK::DictionaryValue const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_UnorderedMapStringDictionaryValue_Remove(void * jarg1, wchar_t * jarg2) {
  unsigned int jresult ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *) 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type *arg2 = 0 ;
  bool result;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__Remove(arg1,(std::wstring const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapStringDictionaryValue_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *) 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::iterator *result = 0 ;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1; 
  result = (std::unordered_map< std::wstring,CNTK::DictionaryValue >::iterator *)std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnorderedMapStringDictionaryValue_get_next_key(void * jarg1, void * jarg2) {
  void * jresult ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *) 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::iterator *arg2 = (std::unordered_map< std::wstring,CNTK::DictionaryValue >::iterator *) 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type *result = 0 ;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1; 
  arg2 = (std::unordered_map< std::wstring,CNTK::DictionaryValue >::iterator *)jarg2; 
  result = (std::unordered_map< std::wstring,CNTK::DictionaryValue >::key_type *) &std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__get_next_key(arg1,arg2);
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UnorderedMapStringDictionaryValue_destroy_iterator(void * jarg1, void * jarg2) {
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *) 0 ;
  std::unordered_map< std::wstring,CNTK::DictionaryValue >::iterator *arg2 = (std::unordered_map< std::wstring,CNTK::DictionaryValue >::iterator *) 0 ;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1; 
  arg2 = (std::unordered_map< std::wstring,CNTK::DictionaryValue >::iterator *)jarg2; 
  std_unordered_map_Sl_std_wstring_Sc_CNTK_DictionaryValue_Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_UnorderedMapStringDictionaryValue(void * jarg1) {
  std::unordered_map< std::wstring,CNTK::DictionaryValue > *arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *) 0 ;
  
  arg1 = (std::unordered_map< std::wstring,CNTK::DictionaryValue > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairSizeTDouble__SWIG_0() {
  void * jresult ;
  std::pair< size_t,double > *result = 0 ;
  
  result = (std::pair< size_t,double > *)new std::pair< size_t,double >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairSizeTDouble__SWIG_1(unsigned long jarg1, double jarg2) {
  void * jresult ;
  size_t arg1 ;
  double arg2 ;
  std::pair< size_t,double > *result = 0 ;
  
  arg1 = (size_t)jarg1; 
  arg2 = (double)jarg2; 
  result = (std::pair< size_t,double > *)new std::pair< size_t,double >(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairSizeTDouble__SWIG_2(void * jarg1) {
  void * jresult ;
  std::pair< size_t,double > *arg1 = 0 ;
  std::pair< size_t,double > *result = 0 ;
  
  arg1 = (std::pair< size_t,double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,double > const & type is null", 0);
    return 0;
  } 
  result = (std::pair< size_t,double > *)new std::pair< size_t,double >((std::pair< size_t,double > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairSizeTDouble_first_set(void * jarg1, unsigned long jarg2) {
  std::pair< size_t,double > *arg1 = (std::pair< size_t,double > *) 0 ;
  size_t arg2 ;
  
  arg1 = (std::pair< size_t,double > *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->first = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_PairSizeTDouble_first_get(void * jarg1) {
  unsigned long jresult ;
  std::pair< size_t,double > *arg1 = (std::pair< size_t,double > *) 0 ;
  size_t result;
  
  arg1 = (std::pair< size_t,double > *)jarg1; 
  result =  ((arg1)->first);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairSizeTDouble_second_set(void * jarg1, double jarg2) {
  std::pair< size_t,double > *arg1 = (std::pair< size_t,double > *) 0 ;
  double arg2 ;
  
  arg1 = (std::pair< size_t,double > *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->second = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_PairSizeTDouble_second_get(void * jarg1) {
  double jresult ;
  std::pair< size_t,double > *arg1 = (std::pair< size_t,double > *) 0 ;
  double result;
  
  arg1 = (std::pair< size_t,double > *)jarg1; 
  result = (double) ((arg1)->second);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_PairSizeTDouble(void * jarg1) {
  std::pair< size_t,double > *arg1 = (std::pair< size_t,double > *) 0 ;
  
  arg1 = (std::pair< size_t,double > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_Clear(void * jarg1) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_Add(void * jarg1, void * jarg2) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  std::pair< size_t,double > *arg2 = 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (std::pair< size_t,double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,double > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((std::pair< size_t,double > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  std::vector< std::pair< size_t,double > >::size_type result;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  result = ((std::vector< std::pair< size_t,double > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  std::vector< std::pair< size_t,double > >::size_type result;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  result = ((std::vector< std::pair< size_t,double > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  std::vector< std::pair< size_t,double > >::size_type arg2 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (std::vector< std::pair< size_t,double > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_VectorPairSizeTDouble__SWIG_0() {
  void * jresult ;
  std::vector< std::pair< size_t,double > > *result = 0 ;
  
  result = (std::vector< std::pair< size_t,double > > *)new std::vector< std::pair< size_t,double > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_VectorPairSizeTDouble__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::pair< size_t,double > > *arg1 = 0 ;
  std::vector< std::pair< size_t,double > > *result = 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< size_t,double > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::pair< size_t,double > > *)new std::vector< std::pair< size_t,double > >((std::vector< std::pair< size_t,double > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_VectorPairSizeTDouble__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::pair< size_t,double > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::pair< size_t,double > > *)new_std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  int arg2 ;
  std::pair< size_t,double > result;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::pair< size_t,double >((const std::pair< size_t,double > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  int arg2 ;
  std::pair< size_t,double > *result = 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::pair< size_t,double > *) &std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  int arg2 ;
  std::pair< size_t,double > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::pair< size_t,double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__setitem(arg1,arg2,(std::pair< size_t,double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  std::vector< std::pair< size_t,double > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (std::vector< std::pair< size_t,double > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< size_t,double > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__AddRange(arg1,(std::vector< std::pair< size_t,double > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::pair< size_t,double > > *result = 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::pair< size_t,double > > *)std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  int arg2 ;
  std::pair< size_t,double > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::pair< size_t,double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__Insert(arg1,arg2,(std::pair< size_t,double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  int arg2 ;
  std::vector< std::pair< size_t,double > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::pair< size_t,double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< size_t,double > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::pair< size_t,double > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::pair< size_t,double > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::pair< size_t,double > > *result = 0 ;
  
  arg1 = (std::pair< size_t,double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,double > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::pair< size_t,double > > *)std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__Repeat((std::pair< size_t,double > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_VectorPairSizeTDouble_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  int arg2 ;
  std::vector< std::pair< size_t,double > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::pair< size_t,double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< size_t,double > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_size_t_Sc_double_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::pair< size_t,double > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_VectorPairSizeTDouble(void * jarg1) {
  std::vector< std::pair< size_t,double > > *arg1 = (std::vector< std::pair< size_t,double > > *) 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairSizeTSizeT__SWIG_0() {
  void * jresult ;
  std::pair< size_t,size_t > *result = 0 ;
  
  result = (std::pair< size_t,size_t > *)new std::pair< size_t,size_t >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairSizeTSizeT__SWIG_1(unsigned long jarg1, unsigned long jarg2) {
  void * jresult ;
  size_t arg1 ;
  size_t arg2 ;
  std::pair< size_t,size_t > *result = 0 ;
  
  arg1 = (size_t)jarg1; 
  arg2 = (size_t)jarg2; 
  result = (std::pair< size_t,size_t > *)new std::pair< size_t,size_t >(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairSizeTSizeT__SWIG_2(void * jarg1) {
  void * jresult ;
  std::pair< size_t,size_t > *arg1 = 0 ;
  std::pair< size_t,size_t > *result = 0 ;
  
  arg1 = (std::pair< size_t,size_t > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,size_t > const & type is null", 0);
    return 0;
  } 
  result = (std::pair< size_t,size_t > *)new std::pair< size_t,size_t >((std::pair< size_t,size_t > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairSizeTSizeT_first_set(void * jarg1, unsigned long jarg2) {
  std::pair< size_t,size_t > *arg1 = (std::pair< size_t,size_t > *) 0 ;
  size_t arg2 ;
  
  arg1 = (std::pair< size_t,size_t > *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->first = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_PairSizeTSizeT_first_get(void * jarg1) {
  unsigned long jresult ;
  std::pair< size_t,size_t > *arg1 = (std::pair< size_t,size_t > *) 0 ;
  size_t result;
  
  arg1 = (std::pair< size_t,size_t > *)jarg1; 
  result =  ((arg1)->first);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairSizeTSizeT_second_set(void * jarg1, unsigned long jarg2) {
  std::pair< size_t,size_t > *arg1 = (std::pair< size_t,size_t > *) 0 ;
  size_t arg2 ;
  
  arg1 = (std::pair< size_t,size_t > *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->second = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_PairSizeTSizeT_second_get(void * jarg1) {
  unsigned long jresult ;
  std::pair< size_t,size_t > *arg1 = (std::pair< size_t,size_t > *) 0 ;
  size_t result;
  
  arg1 = (std::pair< size_t,size_t > *)jarg1; 
  result =  ((arg1)->second);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_PairSizeTSizeT(void * jarg1) {
  std::pair< size_t,size_t > *arg1 = (std::pair< size_t,size_t > *) 0 ;
  
  arg1 = (std::pair< size_t,size_t > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairSizeTInt__SWIG_0() {
  void * jresult ;
  std::pair< size_t,int > *result = 0 ;
  
  result = (std::pair< size_t,int > *)new std::pair< size_t,int >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairSizeTInt__SWIG_1(unsigned long jarg1, int jarg2) {
  void * jresult ;
  size_t arg1 ;
  int arg2 ;
  std::pair< size_t,int > *result = 0 ;
  
  arg1 = (size_t)jarg1; 
  arg2 = (int)jarg2; 
  result = (std::pair< size_t,int > *)new std::pair< size_t,int >(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairSizeTInt__SWIG_2(void * jarg1) {
  void * jresult ;
  std::pair< size_t,int > *arg1 = 0 ;
  std::pair< size_t,int > *result = 0 ;
  
  arg1 = (std::pair< size_t,int > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,int > const & type is null", 0);
    return 0;
  } 
  result = (std::pair< size_t,int > *)new std::pair< size_t,int >((std::pair< size_t,int > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairSizeTInt_first_set(void * jarg1, unsigned long jarg2) {
  std::pair< size_t,int > *arg1 = (std::pair< size_t,int > *) 0 ;
  size_t arg2 ;
  
  arg1 = (std::pair< size_t,int > *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->first = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_PairSizeTInt_first_get(void * jarg1) {
  unsigned long jresult ;
  std::pair< size_t,int > *arg1 = (std::pair< size_t,int > *) 0 ;
  size_t result;
  
  arg1 = (std::pair< size_t,int > *)jarg1; 
  result =  ((arg1)->first);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairSizeTInt_second_set(void * jarg1, int jarg2) {
  std::pair< size_t,int > *arg1 = (std::pair< size_t,int > *) 0 ;
  int arg2 ;
  
  arg1 = (std::pair< size_t,int > *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->second = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_PairSizeTInt_second_get(void * jarg1) {
  int jresult ;
  std::pair< size_t,int > *arg1 = (std::pair< size_t,int > *) 0 ;
  int result;
  
  arg1 = (std::pair< size_t,int > *)jarg1; 
  result = (int) ((arg1)->second);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_PairSizeTInt(void * jarg1) {
  std::pair< size_t,int > *arg1 = (std::pair< size_t,int > *) 0 ;
  
  arg1 = (std::pair< size_t,int > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairIntInt__SWIG_0() {
  void * jresult ;
  std::pair< int,int > *result = 0 ;
  
  result = (std::pair< int,int > *)new std::pair< int,int >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairIntInt__SWIG_1(int jarg1, int jarg2) {
  void * jresult ;
  int arg1 ;
  int arg2 ;
  std::pair< int,int > *result = 0 ;
  
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  result = (std::pair< int,int > *)new std::pair< int,int >(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairIntInt__SWIG_2(void * jarg1) {
  void * jresult ;
  std::pair< int,int > *arg1 = 0 ;
  std::pair< int,int > *result = 0 ;
  
  arg1 = (std::pair< int,int > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< int,int > const & type is null", 0);
    return 0;
  } 
  result = (std::pair< int,int > *)new std::pair< int,int >((std::pair< int,int > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairIntInt_first_set(void * jarg1, int jarg2) {
  std::pair< int,int > *arg1 = (std::pair< int,int > *) 0 ;
  int arg2 ;
  
  arg1 = (std::pair< int,int > *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->first = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_PairIntInt_first_get(void * jarg1) {
  int jresult ;
  std::pair< int,int > *arg1 = (std::pair< int,int > *) 0 ;
  int result;
  
  arg1 = (std::pair< int,int > *)jarg1; 
  result = (int) ((arg1)->first);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairIntInt_second_set(void * jarg1, int jarg2) {
  std::pair< int,int > *arg1 = (std::pair< int,int > *) 0 ;
  int arg2 ;
  
  arg1 = (std::pair< int,int > *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->second = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_PairIntInt_second_get(void * jarg1) {
  int jresult ;
  std::pair< int,int > *arg1 = (std::pair< int,int > *) 0 ;
  int result;
  
  arg1 = (std::pair< int,int > *)jarg1; 
  result = (int) ((arg1)->second);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_PairIntInt(void * jarg1) {
  std::pair< int,int > *arg1 = (std::pair< int,int > *) 0 ;
  
  arg1 = (std::pair< int,int > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairFloatFloat__SWIG_0() {
  void * jresult ;
  std::pair< float,float > *result = 0 ;
  
  result = (std::pair< float,float > *)new std::pair< float,float >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairFloatFloat__SWIG_1(float jarg1, float jarg2) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  std::pair< float,float > *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  result = (std::pair< float,float > *)new std::pair< float,float >(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairFloatFloat__SWIG_2(void * jarg1) {
  void * jresult ;
  std::pair< float,float > *arg1 = 0 ;
  std::pair< float,float > *result = 0 ;
  
  arg1 = (std::pair< float,float > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< float,float > const & type is null", 0);
    return 0;
  } 
  result = (std::pair< float,float > *)new std::pair< float,float >((std::pair< float,float > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairFloatFloat_first_set(void * jarg1, float jarg2) {
  std::pair< float,float > *arg1 = (std::pair< float,float > *) 0 ;
  float arg2 ;
  
  arg1 = (std::pair< float,float > *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->first = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CNTK_PairFloatFloat_first_get(void * jarg1) {
  float jresult ;
  std::pair< float,float > *arg1 = (std::pair< float,float > *) 0 ;
  float result;
  
  arg1 = (std::pair< float,float > *)jarg1; 
  result = (float) ((arg1)->first);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairFloatFloat_second_set(void * jarg1, float jarg2) {
  std::pair< float,float > *arg1 = (std::pair< float,float > *) 0 ;
  float arg2 ;
  
  arg1 = (std::pair< float,float > *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->second = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CNTK_PairFloatFloat_second_get(void * jarg1) {
  float jresult ;
  std::pair< float,float > *arg1 = (std::pair< float,float > *) 0 ;
  float result;
  
  arg1 = (std::pair< float,float > *)jarg1; 
  result = (float) ((arg1)->second);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_PairFloatFloat(void * jarg1) {
  std::pair< float,float > *arg1 = (std::pair< float,float > *) 0 ;
  
  arg1 = (std::pair< float,float > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairDoubleDouble__SWIG_0() {
  void * jresult ;
  std::pair< double,double > *result = 0 ;
  
  result = (std::pair< double,double > *)new std::pair< double,double >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairDoubleDouble__SWIG_1(double jarg1, double jarg2) {
  void * jresult ;
  double arg1 ;
  double arg2 ;
  std::pair< double,double > *result = 0 ;
  
  arg1 = (double)jarg1; 
  arg2 = (double)jarg2; 
  result = (std::pair< double,double > *)new std::pair< double,double >(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_PairDoubleDouble__SWIG_2(void * jarg1) {
  void * jresult ;
  std::pair< double,double > *arg1 = 0 ;
  std::pair< double,double > *result = 0 ;
  
  arg1 = (std::pair< double,double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< double,double > const & type is null", 0);
    return 0;
  } 
  result = (std::pair< double,double > *)new std::pair< double,double >((std::pair< double,double > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairDoubleDouble_first_set(void * jarg1, double jarg2) {
  std::pair< double,double > *arg1 = (std::pair< double,double > *) 0 ;
  double arg2 ;
  
  arg1 = (std::pair< double,double > *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->first = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_PairDoubleDouble_first_get(void * jarg1) {
  double jresult ;
  std::pair< double,double > *arg1 = (std::pair< double,double > *) 0 ;
  double result;
  
  arg1 = (std::pair< double,double > *)jarg1; 
  result = (double) ((arg1)->first);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_PairDoubleDouble_second_set(void * jarg1, double jarg2) {
  std::pair< double,double > *arg1 = (std::pair< double,double > *) 0 ;
  double arg2 ;
  
  arg1 = (std::pair< double,double > *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->second = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_PairDoubleDouble_second_get(void * jarg1) {
  double jresult ;
  std::pair< double,double > *arg1 = (std::pair< double,double > *) 0 ;
  double result;
  
  arg1 = (std::pair< double,double > *)jarg1; 
  result = (double) ((arg1)->second);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_PairDoubleDouble(void * jarg1) {
  std::pair< double,double > *arg1 = (std::pair< double,double > *) 0 ;
  
  arg1 = (std::pair< double,double > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionSequenceShape__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned int jarg7, void * jarg8, unsigned long jarg9, unsigned long jarg10, wchar_t * jarg11) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  bool arg7 ;
  CNTK::NDShape *arg8 = 0 ;
  size_t arg9 ;
  size_t arg10 ;
  std::wstring *arg11 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  
  arg8 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg8) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg8)->get() : 0);
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg9 = (size_t)jarg9; 
  arg10 = (size_t)jarg10; 
  if (!jarg11) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg11_str(jarg11);
  arg11 = &arg11_str; 
  {
    try {
      result = CNTK::Internal::ConvolutionSequenceShape((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,arg7,(CNTK::NDShape const &)*arg8,arg9,arg10,(std::wstring const &)*arg11); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionSequenceShape__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned int jarg7, void * jarg8, unsigned long jarg9, unsigned long jarg10) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  bool arg7 ;
  CNTK::NDShape *arg8 = 0 ;
  size_t arg9 ;
  size_t arg10 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  
  arg8 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg8) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg8)->get() : 0);
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg9 = (size_t)jarg9; 
  arg10 = (size_t)jarg10; 
  {
    try {
      result = CNTK::Internal::ConvolutionSequenceShape((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,arg7,(CNTK::NDShape const &)*arg8,arg9,arg10); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SpatialConvolution__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned long jarg7, wchar_t * jarg8) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  size_t arg7 ;
  std::wstring *arg8 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg7 = (size_t)jarg7; 
  if (!jarg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg8_str(jarg8);
  arg8 = &arg8_str; 
  {
    try {
      result = CNTK::Internal::SpatialConvolution((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,arg7,(std::wstring const &)*arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SpatialConvolution__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned long jarg7) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  size_t arg7 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg7 = (size_t)jarg7; 
  {
    try {
      result = CNTK::Internal::SpatialConvolution((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SpatialConvolutionSequenceShape__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned long jarg7, wchar_t * jarg8) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  size_t arg7 ;
  std::wstring *arg8 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg7 = (size_t)jarg7; 
  if (!jarg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg8_str(jarg8);
  arg8 = &arg8_str; 
  {
    try {
      result = CNTK::Internal::SpatialConvolutionSequenceShape((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,arg7,(std::wstring const &)*arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SpatialConvolutionSequenceShape__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned long jarg7) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  size_t arg7 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg7 = (size_t)jarg7; 
  {
    try {
      result = CNTK::Internal::SpatialConvolutionSequenceShape((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MatMul__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Internal::MatMul((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MatMul__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Internal::MatMul((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Gemm__SWIG_0(void * jarg1, void * jarg2, void * jarg3, float jarg4, float jarg5, unsigned int jarg6, unsigned int jarg7, wchar_t * jarg8) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  float arg4 ;
  float arg5 ;
  bool arg6 ;
  bool arg7 ;
  std::wstring *arg8 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = jarg6 ? true : false; 
  arg7 = jarg7 ? true : false; 
  if (!jarg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg8_str(jarg8);
  arg8 = &arg8_str; 
  {
    try {
      result = CNTK::Internal::Gemm((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,arg4,arg5,arg6,arg7,(std::wstring const &)*arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Gemm__SWIG_1(void * jarg1, void * jarg2, void * jarg3, float jarg4, float jarg5, unsigned int jarg6, unsigned int jarg7) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  float arg4 ;
  float arg5 ;
  bool arg6 ;
  bool arg7 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = jarg6 ? true : false; 
  arg7 = jarg7 ? true : false; 
  {
    try {
      result = CNTK::Internal::Gemm((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,arg4,arg5,arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Gemm__SWIG_2(void * jarg1, void * jarg2, void * jarg3, float jarg4, float jarg5, unsigned int jarg6) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  float arg4 ;
  float arg5 ;
  bool arg6 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = jarg6 ? true : false; 
  {
    try {
      result = CNTK::Internal::Gemm((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,arg4,arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Gemm__SWIG_3(void * jarg1, void * jarg2, void * jarg3, float jarg4, float jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  float arg4 ;
  float arg5 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  {
    try {
      result = CNTK::Internal::Gemm((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Gemm__SWIG_4(void * jarg1, void * jarg2, void * jarg3, float jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  float arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (float)jarg4; 
  {
    try {
      result = CNTK::Internal::Gemm((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Gemm__SWIG_5(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Internal::Gemm((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Unsqueeze__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Internal::Unsqueeze((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Unsqueeze__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Internal::Unsqueeze((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_GenerateRandomSeed__SWIG_0(unsigned int jarg1) {
  unsigned long jresult ;
  bool arg1 ;
  size_t result;
  
  arg1 = jarg1 ? true : false; 
  {
    try {
      result = CNTK::Internal::GenerateRandomSeed(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_GenerateRandomSeed__SWIG_1() {
  unsigned long jresult ;
  size_t result;
  
  {
    try {
      result = CNTK::Internal::GenerateRandomSeed(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SetMathLibTraceLevel(int jarg1) {
  int arg1 ;
  
  arg1 = (int)jarg1; 
  {
    try {
      CNTK::Internal::SetMathLibTraceLevel(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ForceDeterministicAlgorithms() {
  {
    try {
      CNTK::Internal::ForceDeterministicAlgorithms(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_ShouldForceDeterministicAlgorithms() {
  unsigned int jresult ;
  bool result;
  
  {
    try {
      result = (bool)CNTK::Internal::ShouldForceDeterministicAlgorithms(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_UseSparseGradientAggregationInDataParallelSGD(unsigned int jarg1) {
  bool arg1 ;
  
  arg1 = jarg1 ? true : false; 
  {
    try {
      CNTK::Internal::UseSparseGradientAggregationInDataParallelSGD(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_ShouldUseSparseGradientAggregationInDataParallelSGD() {
  unsigned int jresult ;
  bool result;
  
  {
    try {
      result = (bool)CNTK::Internal::ShouldUseSparseGradientAggregationInDataParallelSGD(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_GetRandomSeed() {
  unsigned long jresult ;
  unsigned long result;
  
  {
    try {
      result = (unsigned long)CNTK::Internal::GetRandomSeed(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SetFixedRandomSeed(unsigned long jarg1) {
  unsigned long arg1 ;
  
  arg1 = (unsigned long)jarg1; 
  {
    try {
      CNTK::Internal::SetFixedRandomSeed(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_IsRandomSeedFixed() {
  unsigned int jresult ;
  bool result;
  
  {
    try {
      result = (bool)CNTK::Internal::IsRandomSeedFixed(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ResetRandomSeed__SWIG_0(unsigned long jarg1) {
  unsigned long arg1 ;
  
  arg1 = (unsigned long)jarg1; 
  {
    try {
      CNTK::Internal::ResetRandomSeed(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ResetRandomSeed__SWIG_1() {
  {
    try {
      CNTK::Internal::ResetRandomSeed(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DisableNodeTimeing() {
  {
    try {
      CNTK::Internal::DisableNodeTimeing(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_EnableCPUEvalOptimization() {
  {
    try {
      CNTK::Internal::EnableCPUEvalOptimization(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DisableCPUEvalOptimization() {
  {
    try {
      CNTK::Internal::DisableCPUEvalOptimization(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_float16__SWIG_0() {
  void * jresult ;
  CNTK::float16 *result = 0 ;
  
  {
    try {
      result = (CNTK::float16 *)new CNTK::float16(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_float16__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::float16 *arg1 = 0 ;
  CNTK::float16 *result = 0 ;
  
  arg1 = (CNTK::float16 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::float16 const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::float16 *)new CNTK::float16((CNTK::float16 const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_float16_create__SWIG_0(float jarg1) {
  void * jresult ;
  float arg1 ;
  CNTK::float16 result;
  
  arg1 = (float)jarg1; 
  {
    try {
      result = CNTK::float16::create(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::float16((const CNTK::float16 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_float16_create__SWIG_1(double jarg1) {
  void * jresult ;
  double arg1 ;
  CNTK::float16 result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = CNTK::float16::create(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::float16((const CNTK::float16 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_float16(void * jarg1) {
  CNTK::float16 *arg1 = (CNTK::float16 *) 0 ;
  
  arg1 = (CNTK::float16 *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CNTK_DataTypeName(int jarg1) {
  char * jresult ;
  CNTK::DataType arg1 ;
  char *result = 0 ;
  
  arg1 = (CNTK::DataType)jarg1; 
  {
    try {
      result = (char *)CNTK::DataTypeName(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_string_callback((const char *)result); 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_DataTypeSize(int jarg1) {
  unsigned long jresult ;
  CNTK::DataType arg1 ;
  size_t result;
  
  arg1 = (CNTK::DataType)jarg1; 
  {
    try {
      result = CNTK::DataTypeSize(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_IsSparseStorageFormat(int jarg1) {
  unsigned int jresult ;
  CNTK::StorageFormat arg1 ;
  bool result;
  
  arg1 = (CNTK::StorageFormat)jarg1; 
  {
    try {
      result = (bool)CNTK::IsSparseStorageFormat(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT wchar_t * SWIGSTDCALL CSharp_CNTK_DeviceKindName(int jarg1) {
  wchar_t * jresult ;
  CNTK::DeviceKind arg1 ;
  wchar_t *result = 0 ;
  
  arg1 = (CNTK::DeviceKind)jarg1; 
  {
    try {
      result = (wchar_t *)CNTK::DeviceKindName(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (wchar_t *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_AreEqual__SWIG_0(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::NDShape *arg2 = 0 ;
  bool result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg2 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg2) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)operator ==((CNTK::NDShape const &)*arg1,(CNTK::NDShape const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDShape_Unknown() {
  void * jresult ;
  CNTK::NDShape *result = 0 ;
  
  {
    try {
      result = (CNTK::NDShape *) &CNTK::NDShape::Unknown(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::shared_ptr< const CNTK::NDShape >(result SWIG_NO_NULL_DELETER_0); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDShape__SWIG_0() {
  void * jresult ;
  CNTK::NDShape *result = 0 ;
  
  {
    try {
      result = (CNTK::NDShape *)new CNTK::NDShape(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDShape >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDShape__SWIG_1(unsigned long jarg1, unsigned long jarg2) {
  void * jresult ;
  size_t arg1 ;
  size_t arg2 ;
  CNTK::NDShape *result = 0 ;
  
  arg1 = (size_t)jarg1; 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = (CNTK::NDShape *)new CNTK::NDShape(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDShape >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDShape__SWIG_2(unsigned long jarg1) {
  void * jresult ;
  size_t arg1 ;
  CNTK::NDShape *result = 0 ;
  
  arg1 = (size_t)jarg1; 
  {
    try {
      result = (CNTK::NDShape *)new CNTK::NDShape(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDShape >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDShape__SWIG_3(void * jarg1) {
  void * jresult ;
  std::vector< size_t > *arg1 = 0 ;
  CNTK::NDShape *result = 0 ;
  
  arg1 = (std::vector< size_t > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::NDShape *)new CNTK::NDShape((std::vector< size_t > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDShape >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDShape__Dimensions(void * jarg1) {
  void * jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  std::vector< size_t > *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (std::vector< size_t > *) &((CNTK::NDShape const *)arg1)->Dimensions(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_NDShape__IsUnknown(void * jarg1) {
  unsigned int jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::NDShape const *)arg1)->IsUnknown(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_NDShape_IsScalar(void * jarg1) {
  unsigned int jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::NDShape const *)arg1)->IsScalar(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_NDShape__Rank(void * jarg1) {
  unsigned long jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::NDShape const *)arg1)->Rank(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDShape__SubShape__SWIG_0(void * jarg1, unsigned long jarg2, unsigned long jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  CNTK::NDShape result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (size_t)jarg2; 
  arg3 = (size_t)jarg3; 
  {
    try {
      result = ((CNTK::NDShape const *)arg1)->SubShape(arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::shared_ptr<  CNTK::NDShape >(new CNTK::NDShape((CNTK::NDShape &)result)); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDShape__SubShape__SWIG_1(void * jarg1, unsigned long jarg2) {
  void * jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  size_t arg2 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  CNTK::NDShape result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = ((CNTK::NDShape const *)arg1)->SubShape(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::shared_ptr<  CNTK::NDShape >(new CNTK::NDShape((CNTK::NDShape &)result)); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDShape__SubShape__SWIG_2(void * jarg1) {
  void * jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  CNTK::NDShape result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::NDShape const *)arg1)->SubShape(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::shared_ptr<  CNTK::NDShape >(new CNTK::NDShape((CNTK::NDShape &)result)); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_NDShape__HasInferredDimension(void * jarg1) {
  unsigned int jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::NDShape const *)arg1)->HasInferredDimension(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_NDShape__HasFreeDimension(void * jarg1) {
  unsigned int jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::NDShape const *)arg1)->HasFreeDimension(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_NDShape__HasUnboundDimension(void * jarg1) {
  unsigned int jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::NDShape const *)arg1)->HasUnboundDimension(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_NDShape__TotalSize(void * jarg1) {
  unsigned long jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::NDShape const *)arg1)->TotalSize(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDShape_AppendShape(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  CNTK::NDShape *arg2 = 0 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  CNTK::NDShape result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  
  arg2 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg2) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = ((CNTK::NDShape const *)arg1)->AppendShape((CNTK::NDShape const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::shared_ptr<  CNTK::NDShape >(new CNTK::NDShape((CNTK::NDShape &)result)); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDShape_AsString(void * jarg1) {
  void * jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  std::shared_ptr< CNTK::NDShape const > *smartarg1 = 0 ;
  std::wstring result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::NDShape const *)arg1)->AsString(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_NDShape__DimensionSize(void * jarg1, unsigned long jarg2) {
  unsigned long jresult ;
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  size_t arg2 ;
  std::shared_ptr< CNTK::NDShape > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = CNTK_NDShape_DimensionSize(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDShape_CSharp_SizeTVector_AddExt(void * jarg1, unsigned long long jarg2) {
  std::vector< size_t > *arg1 = (std::vector< size_t > *) 0 ;
  unsigned long long arg2 ;
  
  arg1 = (std::vector< size_t > *)jarg1; 
  arg2 = (unsigned long long)jarg2; 
  {
    try {
      CNTK_NDShape_CSharp_SizeTVector_AddExt(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_NDShape(void * jarg1) {
  CNTK::NDShape *arg1 = (CNTK::NDShape *) 0 ;
  std::shared_ptr< CNTK::NDShape > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDShape > *)jarg1;
  arg1 = (CNTK::NDShape *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (void)arg1; delete smartarg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_AreNotEqual__SWIG_0(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::NDShape *arg2 = 0 ;
  bool result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg2 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg2) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)CNTK::operator !=((CNTK::NDShape const &)*arg1,(CNTK::NDShape const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_StreamInformation() {
  void * jresult ;
  CNTK::StreamInformation *result = 0 ;
  
  {
    try {
      result = (CNTK::StreamInformation *)new CNTK::StreamInformation(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamInformation_m_name_set(void * jarg1, wchar_t * jarg2) {
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  std::wstring *arg2 = 0 ;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->m_name = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StreamInformation_m_name_get(void * jarg1) {
  void * jresult ;
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  std::wstring *result = 0 ;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  result = (std::wstring *) & ((arg1)->m_name);
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamInformation_m_id_set(void * jarg1, unsigned long jarg2) {
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->m_id = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_StreamInformation_m_id_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  size_t result;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  result =  ((arg1)->m_id);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamInformation_m_storageFormat_set(void * jarg1, int jarg2) {
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  CNTK::StorageFormat arg2 ;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  arg2 = (CNTK::StorageFormat)jarg2; 
  if (arg1) (arg1)->m_storageFormat = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_StreamInformation_m_storageFormat_get(void * jarg1) {
  int jresult ;
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  CNTK::StorageFormat result;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  result = (CNTK::StorageFormat) ((arg1)->m_storageFormat);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamInformation_m_elementType_set(void * jarg1, int jarg2) {
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  CNTK::DataType arg2 ;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  arg2 = (CNTK::DataType)jarg2; 
  if (arg1) (arg1)->m_elementType = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_StreamInformation_m_elementType_get(void * jarg1) {
  int jresult ;
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  CNTK::DataType result;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  result = (CNTK::DataType) ((arg1)->m_elementType);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamInformation_m_sampleLayout_set(void * jarg1, void * jarg2) {
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  CNTK::NDShape *arg2 = 0 ;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  
  arg2 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg2) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return ;
  } 
  if (arg1) (arg1)->m_sampleLayout = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StreamInformation_m_sampleLayout_get(void * jarg1) {
  void * jresult ;
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  CNTK::NDShape *result = 0 ;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  result = (CNTK::NDShape *) & ((arg1)->m_sampleLayout);
  jresult = new std::shared_ptr< const CNTK::NDShape >(result SWIG_NO_NULL_DELETER_0); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamInformation_m_definesMbSize_set(void * jarg1, unsigned int jarg2) {
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  bool arg2 ;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->m_definesMbSize = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_StreamInformation_m_definesMbSize_get(void * jarg1) {
  unsigned int jresult ;
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  bool result;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  result = (bool) ((arg1)->m_definesMbSize);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamInformation_m_isBinary_set(void * jarg1, unsigned int jarg2) {
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  bool arg2 ;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->m_isBinary = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_StreamInformation_m_isBinary_get(void * jarg1) {
  unsigned int jresult ;
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  bool result;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  result = (bool) ((arg1)->m_isBinary);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StreamInformation_AsString(void * jarg1) {
  void * jresult ;
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  std::wstring result;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  {
    try {
      result = ((CNTK::StreamInformation const *)arg1)->AsString(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_StreamInformation(void * jarg1) {
  CNTK::StreamInformation *arg1 = (CNTK::StreamInformation *) 0 ;
  
  arg1 = (CNTK::StreamInformation *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SetTraceLevel(int jarg1) {
  CNTK::TraceLevel arg1 ;
  
  arg1 = (CNTK::TraceLevel)jarg1; 
  {
    try {
      CNTK::SetTraceLevel(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_GetTraceLevel() {
  int jresult ;
  CNTK::TraceLevel result;
  
  {
    try {
      result = (CNTK::TraceLevel)CNTK::GetTraceLevel(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchInfo_atEndOfData_set(void * jarg1, unsigned int jarg2) {
  CNTK::MinibatchInfo *arg1 = (CNTK::MinibatchInfo *) 0 ;
  bool arg2 ;
  
  arg1 = (CNTK::MinibatchInfo *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->atEndOfData = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_MinibatchInfo_atEndOfData_get(void * jarg1) {
  unsigned int jresult ;
  CNTK::MinibatchInfo *arg1 = (CNTK::MinibatchInfo *) 0 ;
  bool result;
  
  arg1 = (CNTK::MinibatchInfo *)jarg1; 
  result = (bool) ((arg1)->atEndOfData);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchInfo_atEndOfSweep_set(void * jarg1, unsigned int jarg2) {
  CNTK::MinibatchInfo *arg1 = (CNTK::MinibatchInfo *) 0 ;
  bool arg2 ;
  
  arg1 = (CNTK::MinibatchInfo *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->atEndOfSweep = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_MinibatchInfo_atEndOfSweep_get(void * jarg1) {
  unsigned int jresult ;
  CNTK::MinibatchInfo *arg1 = (CNTK::MinibatchInfo *) 0 ;
  bool result;
  
  arg1 = (CNTK::MinibatchInfo *)jarg1; 
  result = (bool) ((arg1)->atEndOfSweep);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchInfo_numberOfSamples_set(void * jarg1, unsigned long jarg2) {
  CNTK::MinibatchInfo *arg1 = (CNTK::MinibatchInfo *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::MinibatchInfo *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->numberOfSamples = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_MinibatchInfo_numberOfSamples_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::MinibatchInfo *arg1 = (CNTK::MinibatchInfo *) 0 ;
  size_t result;
  
  arg1 = (CNTK::MinibatchInfo *)jarg1; 
  result =  ((arg1)->numberOfSamples);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchInfo_trainingLossValue_set(void * jarg1, void * jarg2) {
  CNTK::MinibatchInfo *arg1 = (CNTK::MinibatchInfo *) 0 ;
  CNTK::NDArrayViewPtr *arg2 = 0 ;
  CNTK::NDArrayViewPtr tempnull2 ;
  
  arg1 = (CNTK::MinibatchInfo *)jarg1; 
  arg2 = jarg2 ? (CNTK::NDArrayViewPtr *)jarg2 : &tempnull2; 
  if (arg1) (arg1)->trainingLossValue = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchInfo_trainingLossValue_get(void * jarg1) {
  void * jresult ;
  CNTK::MinibatchInfo *arg1 = (CNTK::MinibatchInfo *) 0 ;
  CNTK::NDArrayViewPtr *result = 0 ;
  
  arg1 = (CNTK::MinibatchInfo *)jarg1; 
  result = (CNTK::NDArrayViewPtr *) & ((arg1)->trainingLossValue);
  jresult = *result ? new CNTK::NDArrayViewPtr(*result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchInfo_evalCriterionValue_set(void * jarg1, void * jarg2) {
  CNTK::MinibatchInfo *arg1 = (CNTK::MinibatchInfo *) 0 ;
  CNTK::NDArrayViewPtr *arg2 = 0 ;
  CNTK::NDArrayViewPtr tempnull2 ;
  
  arg1 = (CNTK::MinibatchInfo *)jarg1; 
  arg2 = jarg2 ? (CNTK::NDArrayViewPtr *)jarg2 : &tempnull2; 
  if (arg1) (arg1)->evalCriterionValue = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchInfo_evalCriterionValue_get(void * jarg1) {
  void * jresult ;
  CNTK::MinibatchInfo *arg1 = (CNTK::MinibatchInfo *) 0 ;
  CNTK::NDArrayViewPtr *result = 0 ;
  
  arg1 = (CNTK::MinibatchInfo *)jarg1; 
  result = (CNTK::NDArrayViewPtr *) & ((arg1)->evalCriterionValue);
  jresult = *result ? new CNTK::NDArrayViewPtr(*result) : 0; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_MinibatchInfo_IsEmpty(void * jarg1) {
  unsigned int jresult ;
  CNTK::MinibatchInfo *arg1 = (CNTK::MinibatchInfo *) 0 ;
  bool result;
  
  arg1 = (CNTK::MinibatchInfo *)jarg1; 
  {
    try {
      result = (bool)((CNTK::MinibatchInfo const *)arg1)->IsEmpty(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_MinibatchInfo() {
  void * jresult ;
  CNTK::MinibatchInfo *result = 0 ;
  
  {
    try {
      result = (CNTK::MinibatchInfo *)new CNTK::MinibatchInfo(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_MinibatchInfo(void * jarg1) {
  CNTK::MinibatchInfo *arg1 = (CNTK::MinibatchInfo *) 0 ;
  
  arg1 = (CNTK::MinibatchInfo *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_AreEqual__SWIG_1(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::DeviceDescriptor *arg1 = 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  bool result;
  
  arg1 = (CNTK::DeviceDescriptor *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)operator ==((CNTK::DeviceDescriptor const &)*arg1,(CNTK::DeviceDescriptor const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DeviceDescriptor__Id(void * jarg1) {
  unsigned int jresult ;
  CNTK::DeviceDescriptor *arg1 = (CNTK::DeviceDescriptor *) 0 ;
  unsigned int result;
  
  arg1 = (CNTK::DeviceDescriptor *)jarg1; 
  {
    try {
      result = (unsigned int)((CNTK::DeviceDescriptor const *)arg1)->Id(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_DeviceDescriptor__Type(void * jarg1) {
  int jresult ;
  CNTK::DeviceDescriptor *arg1 = (CNTK::DeviceDescriptor *) 0 ;
  CNTK::DeviceKind result;
  
  arg1 = (CNTK::DeviceDescriptor *)jarg1; 
  {
    try {
      result = (CNTK::DeviceKind)((CNTK::DeviceDescriptor const *)arg1)->Type(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DeviceDescriptor_IsLocked(void * jarg1) {
  unsigned int jresult ;
  CNTK::DeviceDescriptor *arg1 = (CNTK::DeviceDescriptor *) 0 ;
  bool result;
  
  arg1 = (CNTK::DeviceDescriptor *)jarg1; 
  {
    try {
      result = (bool)((CNTK::DeviceDescriptor const *)arg1)->IsLocked(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DeviceDescriptor__CPUDevice() {
  void * jresult ;
  SwigValueWrapper< CNTK::DeviceDescriptor > result;
  
  {
    try {
      result = CNTK::DeviceDescriptor::CPUDevice(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::DeviceDescriptor((const CNTK::DeviceDescriptor &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DeviceDescriptor__GPUDevice(unsigned int jarg1) {
  void * jresult ;
  unsigned int arg1 ;
  SwigValueWrapper< CNTK::DeviceDescriptor > result;
  
  arg1 = (unsigned int)jarg1; 
  {
    try {
      result = CNTK::DeviceDescriptor::GPUDevice(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::DeviceDescriptor((const CNTK::DeviceDescriptor &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DeviceDescriptor_UseDefaultDevice() {
  void * jresult ;
  SwigValueWrapper< CNTK::DeviceDescriptor > result;
  
  {
    try {
      result = CNTK::DeviceDescriptor::UseDefaultDevice(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::DeviceDescriptor((const CNTK::DeviceDescriptor &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DeviceDescriptor_TrySetDefaultDevice__SWIG_0(void * jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  CNTK::DeviceDescriptor *arg1 = 0 ;
  bool arg2 ;
  bool result;
  
  arg1 = (CNTK::DeviceDescriptor *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = (bool)CNTK::DeviceDescriptor::TrySetDefaultDevice((CNTK::DeviceDescriptor const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DeviceDescriptor_TrySetDefaultDevice__SWIG_1(void * jarg1) {
  unsigned int jresult ;
  CNTK::DeviceDescriptor *arg1 = 0 ;
  bool result;
  
  arg1 = (CNTK::DeviceDescriptor *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)CNTK::DeviceDescriptor::TrySetDefaultDevice((CNTK::DeviceDescriptor const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DeviceDescriptor__SetExcludedDevices(void * jarg1) {
  std::vector< CNTK::DeviceDescriptor > *arg1 = 0 ;
  
  arg1 = (std::vector< CNTK::DeviceDescriptor > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::DeviceDescriptor > const & type is null", 0);
    return ;
  } 
  {
    try {
      CNTK::DeviceDescriptor::SetExcludedDevices((std::vector< CNTK::DeviceDescriptor > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DeviceDescriptor__AllDevices() {
  void * jresult ;
  std::vector< CNTK::DeviceDescriptor > *result = 0 ;
  
  {
    try {
      result = (std::vector< CNTK::DeviceDescriptor > *) &CNTK::DeviceDescriptor::AllDevices(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DeviceDescriptor_AsString(void * jarg1) {
  void * jresult ;
  CNTK::DeviceDescriptor *arg1 = (CNTK::DeviceDescriptor *) 0 ;
  std::wstring result;
  
  arg1 = (CNTK::DeviceDescriptor *)jarg1; 
  {
    try {
      result = ((CNTK::DeviceDescriptor const *)arg1)->AsString(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_DeviceDescriptor(void * jarg1) {
  CNTK::DeviceDescriptor *arg1 = (CNTK::DeviceDescriptor *) 0 ;
  
  arg1 = (CNTK::DeviceDescriptor *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_AreNotEqual__SWIG_1(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::DeviceDescriptor *arg1 = 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  bool result;
  
  arg1 = (CNTK::DeviceDescriptor *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)CNTK::operator !=((CNTK::DeviceDescriptor const &)*arg1,(CNTK::DeviceDescriptor const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_0(int jarg1, void * jarg2, int* jarg3, int* jarg4, void * jarg5, unsigned long jarg6, void * jarg7, unsigned int jarg8) {
  void * jresult ;
  ::CNTK::DataType arg1 ;
  CNTK::NDShape *arg2 = 0 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg4 = (CNTK::SparseIndexType *) 0 ;
  void *arg5 = (void *) 0 ;
  size_t arg6 ;
  CNTK::DeviceDescriptor *arg7 = 0 ;
  bool arg8 ;
  CNTK::NDArrayView *result = 0 ;
  
  arg1 = (::CNTK::DataType)jarg1; 
  
  arg2 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg2) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = (void *)jarg5; 
  arg6 = (size_t)jarg6; 
  arg7 = (CNTK::DeviceDescriptor *)jarg7;
  if (!arg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg8 = jarg8 ? true : false; 
  {
    try {
      result = (CNTK::NDArrayView *)new CNTK::NDArrayView(arg1,(CNTK::NDShape const &)*arg2,(CNTK::SparseIndexType const *)arg3,(CNTK::SparseIndexType const *)arg4,(void const *)arg5,arg6,(CNTK::DeviceDescriptor const &)*arg7,arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_1(int jarg1, void * jarg2, int* jarg3, int* jarg4, void * jarg5, unsigned long jarg6, void * jarg7) {
  void * jresult ;
  ::CNTK::DataType arg1 ;
  CNTK::NDShape *arg2 = 0 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg4 = (CNTK::SparseIndexType *) 0 ;
  void *arg5 = (void *) 0 ;
  size_t arg6 ;
  CNTK::DeviceDescriptor *arg7 = 0 ;
  CNTK::NDArrayView *result = 0 ;
  
  arg1 = (::CNTK::DataType)jarg1; 
  
  arg2 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg2) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = (void *)jarg5; 
  arg6 = (size_t)jarg6; 
  arg7 = (CNTK::DeviceDescriptor *)jarg7;
  if (!arg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::NDArrayView *)new CNTK::NDArrayView(arg1,(CNTK::NDShape const &)*arg2,(CNTK::SparseIndexType const *)arg3,(CNTK::SparseIndexType const *)arg4,(void const *)arg5,arg6,(CNTK::DeviceDescriptor const &)*arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_2(int jarg1, int jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  ::CNTK::DataType arg1 ;
  ::CNTK::StorageFormat arg2 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::NDArrayView *result = 0 ;
  
  arg1 = (::CNTK::DataType)jarg1; 
  arg2 = (::CNTK::StorageFormat)jarg2; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::NDArrayView *)new CNTK::NDArrayView(arg1,arg2,(CNTK::NDShape const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_3(int jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  ::CNTK::DataType arg1 ;
  CNTK::NDShape *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::NDArrayView *result = 0 ;
  
  arg1 = (::CNTK::DataType)jarg1; 
  
  arg2 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg2) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::NDArrayView *)new CNTK::NDArrayView(arg1,(CNTK::NDShape const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_NDArrayView(void * jarg1) {
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::shared_ptr< CNTK::NDArrayView > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (void)arg1; delete smartarg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView__Device(void * jarg1) {
  void * jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  SwigValueWrapper< CNTK::DeviceDescriptor > result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::NDArrayView const *)arg1)->Device(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::DeviceDescriptor((const CNTK::DeviceDescriptor &)result); 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_NDArrayView__GetDataType(void * jarg1) {
  int jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  CNTK::DataType result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (CNTK::DataType)((CNTK::NDArrayView const *)arg1)->GetDataType(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_NDArrayView__GetStorageFormat(void * jarg1) {
  int jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  CNTK::StorageFormat result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (CNTK::StorageFormat)((CNTK::NDArrayView const *)arg1)->GetStorageFormat(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView__Shape(void * jarg1) {
  void * jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  CNTK::NDShape *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (CNTK::NDShape *) &((CNTK::NDArrayView const *)arg1)->Shape(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::shared_ptr< const CNTK::NDShape >(result SWIG_NO_NULL_DELETER_0); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_NDArrayView__IsSparse(void * jarg1) {
  unsigned int jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::NDArrayView const *)arg1)->IsSparse(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_NDArrayView__IsReadOnly(void * jarg1) {
  unsigned int jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::NDArrayView const *)arg1)->IsReadOnly(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_NDArrayView__IsSliceView(void * jarg1) {
  unsigned int jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::shared_ptr< CNTK::NDArrayView > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)(arg1)->IsSliceView(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayView_SetValue__SWIG_0(void * jarg1, float jarg2) {
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  float arg2 ;
  std::shared_ptr< CNTK::NDArrayView > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  {
    try {
      (arg1)->SetValue(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayView_SetValue__SWIG_1(void * jarg1, double jarg2) {
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  double arg2 ;
  std::shared_ptr< CNTK::NDArrayView > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (double)jarg2; 
  {
    try {
      (arg1)->SetValue(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayView_SetValue__SWIG_2(void * jarg1, void * jarg2) {
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  CNTK::float16 arg2 ;
  std::shared_ptr< CNTK::NDArrayView > *smartarg1 = 0 ;
  CNTK::float16 *argp2 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  argp2 = (CNTK::float16 *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null CNTK::float16", 0);
    return ;
  }
  arg2 = *argp2; 
  {
    try {
      (arg1)->SetValue(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayView_SetValue__SWIG_3(void * jarg1, void * jarg2) {
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  int8_t arg2 ;
  std::shared_ptr< CNTK::NDArrayView > *smartarg1 = 0 ;
  int8_t *argp2 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  argp2 = (int8_t *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null int8_t", 0);
    return ;
  }
  arg2 = *argp2; 
  {
    try {
      (arg1)->SetValue(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayView_SetValue__SWIG_4(void * jarg1, void * jarg2) {
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  int16_t arg2 ;
  std::shared_ptr< CNTK::NDArrayView > *smartarg1 = 0 ;
  int16_t *argp2 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  argp2 = (int16_t *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null int16_t", 0);
    return ;
  }
  arg2 = *argp2; 
  {
    try {
      (arg1)->SetValue(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView_DeepClone__SWIG_0(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  bool arg3 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = ((CNTK::NDArrayView const *)arg1)->DeepClone((CNTK::DeviceDescriptor const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView_DeepClone__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = ((CNTK::NDArrayView const *)arg1)->DeepClone((CNTK::DeviceDescriptor const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView_DeepClone__SWIG_2(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  bool arg2 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = ((CNTK::NDArrayView const *)arg1)->DeepClone(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView_DeepClone__SWIG_3(void * jarg1) {
  void * jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::NDArrayView const *)arg1)->DeepClone(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView__Alias__SWIG_0(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  bool arg2 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = ((CNTK::NDArrayView const *)arg1)->Alias(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView__Alias__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::NDArrayView const *)arg1)->Alias(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView__SliceView__SWIG_0(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::vector< size_t > *arg2 = 0 ;
  std::vector< size_t > *arg3 = 0 ;
  bool arg4 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< size_t > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = ((CNTK::NDArrayView const *)arg1)->SliceView((std::vector< size_t > const &)*arg2,(std::vector< size_t > const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView__SliceView__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::vector< size_t > *arg2 = 0 ;
  std::vector< size_t > *arg3 = 0 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< size_t > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = ((CNTK::NDArrayView const *)arg1)->SliceView((std::vector< size_t > const &)*arg2,(std::vector< size_t > const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView_AsShape(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  CNTK::NDShape *arg2 = 0 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  
  arg2 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg2) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = ((CNTK::NDArrayView const *)arg1)->AsShape((CNTK::NDShape const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayView_CopyFrom(void * jarg1, void * jarg2) {
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  CNTK::NDArrayView *arg2 = 0 ;
  std::shared_ptr< CNTK::NDArrayView > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  
  arg2 = (CNTK::NDArrayView *)(((std::shared_ptr< const CNTK::NDArrayView > *)jarg2) ? ((std::shared_ptr< const CNTK::NDArrayView > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDArrayView const & reference is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->CopyFrom((CNTK::NDArrayView const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDArrayView_ChangeDevice(void * jarg1, void * jarg2) {
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  std::shared_ptr< CNTK::NDArrayView > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->ChangeDevice((CNTK::DeviceDescriptor const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView_AsString(void * jarg1) {
  void * jresult ;
  CNTK::NDArrayView *arg1 = (CNTK::NDArrayView *) 0 ;
  std::shared_ptr< CNTK::NDArrayView const > *smartarg1 = 0 ;
  std::wstring result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDArrayView > *)jarg1;
  arg1 = (CNTK::NDArrayView *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::NDArrayView const *)arg1)->AsString(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_14(void * jarg1, float* jarg2, unsigned long jarg3, void * jarg4, unsigned int jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  float *arg2 = (float *) 0 ;
  size_t arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  CNTK::NDArrayView *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = (size_t)jarg3; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = (CNTK::NDArrayView *)new_CNTK_NDArrayView__SWIG_14((CNTK::NDShape const &)*arg1,arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_15(void * jarg1, float* jarg2, unsigned long jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  float *arg2 = (float *) 0 ;
  size_t arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::NDArrayView *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = (size_t)jarg3; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::NDArrayView *)new_CNTK_NDArrayView__SWIG_14((CNTK::NDShape const &)*arg1,arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_16(void * jarg1, double* jarg2, unsigned long jarg3, void * jarg4, unsigned int jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  double *arg2 = (double *) 0 ;
  size_t arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  CNTK::NDArrayView *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = (size_t)jarg3; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = (CNTK::NDArrayView *)new_CNTK_NDArrayView__SWIG_16((CNTK::NDShape const &)*arg1,arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_17(void * jarg1, double* jarg2, unsigned long jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  double *arg2 = (double *) 0 ;
  size_t arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::NDArrayView *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = (size_t)jarg3; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::NDArrayView *)new_CNTK_NDArrayView__SWIG_16((CNTK::NDShape const &)*arg1,arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_18(void * jarg1, int* jarg2, int* jarg3, float* jarg4, unsigned long jarg5, void * jarg6, unsigned int jarg7) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::SparseIndexType *arg2 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  float *arg4 = (float *) 0 ;
  size_t arg5 ;
  CNTK::DeviceDescriptor *arg6 = 0 ;
  bool arg7 ;
  CNTK::NDArrayView *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = (size_t)jarg5; 
  arg6 = (CNTK::DeviceDescriptor *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  {
    try {
      result = (CNTK::NDArrayView *)new_CNTK_NDArrayView__SWIG_18((CNTK::NDShape const &)*arg1,(int const *)arg2,(int const *)arg3,(float const *)arg4,arg5,(CNTK::DeviceDescriptor const &)*arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_19(void * jarg1, int* jarg2, int* jarg3, float* jarg4, unsigned long jarg5, void * jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::SparseIndexType *arg2 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  float *arg4 = (float *) 0 ;
  size_t arg5 ;
  CNTK::DeviceDescriptor *arg6 = 0 ;
  CNTK::NDArrayView *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = (size_t)jarg5; 
  arg6 = (CNTK::DeviceDescriptor *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::NDArrayView *)new_CNTK_NDArrayView__SWIG_18((CNTK::NDShape const &)*arg1,(int const *)arg2,(int const *)arg3,(float const *)arg4,arg5,(CNTK::DeviceDescriptor const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_20(void * jarg1, int* jarg2, int* jarg3, double* jarg4, unsigned long jarg5, void * jarg6, unsigned int jarg7) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::SparseIndexType *arg2 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  double *arg4 = (double *) 0 ;
  size_t arg5 ;
  CNTK::DeviceDescriptor *arg6 = 0 ;
  bool arg7 ;
  CNTK::NDArrayView *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = (size_t)jarg5; 
  arg6 = (CNTK::DeviceDescriptor *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  {
    try {
      result = (CNTK::NDArrayView *)new_CNTK_NDArrayView__SWIG_20((CNTK::NDShape const &)*arg1,(int const *)arg2,(int const *)arg3,(double const *)arg4,arg5,(CNTK::DeviceDescriptor const &)*arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_21(void * jarg1, int* jarg2, int* jarg3, double* jarg4, unsigned long jarg5, void * jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::SparseIndexType *arg2 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  double *arg4 = (double *) 0 ;
  size_t arg5 ;
  CNTK::DeviceDescriptor *arg6 = 0 ;
  CNTK::NDArrayView *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = (size_t)jarg5; 
  arg6 = (CNTK::DeviceDescriptor *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::NDArrayView *)new_CNTK_NDArrayView__SWIG_20((CNTK::NDShape const &)*arg1,(int const *)arg2,(int const *)arg3,(double const *)arg4,arg5,(CNTK::DeviceDescriptor const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_22(void * jarg1, int* jarg2, int* jarg3, void * jarg4, unsigned long jarg5, void * jarg6, unsigned int jarg7) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::SparseIndexType *arg2 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  int8_t *arg4 = (int8_t *) 0 ;
  size_t arg5 ;
  CNTK::DeviceDescriptor *arg6 = 0 ;
  bool arg7 ;
  CNTK::NDArrayView *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = jarg3;
  arg4 = (int8_t *)jarg4; 
  arg5 = (size_t)jarg5; 
  arg6 = (CNTK::DeviceDescriptor *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  {
    try {
      result = (CNTK::NDArrayView *)new_CNTK_NDArrayView__SWIG_22((CNTK::NDShape const &)*arg1,(int const *)arg2,(int const *)arg3,(int8_t const *)arg4,arg5,(CNTK::DeviceDescriptor const &)*arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_23(void * jarg1, int* jarg2, int* jarg3, void * jarg4, unsigned long jarg5, void * jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::SparseIndexType *arg2 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  int8_t *arg4 = (int8_t *) 0 ;
  size_t arg5 ;
  CNTK::DeviceDescriptor *arg6 = 0 ;
  CNTK::NDArrayView *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = jarg3;
  arg4 = (int8_t *)jarg4; 
  arg5 = (size_t)jarg5; 
  arg6 = (CNTK::DeviceDescriptor *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::NDArrayView *)new_CNTK_NDArrayView__SWIG_22((CNTK::NDShape const &)*arg1,(int const *)arg2,(int const *)arg3,(int8_t const *)arg4,arg5,(CNTK::DeviceDescriptor const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_24(void * jarg1, int* jarg2, int* jarg3, void * jarg4, unsigned long jarg5, void * jarg6, unsigned int jarg7) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::SparseIndexType *arg2 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  int16_t *arg4 = (int16_t *) 0 ;
  size_t arg5 ;
  CNTK::DeviceDescriptor *arg6 = 0 ;
  bool arg7 ;
  CNTK::NDArrayView *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = jarg3;
  arg4 = (int16_t *)jarg4; 
  arg5 = (size_t)jarg5; 
  arg6 = (CNTK::DeviceDescriptor *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  {
    try {
      result = (CNTK::NDArrayView *)new_CNTK_NDArrayView__SWIG_24((CNTK::NDShape const &)*arg1,(int const *)arg2,(int const *)arg3,(int16_t const *)arg4,arg5,(CNTK::DeviceDescriptor const &)*arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDArrayView__SWIG_25(void * jarg1, int* jarg2, int* jarg3, void * jarg4, unsigned long jarg5, void * jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::SparseIndexType *arg2 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  int16_t *arg4 = (int16_t *) 0 ;
  size_t arg5 ;
  CNTK::DeviceDescriptor *arg6 = 0 ;
  CNTK::NDArrayView *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = jarg3;
  arg4 = (int16_t *)jarg4; 
  arg5 = (size_t)jarg5; 
  arg6 = (CNTK::DeviceDescriptor *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::NDArrayView *)new_CNTK_NDArrayView__SWIG_24((CNTK::NDShape const &)*arg1,(int const *)arg2,(int const *)arg3,(int16_t const *)arg4,arg5,(CNTK::DeviceDescriptor const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDArrayView >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView__RandomNormalFloat(void * jarg1, double jarg2, double jarg3, unsigned long jarg4, void * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  unsigned long arg4 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (unsigned long)jarg4; 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_NDArrayView_RandomNormalFloat((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,(CNTK::DeviceDescriptor const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView__RandomNormalDouble(void * jarg1, double jarg2, double jarg3, unsigned long jarg4, void * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  unsigned long arg4 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (unsigned long)jarg4; 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_NDArrayView_RandomNormalDouble((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,(CNTK::DeviceDescriptor const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView__RandomUniformFloat(void * jarg1, double jarg2, double jarg3, unsigned long jarg4, void * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  unsigned long arg4 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (unsigned long)jarg4; 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_NDArrayView_RandomUniformFloat((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,(CNTK::DeviceDescriptor const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDArrayView__RandomUniformDouble(void * jarg1, double jarg2, double jarg3, unsigned long jarg4, void * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  unsigned long arg4 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (unsigned long)jarg4; 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_NDArrayView_RandomUniformDouble((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,(CNTK::DeviceDescriptor const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDMask__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  CNTK::NDMask *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::NDMask *)new CNTK::NDMask((CNTK::NDShape const &)*arg1,(CNTK::DeviceDescriptor const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDMask >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_NDMask__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::NDMask *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::NDMask *)new CNTK::NDMask((CNTK::NDShape const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::NDMask >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_NDMask(void * jarg1) {
  CNTK::NDMask *arg1 = (CNTK::NDMask *) 0 ;
  std::shared_ptr< CNTK::NDMask > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDMask > *)jarg1;
  arg1 = (CNTK::NDMask *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (void)arg1; delete smartarg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDMask__InvalidateSection(void * jarg1, void * jarg2, void * jarg3) {
  CNTK::NDMask *arg1 = (CNTK::NDMask *) 0 ;
  std::vector< size_t > *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::shared_ptr< CNTK::NDMask > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDMask > *)jarg1;
  arg1 = (CNTK::NDMask *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return ;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->InvalidateSection((std::vector< size_t > const &)*arg2,(CNTK::NDShape const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDMask__MarkSequenceBegin__SWIG_0(void * jarg1, void * jarg2) {
  CNTK::NDMask *arg1 = (CNTK::NDMask *) 0 ;
  std::vector< size_t > *arg2 = 0 ;
  std::shared_ptr< CNTK::NDMask > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDMask > *)jarg1;
  arg1 = (CNTK::NDMask *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->MarkSequenceBegin((std::vector< size_t > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDMask__MarkSequenceBegin__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  CNTK::NDMask *arg1 = (CNTK::NDMask *) 0 ;
  std::vector< size_t > *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::shared_ptr< CNTK::NDMask > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDMask > *)jarg1;
  arg1 = (CNTK::NDMask *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return ;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->MarkSequenceBegin((std::vector< size_t > const &)*arg2,(CNTK::NDShape const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDMask_Clear(void * jarg1) {
  CNTK::NDMask *arg1 = (CNTK::NDMask *) 0 ;
  std::shared_ptr< CNTK::NDMask > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDMask > *)jarg1;
  arg1 = (CNTK::NDMask *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (arg1)->Clear(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_NDMask__MaskedCount(void * jarg1) {
  unsigned long jresult ;
  CNTK::NDMask *arg1 = (CNTK::NDMask *) 0 ;
  std::shared_ptr< CNTK::NDMask const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDMask > *)jarg1;
  arg1 = (CNTK::NDMask *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::NDMask const *)arg1)->MaskedCount(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDMask__Device(void * jarg1) {
  void * jresult ;
  CNTK::NDMask *arg1 = (CNTK::NDMask *) 0 ;
  std::shared_ptr< CNTK::NDMask const > *smartarg1 = 0 ;
  SwigValueWrapper< CNTK::DeviceDescriptor > result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDMask > *)jarg1;
  arg1 = (CNTK::NDMask *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::NDMask const *)arg1)->Device(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::DeviceDescriptor((const CNTK::DeviceDescriptor &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDMask__Shape(void * jarg1) {
  void * jresult ;
  CNTK::NDMask *arg1 = (CNTK::NDMask *) 0 ;
  std::shared_ptr< CNTK::NDMask const > *smartarg1 = 0 ;
  CNTK::NDShape *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDMask > *)jarg1;
  arg1 = (CNTK::NDMask *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (CNTK::NDShape *) &((CNTK::NDMask const *)arg1)->Shape(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::shared_ptr< const CNTK::NDShape >(result SWIG_NO_NULL_DELETER_0); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDMask_DeepClone__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::NDMask *arg1 = (CNTK::NDMask *) 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  std::shared_ptr< CNTK::NDMask const > *smartarg1 = 0 ;
  CNTK::NDMaskPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDMask > *)jarg1;
  arg1 = (CNTK::NDMask *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = ((CNTK::NDMask const *)arg1)->DeepClone((CNTK::DeviceDescriptor const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDMaskPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDMask_DeepClone__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::NDMask *arg1 = (CNTK::NDMask *) 0 ;
  std::shared_ptr< CNTK::NDMask const > *smartarg1 = 0 ;
  CNTK::NDMaskPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDMask > *)jarg1;
  arg1 = (CNTK::NDMask *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::NDMask const *)arg1)->DeepClone(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDMaskPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDMask_Alias(void * jarg1) {
  void * jresult ;
  CNTK::NDMask *arg1 = (CNTK::NDMask *) 0 ;
  std::shared_ptr< CNTK::NDMask const > *smartarg1 = 0 ;
  CNTK::NDMaskPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::NDMask > *)jarg1;
  arg1 = (CNTK::NDMask *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::NDMask const *)arg1)->Alias(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDMaskPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_NDMask_CopyFrom(void * jarg1, void * jarg2) {
  CNTK::NDMask *arg1 = (CNTK::NDMask *) 0 ;
  CNTK::NDMask *arg2 = 0 ;
  std::shared_ptr< CNTK::NDMask > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::NDMask > *)jarg1;
  arg1 = (CNTK::NDMask *)(smartarg1 ? smartarg1->get() : 0); 
  
  arg2 = (CNTK::NDMask *)(((std::shared_ptr< const CNTK::NDMask > *)jarg2) ? ((std::shared_ptr< const CNTK::NDMask > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDMask const & reference is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->CopyFrom((CNTK::NDMask const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_AreEqual__SWIG_2(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::Axis *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  bool result;
  
  arg1 = (CNTK::Axis *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)operator ==((CNTK::Axis const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Axis_DefaultInputVariableDynamicAxes() {
  void * jresult ;
  std::vector< CNTK::Axis > *result = 0 ;
  
  {
    try {
      result = (std::vector< CNTK::Axis > *) &CNTK::Axis::DefaultInputVariableDynamicAxes(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Axis_UnknownDynamicAxes() {
  void * jresult ;
  std::vector< CNTK::Axis > *result = 0 ;
  
  {
    try {
      result = (std::vector< CNTK::Axis > *) &CNTK::Axis::UnknownDynamicAxes(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Axis__SWIG_0(int jarg1) {
  void * jresult ;
  int arg1 ;
  CNTK::Axis *result = 0 ;
  
  arg1 = (int)jarg1; 
  {
    try {
      result = (CNTK::Axis *)new CNTK::Axis(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Axis__SWIG_1(wchar_t * jarg1, unsigned int jarg2) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  bool arg2 ;
  CNTK::Axis *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = (CNTK::Axis *)new CNTK::Axis((std::wstring const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Axis__SWIG_2(wchar_t * jarg1) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  CNTK::Axis *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  {
    try {
      result = (CNTK::Axis *)new CNTK::Axis((std::wstring const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Axis__IsStaticAxis(void * jarg1) {
  unsigned int jresult ;
  CNTK::Axis *arg1 = (CNTK::Axis *) 0 ;
  bool result;
  
  arg1 = (CNTK::Axis *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Axis const *)arg1)->IsStaticAxis(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Axis__IsDynamicAxis(void * jarg1) {
  unsigned int jresult ;
  CNTK::Axis *arg1 = (CNTK::Axis *) 0 ;
  bool result;
  
  arg1 = (CNTK::Axis *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Axis const *)arg1)->IsDynamicAxis(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Axis_IsBatchAxis(void * jarg1) {
  unsigned int jresult ;
  CNTK::Axis *arg1 = (CNTK::Axis *) 0 ;
  bool result;
  
  arg1 = (CNTK::Axis *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Axis const *)arg1)->IsBatchAxis(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Axis_IsSequenceAxis(void * jarg1) {
  unsigned int jresult ;
  CNTK::Axis *arg1 = (CNTK::Axis *) 0 ;
  bool result;
  
  arg1 = (CNTK::Axis *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Axis const *)arg1)->IsSequenceAxis(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Axis__IsOrdered(void * jarg1) {
  unsigned int jresult ;
  CNTK::Axis *arg1 = (CNTK::Axis *) 0 ;
  bool result;
  
  arg1 = (CNTK::Axis *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Axis const *)arg1)->IsOrdered(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_Axis__StaticAxisIndex__SWIG_0(void * jarg1, unsigned int jarg2) {
  int jresult ;
  CNTK::Axis *arg1 = (CNTK::Axis *) 0 ;
  bool arg2 ;
  int result;
  
  arg1 = (CNTK::Axis *)jarg1; 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = (int)((CNTK::Axis const *)arg1)->StaticAxisIndex(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_Axis__StaticAxisIndex__SWIG_1(void * jarg1) {
  int jresult ;
  CNTK::Axis *arg1 = (CNTK::Axis *) 0 ;
  int result;
  
  arg1 = (CNTK::Axis *)jarg1; 
  {
    try {
      result = (int)((CNTK::Axis const *)arg1)->StaticAxisIndex(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Axis_DefaultDynamicAxis() {
  void * jresult ;
  CNTK::Axis *result = 0 ;
  
  {
    try {
      result = (CNTK::Axis *) &CNTK::Axis::DefaultDynamicAxis(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Axis_OperandSequenceAxis() {
  void * jresult ;
  CNTK::Axis *result = 0 ;
  
  {
    try {
      result = (CNTK::Axis *) &CNTK::Axis::OperandSequenceAxis(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Axis_DefaultBatchAxis() {
  void * jresult ;
  CNTK::Axis *result = 0 ;
  
  {
    try {
      result = (CNTK::Axis *) &CNTK::Axis::DefaultBatchAxis(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Axis_AllStaticAxes() {
  void * jresult ;
  CNTK::Axis *result = 0 ;
  
  {
    try {
      result = (CNTK::Axis *) &CNTK::Axis::AllStaticAxes(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Axis_AllAxes() {
  void * jresult ;
  CNTK::Axis *result = 0 ;
  
  {
    try {
      result = (CNTK::Axis *) &CNTK::Axis::AllAxes(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Axis_NewUniqueDynamicAxis__SWIG_0(wchar_t * jarg1, unsigned int jarg2) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  bool arg2 ;
  CNTK::Axis result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = CNTK::Axis::NewUniqueDynamicAxis((std::wstring const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Axis((const CNTK::Axis &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Axis_NewUniqueDynamicAxis__SWIG_1(wchar_t * jarg1) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  CNTK::Axis result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  {
    try {
      result = CNTK::Axis::NewUniqueDynamicAxis((std::wstring const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Axis((const CNTK::Axis &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Axis_EndStaticAxis() {
  void * jresult ;
  CNTK::Axis result;
  
  {
    try {
      result = CNTK::Axis::EndStaticAxis(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Axis((const CNTK::Axis &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Axis__Name(void * jarg1) {
  void * jresult ;
  CNTK::Axis *arg1 = (CNTK::Axis *) 0 ;
  std::wstring *result = 0 ;
  
  arg1 = (CNTK::Axis *)jarg1; 
  {
    try {
      result = (std::wstring *) &((CNTK::Axis const *)arg1)->Name(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Axis_AsString(void * jarg1) {
  void * jresult ;
  CNTK::Axis *arg1 = (CNTK::Axis *) 0 ;
  std::wstring result;
  
  arg1 = (CNTK::Axis *)jarg1; 
  {
    try {
      result = ((CNTK::Axis const *)arg1)->AsString(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Axis__SWIG_3() {
  void * jresult ;
  CNTK::Axis *result = 0 ;
  
  {
    try {
      result = (CNTK::Axis *)new CNTK::Axis(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_Axis(void * jarg1) {
  CNTK::Axis *arg1 = (CNTK::Axis *) 0 ;
  
  arg1 = (CNTK::Axis *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_AreNotEqual__SWIG_2(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::Axis *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  bool result;
  
  arg1 = (CNTK::Axis *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)CNTK::operator !=((CNTK::Axis const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CNTK_DictionaryValue_TypeName(int jarg1) {
  char * jresult ;
  CNTK::DictionaryValue::Type arg1 ;
  char *result = 0 ;
  
  arg1 = (CNTK::DictionaryValue::Type)jarg1; 
  {
    try {
      result = (char *)CNTK::DictionaryValue::TypeName(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_string_callback((const char *)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DictionaryValue__SWIG_0() {
  void * jresult ;
  CNTK::DictionaryValue *result = 0 ;
  
  {
    try {
      result = (CNTK::DictionaryValue *)new CNTK::DictionaryValue(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DictionaryValue__SWIG_1(unsigned int jarg1) {
  void * jresult ;
  bool arg1 ;
  CNTK::DictionaryValue *result = 0 ;
  
  arg1 = jarg1 ? true : false; 
  {
    try {
      result = (CNTK::DictionaryValue *)new CNTK::DictionaryValue(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DictionaryValue__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  CNTK::DictionaryValue *result = 0 ;
  
  arg1 = (int)jarg1; 
  {
    try {
      result = (CNTK::DictionaryValue *)new CNTK::DictionaryValue(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DictionaryValue__SWIG_3(unsigned long jarg1) {
  void * jresult ;
  size_t arg1 ;
  CNTK::DictionaryValue *result = 0 ;
  
  arg1 = (size_t)jarg1; 
  {
    try {
      result = (CNTK::DictionaryValue *)new CNTK::DictionaryValue(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DictionaryValue__SWIG_4(float jarg1) {
  void * jresult ;
  float arg1 ;
  CNTK::DictionaryValue *result = 0 ;
  
  arg1 = (float)jarg1; 
  {
    try {
      result = (CNTK::DictionaryValue *)new CNTK::DictionaryValue(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DictionaryValue__SWIG_5(double jarg1) {
  void * jresult ;
  double arg1 ;
  CNTK::DictionaryValue *result = 0 ;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = (CNTK::DictionaryValue *)new CNTK::DictionaryValue(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DictionaryValue__SWIG_6(wchar_t * jarg1) {
  void * jresult ;
  wchar_t *arg1 = (wchar_t *) 0 ;
  CNTK::DictionaryValue *result = 0 ;
  
  arg1 = (wchar_t *)jarg1; 
  {
    try {
      result = (CNTK::DictionaryValue *)new CNTK::DictionaryValue((wchar_t const *)arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_DictionaryValue__SWIG_8(void * jarg1) {
  void * jresult ;
  CNTK::DictionaryValue *arg1 = 0 ;
  CNTK::DictionaryValue *result = 0 ;
  
  arg1 = (CNTK::DictionaryValue *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DictionaryValue const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::DictionaryValue *)new CNTK::DictionaryValue((CNTK::DictionaryValue const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_DictionaryValue(void * jarg1) {
  CNTK::DictionaryValue *arg1 = (CNTK::DictionaryValue *) 0 ;
  
  arg1 = (CNTK::DictionaryValue *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DictionaryValue_HasValue(void * jarg1) {
  unsigned int jresult ;
  CNTK::DictionaryValue *arg1 = (CNTK::DictionaryValue *) 0 ;
  bool result;
  
  arg1 = (CNTK::DictionaryValue *)jarg1; 
  {
    try {
      result = (bool)((CNTK::DictionaryValue const *)arg1)->HasValue(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_DictionaryValue_ValueType(void * jarg1) {
  int jresult ;
  CNTK::DictionaryValue *arg1 = (CNTK::DictionaryValue *) 0 ;
  CNTK::DictionaryValue::Type result;
  
  arg1 = (CNTK::DictionaryValue *)jarg1; 
  {
    try {
      result = (CNTK::DictionaryValue::Type)((CNTK::DictionaryValue const *)arg1)->ValueType(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DictionaryValue_AreEqual(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::DictionaryValue *arg1 = (CNTK::DictionaryValue *) 0 ;
  CNTK::DictionaryValue *arg2 = 0 ;
  bool result;
  
  arg1 = (CNTK::DictionaryValue *)jarg1; 
  arg2 = (CNTK::DictionaryValue *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DictionaryValue const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)((CNTK::DictionaryValue const *)arg1)->operator ==((CNTK::DictionaryValue const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_DictionaryValue_AreNotEqual(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::DictionaryValue *arg1 = (CNTK::DictionaryValue *) 0 ;
  CNTK::DictionaryValue *arg2 = 0 ;
  bool result;
  
  arg1 = (CNTK::DictionaryValue *)jarg1; 
  arg2 = (CNTK::DictionaryValue *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DictionaryValue const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)((CNTK::DictionaryValue const *)arg1)->operator !=((CNTK::DictionaryValue const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_DictionaryValue_Save(void * jarg1, wchar_t * jarg2) {
  CNTK::DictionaryValue *arg1 = (CNTK::DictionaryValue *) 0 ;
  std::wstring *arg2 = 0 ;
  
  arg1 = (CNTK::DictionaryValue *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      (arg1)->Save((std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DictionaryValue_Load(wchar_t * jarg1) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  CNTK::DictionaryValue result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  {
    try {
      result = CNTK::DictionaryValue::Load((std::wstring const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::DictionaryValue((const CNTK::DictionaryValue &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_CNTKDictionary__SWIG_0() {
  void * jresult ;
  CNTK::Dictionary *result = 0 ;
  
  {
    try {
      result = (CNTK::Dictionary *)new CNTK::Dictionary(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_CNTKDictionary(void * jarg1) {
  CNTK::Dictionary *arg1 = (CNTK::Dictionary *) 0 ;
  
  arg1 = (CNTK::Dictionary *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_CNTKDictionary__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Dictionary *arg1 = 0 ;
  CNTK::Dictionary *result = 0 ;
  
  arg1 = (CNTK::Dictionary *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::Dictionary *)new CNTK::Dictionary((CNTK::Dictionary const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CNTKDictionary_Equal(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Dictionary *arg1 = (CNTK::Dictionary *) 0 ;
  CNTK::Dictionary *arg2 = 0 ;
  CNTK::Dictionary *result = 0 ;
  
  arg1 = (CNTK::Dictionary *)jarg1; 
  arg2 = (CNTK::Dictionary *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::Dictionary *) &(arg1)->operator =((CNTK::Dictionary const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_CNTKDictionary_Contains(void * jarg1, wchar_t * jarg2) {
  unsigned int jresult ;
  CNTK::Dictionary *arg1 = (CNTK::Dictionary *) 0 ;
  wchar_t *arg2 = (wchar_t *) 0 ;
  bool result;
  
  arg1 = (CNTK::Dictionary *)jarg1; 
  arg2 = (wchar_t *)jarg2; 
  {
    try {
      result = (bool)((CNTK::Dictionary const *)arg1)->Contains((wchar_t const *)arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CNTKDictionary_Add__SWIG_0(void * jarg1, void * jarg2) {
  CNTK::Dictionary *arg1 = (CNTK::Dictionary *) 0 ;
  CNTK::Dictionary *arg2 = 0 ;
  
  arg1 = (CNTK::Dictionary *)jarg1; 
  arg2 = (CNTK::Dictionary *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->Add((CNTK::Dictionary const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CNTKDictionary_Add__SWIG_1(void * jarg1, wchar_t * jarg2, void * jarg3) {
  CNTK::Dictionary *arg1 = (CNTK::Dictionary *) 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::DictionaryValue *arg3 = 0 ;
  
  arg1 = (CNTK::Dictionary *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (CNTK::DictionaryValue *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DictionaryValue const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->Add((std::wstring const &)*arg2,(CNTK::DictionaryValue const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_CNTKDictionary_AreEqual(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::Dictionary *arg1 = (CNTK::Dictionary *) 0 ;
  CNTK::Dictionary *arg2 = 0 ;
  bool result;
  
  arg1 = (CNTK::Dictionary *)jarg1; 
  arg2 = (CNTK::Dictionary *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)((CNTK::Dictionary const *)arg1)->operator ==((CNTK::Dictionary const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_CNTKDictionary_AreNotEqual(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::Dictionary *arg1 = (CNTK::Dictionary *) 0 ;
  CNTK::Dictionary *arg2 = 0 ;
  bool result;
  
  arg1 = (CNTK::Dictionary *)jarg1; 
  arg2 = (CNTK::Dictionary *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)((CNTK::Dictionary const *)arg1)->operator !=((CNTK::Dictionary const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_CNTKDictionary_Size(void * jarg1) {
  unsigned long jresult ;
  CNTK::Dictionary *arg1 = (CNTK::Dictionary *) 0 ;
  size_t result;
  
  arg1 = (CNTK::Dictionary *)jarg1; 
  {
    try {
      result = ((CNTK::Dictionary const *)arg1)->Size(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_CNTKDictionary_Save(void * jarg1, wchar_t * jarg2) {
  CNTK::Dictionary *arg1 = (CNTK::Dictionary *) 0 ;
  std::wstring *arg2 = 0 ;
  
  arg1 = (CNTK::Dictionary *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      (arg1)->Save((std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CNTKDictionary_Load(wchar_t * jarg1) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  CNTK::Dictionary result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  {
    try {
      result = CNTK::Dictionary::Load((std::wstring const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Dictionary((const CNTK::Dictionary &)result); 
  return jresult;
}


SWIGEXPORT wchar_t * SWIGSTDCALL CSharp_CNTK_VariableKindName(int jarg1) {
  wchar_t * jresult ;
  CNTK::VariableKind arg1 ;
  wchar_t *result = 0 ;
  
  arg1 = (CNTK::VariableKind)jarg1; 
  {
    try {
      result = (wchar_t *)CNTK::VariableKindName(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (wchar_t *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PlaceholderVariable__SWIG_0(void * jarg1, int jarg2, wchar_t * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  ::CNTK::DataType arg2 ;
  std::wstring *arg3 = 0 ;
  std::vector< CNTK::Axis > *arg4 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (::CNTK::DataType)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  arg4 = (std::vector< CNTK::Axis > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::PlaceholderVariable((CNTK::NDShape const &)*arg1,arg2,(std::wstring const &)*arg3,(std::vector< CNTK::Axis > const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PlaceholderVariable__SWIG_1(void * jarg1, int jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  ::CNTK::DataType arg2 ;
  std::wstring *arg3 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (::CNTK::DataType)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::PlaceholderVariable((CNTK::NDShape const &)*arg1,arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_0(void * jarg1, unsigned int jarg2, int jarg3, unsigned int jarg4, wchar_t * jarg5, void * jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  bool arg2 ;
  ::CNTK::DataType arg3 ;
  bool arg4 ;
  std::wstring *arg5 = 0 ;
  std::vector< CNTK::Axis > *arg6 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  arg3 = (::CNTK::DataType)jarg3; 
  arg4 = jarg4 ? true : false; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  arg6 = (std::vector< CNTK::Axis > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,(std::wstring const &)*arg5,(std::vector< CNTK::Axis > const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_1(void * jarg1, unsigned int jarg2, int jarg3, unsigned int jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  bool arg2 ;
  ::CNTK::DataType arg3 ;
  bool arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  arg3 = (::CNTK::DataType)jarg3; 
  arg4 = jarg4 ? true : false; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_OutputVariable__SWIG_0(void * jarg1, int jarg2, void * jarg3, unsigned int jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  ::CNTK::DataType arg2 ;
  std::vector< CNTK::Axis > *arg3 = 0 ;
  bool arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (::CNTK::DataType)jarg2; 
  arg3 = (std::vector< CNTK::Axis > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::OutputVariable((CNTK::NDShape const &)*arg1,arg2,(std::vector< CNTK::Axis > const &)*arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_OutputVariable__SWIG_1(void * jarg1, int jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  ::CNTK::DataType arg2 ;
  std::vector< CNTK::Axis > *arg3 = 0 ;
  bool arg4 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (::CNTK::DataType)jarg2; 
  arg3 = (std::vector< CNTK::Axis > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK::OutputVariable((CNTK::NDShape const &)*arg1,arg2,(std::vector< CNTK::Axis > const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_AreEqual__SWIG_3(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  bool result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)operator ==((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Variable__SWIG_0(void * jarg1) {
  void * jresult ;
  CNTK::FunctionPtr *arg1 = 0 ;
  CNTK::FunctionPtr tempnull1 ;
  CNTK::Variable *result = 0 ;
  
  arg1 = jarg1 ? (CNTK::FunctionPtr *)jarg1 : &tempnull1; 
  {
    try {
      result = (CNTK::Variable *)new CNTK::Variable((CNTK::FunctionPtr const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Variable_ToFunction(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = ((CNTK::Variable const *)arg1)->operator CNTK::FunctionPtr(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Variable__SWIG_1() {
  void * jresult ;
  CNTK::Variable *result = 0 ;
  
  {
    try {
      result = (CNTK::Variable *)new CNTK::Variable(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Variable__Shape(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  CNTK::NDShape *result = 0 ;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (CNTK::NDShape *) &((CNTK::Variable const *)arg1)->Shape(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::shared_ptr< const CNTK::NDShape >(result SWIG_NO_NULL_DELETER_0); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Variable__DynamicAxes(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  std::vector< CNTK::Axis > *result = 0 ;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (std::vector< CNTK::Axis > *) &((CNTK::Variable const *)arg1)->DynamicAxes(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_Variable__Kind(void * jarg1) {
  int jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  CNTK::VariableKind result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (CNTK::VariableKind)((CNTK::Variable const *)arg1)->Kind(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Variable__IsSparse(void * jarg1) {
  unsigned int jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  bool result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Variable const *)arg1)->IsSparse(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Variable__IsInput(void * jarg1) {
  unsigned int jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  bool result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Variable const *)arg1)->IsInput(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Variable__IsOutput(void * jarg1) {
  unsigned int jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  bool result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Variable const *)arg1)->IsOutput(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Variable__IsParameter(void * jarg1) {
  unsigned int jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  bool result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Variable const *)arg1)->IsParameter(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Variable__IsConstant(void * jarg1) {
  unsigned int jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  bool result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Variable const *)arg1)->IsConstant(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Variable__IsPlaceholder(void * jarg1) {
  unsigned int jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  bool result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Variable const *)arg1)->IsPlaceholder(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Variable_HasBatchAxis(void * jarg1) {
  unsigned int jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  bool result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Variable const *)arg1)->HasBatchAxis(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Variable_HasSequenceAxis(void * jarg1) {
  unsigned int jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  bool result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Variable const *)arg1)->HasSequenceAxis(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Variable_IsInitialized(void * jarg1) {
  unsigned int jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  bool result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Variable const *)arg1)->IsInitialized(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Variable__Name(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  std::wstring *result = 0 ;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (std::wstring *) &((CNTK::Variable const *)arg1)->Name(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Variable__Uid(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  std::wstring *result = 0 ;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (std::wstring *) &((CNTK::Variable const *)arg1)->Uid(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Variable__Owner(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = ((CNTK::Variable const *)arg1)->Owner(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_Variable__GetDataType(void * jarg1) {
  int jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  CNTK::DataType result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (CNTK::DataType)((CNTK::Variable const *)arg1)->GetDataType(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Variable__NeedsGradient(void * jarg1) {
  unsigned int jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  bool result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (bool)((CNTK::Variable const *)arg1)->NeedsGradient(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Variable_AsString(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  std::wstring result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = ((CNTK::Variable const *)arg1)->AsString(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Variable__CurrentValueTimeStamp(void * jarg1) {
  unsigned long jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  size_t result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = ((CNTK::Variable const *)arg1)->CurrentValueTimeStamp(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Variable_GetValue(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  CNTK::NDArrayViewPtr result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = ((CNTK::Variable const *)arg1)->GetValue(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Variable__SWIG_3(void * jarg1, int jarg2, int jarg3, void * jarg4, unsigned int jarg5, void * jarg6, unsigned int jarg7, wchar_t * jarg8, wchar_t * jarg9) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::VariableKind arg2 ;
  ::CNTK::DataType arg3 ;
  CNTK::NDArrayViewPtr *arg4 = 0 ;
  bool arg5 ;
  std::vector< CNTK::Axis > *arg6 = 0 ;
  bool arg7 ;
  std::wstring *arg8 = 0 ;
  std::wstring *arg9 = 0 ;
  CNTK::NDArrayViewPtr tempnull4 ;
  CNTK::Variable *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::VariableKind)jarg2; 
  arg3 = (::CNTK::DataType)jarg3; 
  arg4 = jarg4 ? (CNTK::NDArrayViewPtr *)jarg4 : &tempnull4; 
  arg5 = jarg5 ? true : false; 
  arg6 = (std::vector< CNTK::Axis > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  if (!jarg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg8_str(jarg8);
  arg8 = &arg8_str; 
  if (!jarg9) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg9_str(jarg9);
  arg9 = &arg9_str; 
  {
    try {
      result = (CNTK::Variable *)new CNTK::Variable((CNTK::NDShape const &)*arg1,arg2,arg3,(CNTK::NDArrayViewPtr const &)*arg4,arg5,(std::vector< CNTK::Axis > const &)*arg6,arg7,(std::wstring const &)*arg8,(std::wstring const &)*arg9); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Variable__GetHashValue(void * jarg1) {
  unsigned long jresult ;
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  size_t result;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      result = (arg1)->GetHashValue(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_Variable(void * jarg1) {
  CNTK::Variable *arg1 = (CNTK::Variable *) 0 ;
  
  arg1 = (CNTK::Variable *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_AreNotEqual__SWIG_3(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  bool result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)CNTK::operator !=((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PlaceholderVariable__SWIG_2(void * jarg1, wchar_t * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  std::vector< CNTK::Axis > *arg3 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (std::vector< CNTK::Axis > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::PlaceholderVariable((CNTK::NDShape const &)*arg1,(std::wstring const &)*arg2,(std::vector< CNTK::Axis > const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PlaceholderVariable__SWIG_3(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::PlaceholderVariable((CNTK::NDShape const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PlaceholderVariable__SWIG_4(void * jarg1) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::PlaceholderVariable((CNTK::NDShape const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PlaceholderVariable__SWIG_5(wchar_t * jarg1) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  CNTK::Variable result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  {
    try {
      result = CNTK::PlaceholderVariable((std::wstring const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PlaceholderVariable__SWIG_6() {
  void * jresult ;
  CNTK::Variable result;
  
  {
    try {
      result = CNTK::PlaceholderVariable(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_2(void * jarg1, int jarg2, unsigned int jarg3, wchar_t * jarg4, void * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  ::CNTK::DataType arg2 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  std::vector< CNTK::Axis > *arg5 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (::CNTK::DataType)jarg2; 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  arg5 = (std::vector< CNTK::Axis > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2,arg3,(std::wstring const &)*arg4,(std::vector< CNTK::Axis > const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_3(void * jarg1, int jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  ::CNTK::DataType arg2 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (::CNTK::DataType)jarg2; 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_4(void * jarg1, int jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  ::CNTK::DataType arg2 ;
  bool arg3 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (::CNTK::DataType)jarg2; 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_5(void * jarg1, int jarg2, wchar_t * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  std::wstring *arg3 = 0 ;
  std::vector< CNTK::Axis > *arg4 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  arg4 = (std::vector< CNTK::Axis > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2,(std::wstring const &)*arg3,(std::vector< CNTK::Axis > const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_6(void * jarg1, int jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  std::wstring *arg3 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_7(void * jarg1, int jarg2, void * jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  std::vector< CNTK::Axis > *arg3 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (std::vector< CNTK::Axis > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2,(std::vector< CNTK::Axis > const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_8(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_9(void * jarg1, unsigned int jarg2, int jarg3, wchar_t * jarg4, void * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  bool arg2 ;
  ::CNTK::DataType arg3 ;
  std::wstring *arg4 = 0 ;
  std::vector< CNTK::Axis > *arg5 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  arg3 = (::CNTK::DataType)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  arg5 = (std::vector< CNTK::Axis > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2,arg3,(std::wstring const &)*arg4,(std::vector< CNTK::Axis > const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_10(void * jarg1, unsigned int jarg2, int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  bool arg2 ;
  ::CNTK::DataType arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  arg3 = (::CNTK::DataType)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_11(void * jarg1, unsigned int jarg2, int jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  bool arg2 ;
  ::CNTK::DataType arg3 ;
  std::vector< CNTK::Axis > *arg4 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  arg3 = (::CNTK::DataType)jarg3; 
  arg4 = (std::vector< CNTK::Axis > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2,arg3,(std::vector< CNTK::Axis > const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_InputVariable__SWIG_12(void * jarg1, unsigned int jarg2, int jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  bool arg2 ;
  ::CNTK::DataType arg3 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  arg3 = (::CNTK::DataType)jarg3; 
  {
    try {
      result = CNTK::InputVariable((CNTK::NDShape const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_OutputVariable__SWIG_2(void * jarg1, int jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  ::CNTK::DataType arg2 ;
  std::vector< CNTK::Axis > *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (::CNTK::DataType)jarg2; 
  arg3 = (std::vector< CNTK::Axis > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::OutputVariable((CNTK::NDShape const &)*arg1,arg2,(std::vector< CNTK::Axis > const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_OutputVariable__SWIG_3(void * jarg1, int jarg2, void * jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  ::CNTK::DataType arg2 ;
  std::vector< CNTK::Axis > *arg3 = 0 ;
  CNTK::Variable result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (::CNTK::DataType)jarg2; 
  arg3 = (std::vector< CNTK::Axis > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::OutputVariable((CNTK::NDShape const &)*arg1,arg2,(std::vector< CNTK::Axis > const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_SentinelValueForInferParamInitRank_get() {
  int jresult ;
  int result;
  
  result = (int)(int)CNTK::SentinelValueForInferParamInitRank;
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_DefaultParamInitScale_get() {
  int jresult ;
  int result;
  
  result = (int)(int)CNTK::DefaultParamInitScale;
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConstantInitializer__SWIG_0(double jarg1) {
  void * jresult ;
  double arg1 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = CNTK::ConstantInitializer(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConstantInitializer__SWIG_1() {
  void * jresult ;
  CNTK::ParameterInitializer result;
  
  {
    try {
      result = CNTK::ConstantInitializer(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UniformInitializer__SWIG_0(double jarg1, unsigned long jarg2) {
  void * jresult ;
  double arg1 ;
  unsigned long arg2 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (unsigned long)jarg2; 
  {
    try {
      result = CNTK::UniformInitializer(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UniformInitializer__SWIG_1(double jarg1) {
  void * jresult ;
  double arg1 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = CNTK::UniformInitializer(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalInitializer__SWIG_0(double jarg1, int jarg2, int jarg3, unsigned long jarg4) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned long arg4 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (unsigned long)jarg4; 
  {
    try {
      result = CNTK::NormalInitializer(arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalInitializer__SWIG_1(double jarg1, int jarg2, int jarg3) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  int arg3 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  {
    try {
      result = CNTK::NormalInitializer(arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalInitializer__SWIG_2(double jarg1, int jarg2) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  {
    try {
      result = CNTK::NormalInitializer(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalInitializer__SWIG_3(double jarg1) {
  void * jresult ;
  double arg1 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = CNTK::NormalInitializer(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_XavierInitializer__SWIG_0(double jarg1, int jarg2, int jarg3, unsigned long jarg4) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned long arg4 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (unsigned long)jarg4; 
  {
    try {
      result = CNTK::XavierInitializer(arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_XavierInitializer__SWIG_1(double jarg1, int jarg2, int jarg3) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  int arg3 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  {
    try {
      result = CNTK::XavierInitializer(arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_XavierInitializer__SWIG_2(double jarg1, int jarg2) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  {
    try {
      result = CNTK::XavierInitializer(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_XavierInitializer__SWIG_3(double jarg1) {
  void * jresult ;
  double arg1 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = CNTK::XavierInitializer(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_XavierInitializer__SWIG_4() {
  void * jresult ;
  CNTK::ParameterInitializer result;
  
  {
    try {
      result = CNTK::XavierInitializer(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GlorotUniformInitializer__SWIG_0(double jarg1, int jarg2, int jarg3, unsigned long jarg4) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned long arg4 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (unsigned long)jarg4; 
  {
    try {
      result = CNTK::GlorotUniformInitializer(arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GlorotUniformInitializer__SWIG_1(double jarg1, int jarg2, int jarg3) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  int arg3 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  {
    try {
      result = CNTK::GlorotUniformInitializer(arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GlorotUniformInitializer__SWIG_2(double jarg1, int jarg2) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  {
    try {
      result = CNTK::GlorotUniformInitializer(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GlorotUniformInitializer__SWIG_3(double jarg1) {
  void * jresult ;
  double arg1 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = CNTK::GlorotUniformInitializer(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GlorotUniformInitializer__SWIG_4() {
  void * jresult ;
  CNTK::ParameterInitializer result;
  
  {
    try {
      result = CNTK::GlorotUniformInitializer(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GlorotNormalInitializer__SWIG_0(double jarg1, int jarg2, int jarg3, unsigned long jarg4) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned long arg4 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (unsigned long)jarg4; 
  {
    try {
      result = CNTK::GlorotNormalInitializer(arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GlorotNormalInitializer__SWIG_1(double jarg1, int jarg2, int jarg3) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  int arg3 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  {
    try {
      result = CNTK::GlorotNormalInitializer(arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GlorotNormalInitializer__SWIG_2(double jarg1, int jarg2) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  {
    try {
      result = CNTK::GlorotNormalInitializer(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GlorotNormalInitializer__SWIG_3(double jarg1) {
  void * jresult ;
  double arg1 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = CNTK::GlorotNormalInitializer(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GlorotNormalInitializer__SWIG_4() {
  void * jresult ;
  CNTK::ParameterInitializer result;
  
  {
    try {
      result = CNTK::GlorotNormalInitializer(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HeUniformInitializer__SWIG_0(double jarg1, int jarg2, int jarg3, unsigned long jarg4) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned long arg4 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (unsigned long)jarg4; 
  {
    try {
      result = CNTK::HeUniformInitializer(arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HeUniformInitializer__SWIG_1(double jarg1, int jarg2, int jarg3) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  int arg3 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  {
    try {
      result = CNTK::HeUniformInitializer(arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HeUniformInitializer__SWIG_2(double jarg1, int jarg2) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  {
    try {
      result = CNTK::HeUniformInitializer(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HeUniformInitializer__SWIG_3(double jarg1) {
  void * jresult ;
  double arg1 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = CNTK::HeUniformInitializer(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HeUniformInitializer__SWIG_4() {
  void * jresult ;
  CNTK::ParameterInitializer result;
  
  {
    try {
      result = CNTK::HeUniformInitializer(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HeNormalInitializer__SWIG_0(double jarg1, int jarg2, int jarg3, unsigned long jarg4) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned long arg4 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (unsigned long)jarg4; 
  {
    try {
      result = CNTK::HeNormalInitializer(arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HeNormalInitializer__SWIG_1(double jarg1, int jarg2, int jarg3) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  int arg3 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  {
    try {
      result = CNTK::HeNormalInitializer(arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HeNormalInitializer__SWIG_2(double jarg1, int jarg2) {
  void * jresult ;
  double arg1 ;
  int arg2 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (int)jarg2; 
  {
    try {
      result = CNTK::HeNormalInitializer(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HeNormalInitializer__SWIG_3(double jarg1) {
  void * jresult ;
  double arg1 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = CNTK::HeNormalInitializer(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HeNormalInitializer__SWIG_4() {
  void * jresult ;
  CNTK::ParameterInitializer result;
  
  {
    try {
      result = CNTK::HeNormalInitializer(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BilinearInitializer(unsigned long jarg1, unsigned long jarg2) {
  void * jresult ;
  size_t arg1 ;
  size_t arg2 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = CNTK::BilinearInitializer(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_RandomInitializerWithRank(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  CNTK::ParameterInitializer *arg1 = 0 ;
  int arg2 ;
  int arg3 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (CNTK::ParameterInitializer *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::ParameterInitializer const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  {
    try {
      result = CNTK::RandomInitializerWithRank((CNTK::Dictionary const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TruncatedNormalInitializer__SWIG_0(double jarg1, unsigned long jarg2) {
  void * jresult ;
  double arg1 ;
  unsigned long arg2 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  arg2 = (unsigned long)jarg2; 
  {
    try {
      result = CNTK::TruncatedNormalInitializer(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TruncatedNormalInitializer__SWIG_1(double jarg1) {
  void * jresult ;
  double arg1 ;
  CNTK::ParameterInitializer result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = CNTK::TruncatedNormalInitializer(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TruncatedNormalInitializer__SWIG_2() {
  void * jresult ;
  CNTK::ParameterInitializer result;
  
  {
    try {
      result = CNTK::TruncatedNormalInitializer(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ParameterInitializer((const CNTK::ParameterInitializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Parameter__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::NDArrayViewPtr *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::NDArrayViewPtr tempnull1 ;
  CNTK::Parameter *result = 0 ;
  
  arg1 = jarg1 ? (CNTK::NDArrayViewPtr *)jarg1 : &tempnull1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = (CNTK::Parameter *)new CNTK::Parameter((CNTK::NDArrayViewPtr const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Parameter__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::NDArrayViewPtr *arg1 = 0 ;
  CNTK::NDArrayViewPtr tempnull1 ;
  CNTK::Parameter *result = 0 ;
  
  arg1 = jarg1 ? (CNTK::NDArrayViewPtr *)jarg1 : &tempnull1; 
  {
    try {
      result = (CNTK::Parameter *)new CNTK::Parameter((CNTK::NDArrayViewPtr const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Parameter__SWIG_5(void * jarg1, int jarg2, double jarg3, void * jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  std::wstring *arg5 = 0 ;
  CNTK::Parameter *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = (CNTK::Parameter *)new CNTK::Parameter((CNTK::NDShape const &)*arg1,arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Parameter__SWIG_6(void * jarg1, int jarg2, double jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::Parameter *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::Parameter *)new CNTK::Parameter((CNTK::NDShape const &)*arg1,arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Parameter__SWIG_7(void * jarg1, int jarg2, double jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  CNTK::Parameter *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  {
    try {
      result = (CNTK::Parameter *)new CNTK::Parameter((CNTK::NDShape const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Parameter__SWIG_8(void * jarg1, int jarg2, void * jarg3, void * jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  CNTK::ParameterInitializer *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  std::wstring *arg5 = 0 ;
  CNTK::Parameter *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (CNTK::ParameterInitializer *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::ParameterInitializer const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = (CNTK::Parameter *)new CNTK::Parameter((CNTK::NDShape const &)*arg1,arg2,(CNTK::ParameterInitializer const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Parameter__SWIG_9(void * jarg1, int jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  CNTK::ParameterInitializer *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::Parameter *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (CNTK::ParameterInitializer *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::ParameterInitializer const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::Parameter *)new CNTK::Parameter((CNTK::NDShape const &)*arg1,arg2,(CNTK::ParameterInitializer const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Parameter__SWIG_10(void * jarg1, int jarg2, void * jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  CNTK::ParameterInitializer *arg3 = 0 ;
  CNTK::Parameter *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (CNTK::ParameterInitializer *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::ParameterInitializer const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::Parameter *)new CNTK::Parameter((CNTK::NDShape const &)*arg1,arg2,(CNTK::ParameterInitializer const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Parameter__SWIG_11(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Parameter *result = 0 ;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::Parameter *)new CNTK::Parameter((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Parameter_Value(void * jarg1) {
  void * jresult ;
  CNTK::Parameter *arg1 = (CNTK::Parameter *) 0 ;
  CNTK::NDArrayViewPtr result;
  
  arg1 = (CNTK::Parameter *)jarg1; 
  {
    try {
      result = ((CNTK::Parameter const *)arg1)->Value(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Parameter_SetValue(void * jarg1, void * jarg2) {
  CNTK::Parameter *arg1 = (CNTK::Parameter *) 0 ;
  CNTK::NDArrayViewPtr *arg2 = 0 ;
  CNTK::NDArrayViewPtr tempnull2 ;
  
  arg1 = (CNTK::Parameter *)jarg1; 
  arg2 = jarg2 ? (CNTK::NDArrayViewPtr *)jarg2 : &tempnull2; 
  {
    try {
      (arg1)->SetValue((CNTK::NDArrayViewPtr const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Parameter_RecordValueUpdate(void * jarg1) {
  CNTK::Parameter *arg1 = (CNTK::Parameter *) 0 ;
  
  arg1 = (CNTK::Parameter *)jarg1; 
  {
    try {
      (arg1)->RecordValueUpdate(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_Parameter(void * jarg1) {
  CNTK::Parameter *arg1 = (CNTK::Parameter *) 0 ;
  
  arg1 = (CNTK::Parameter *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Constant__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::NDArrayViewPtr *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::NDArrayViewPtr tempnull1 ;
  CNTK::Constant *result = 0 ;
  
  arg1 = jarg1 ? (CNTK::NDArrayViewPtr *)jarg1 : &tempnull1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = (CNTK::Constant *)new CNTK::Constant((CNTK::NDArrayViewPtr const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Constant__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::NDArrayViewPtr *arg1 = 0 ;
  CNTK::NDArrayViewPtr tempnull1 ;
  CNTK::Constant *result = 0 ;
  
  arg1 = jarg1 ? (CNTK::NDArrayViewPtr *)jarg1 : &tempnull1; 
  {
    try {
      result = (CNTK::Constant *)new CNTK::Constant((CNTK::NDArrayViewPtr const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Constant__SWIG_5(void * jarg1, int jarg2, double jarg3, void * jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  std::wstring *arg5 = 0 ;
  CNTK::Constant *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = (CNTK::Constant *)new CNTK::Constant((CNTK::NDShape const &)*arg1,arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Constant__SWIG_6(void * jarg1, int jarg2, double jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::Constant *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::Constant *)new CNTK::Constant((CNTK::NDShape const &)*arg1,arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Constant__SWIG_7(void * jarg1, int jarg2, double jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  CNTK::Constant *result = 0 ;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  {
    try {
      result = (CNTK::Constant *)new CNTK::Constant((CNTK::NDShape const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Constant_CloneAs(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::Constant *arg1 = (CNTK::Constant *) 0 ;
  CNTK::DataType arg2 ;
  SwigValueWrapper< CNTK::Constant > result;
  
  arg1 = (CNTK::Constant *)jarg1; 
  arg2 = (CNTK::DataType)jarg2; 
  {
    try {
      result = ((CNTK::Constant const *)arg1)->CloneAs(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Constant((const CNTK::Constant &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Constant_Scalar__SWIG_0(int jarg1, double jarg2, void * jarg3) {
  void * jresult ;
  ::CNTK::DataType arg1 ;
  double arg2 ;
  ::CNTK::DeviceDescriptor *arg3 = 0 ;
  SwigValueWrapper< ::CNTK::Constant > result;
  
  arg1 = (::CNTK::DataType)jarg1; 
  arg2 = (double)jarg2; 
  arg3 = (::CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "::CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Constant::Scalar(arg1,arg2,(::CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new ::CNTK::Constant((const ::CNTK::Constant &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Constant_Scalar__SWIG_1(int jarg1, double jarg2) {
  void * jresult ;
  ::CNTK::DataType arg1 ;
  double arg2 ;
  SwigValueWrapper< ::CNTK::Constant > result;
  
  arg1 = (::CNTK::DataType)jarg1; 
  arg2 = (double)jarg2; 
  {
    try {
      result = CNTK::Constant::Scalar(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new ::CNTK::Constant((const ::CNTK::Constant &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Constant__SWIG_8(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Constant *result = 0 ;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::Constant *)new CNTK::Constant((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Constant_Value(void * jarg1) {
  void * jresult ;
  CNTK::Constant *arg1 = (CNTK::Constant *) 0 ;
  CNTK::NDArrayViewPtr result;
  
  arg1 = (CNTK::Constant *)jarg1; 
  {
    try {
      result = ((CNTK::Constant const *)arg1)->Value(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Constant_SetValue(void * jarg1, void * jarg2) {
  CNTK::Constant *arg1 = (CNTK::Constant *) 0 ;
  CNTK::NDArrayViewPtr *arg2 = 0 ;
  CNTK::NDArrayViewPtr tempnull2 ;
  
  arg1 = (CNTK::Constant *)jarg1; 
  arg2 = jarg2 ? (CNTK::NDArrayViewPtr *)jarg2 : &tempnull2; 
  {
    try {
      (arg1)->SetValue((CNTK::NDArrayViewPtr const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Constant_RecordValueUpdate(void * jarg1) {
  CNTK::Constant *arg1 = (CNTK::Constant *) 0 ;
  
  arg1 = (CNTK::Constant *)jarg1; 
  {
    try {
      (arg1)->RecordValueUpdate(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Constant__ScalarFloat__SWIG_0(float jarg1, void * jarg2) {
  void * jresult ;
  float arg1 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  SwigValueWrapper< CNTK::Constant > result;
  
  arg1 = (float)jarg1; 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Constant_ScalarFloat__SWIG_0(arg1,(CNTK::DeviceDescriptor const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Constant((const CNTK::Constant &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Constant__ScalarFloat__SWIG_1(float jarg1) {
  void * jresult ;
  float arg1 ;
  SwigValueWrapper< CNTK::Constant > result;
  
  arg1 = (float)jarg1; 
  {
    try {
      result = CNTK_Constant_ScalarFloat__SWIG_0(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Constant((const CNTK::Constant &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Constant__ScalarDouble__SWIG_0(double jarg1, void * jarg2) {
  void * jresult ;
  double arg1 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  SwigValueWrapper< CNTK::Constant > result;
  
  arg1 = (double)jarg1; 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Constant_ScalarDouble__SWIG_0(arg1,(CNTK::DeviceDescriptor const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Constant((const CNTK::Constant &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Constant__ScalarDouble__SWIG_1(double jarg1) {
  void * jresult ;
  double arg1 ;
  SwigValueWrapper< CNTK::Constant > result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = CNTK_Constant_ScalarDouble__SWIG_0(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Constant((const CNTK::Constant &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_Constant(void * jarg1) {
  CNTK::Constant *arg1 = (CNTK::Constant *) 0 ;
  
  arg1 = (CNTK::Constant *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Value_OneHotSkip_get() {
  unsigned long jresult ;
  size_t result;
  
  result = CNTK::Value::OneHotSkip;
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Value__SWIG_0(void * jarg1) {
  void * jresult ;
  CNTK::NDArrayViewPtr *arg1 = 0 ;
  CNTK::NDArrayViewPtr tempnull1 ;
  CNTK::Value *result = 0 ;
  
  arg1 = jarg1 ? (CNTK::NDArrayViewPtr *)jarg1 : &tempnull1; 
  {
    try {
      result = (CNTK::Value *)new CNTK::Value((CNTK::NDArrayViewPtr const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::Value >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_Value__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::NDArrayViewPtr *arg1 = 0 ;
  CNTK::NDMaskPtr *arg2 = 0 ;
  CNTK::NDArrayViewPtr tempnull1 ;
  CNTK::NDMaskPtr tempnull2 ;
  CNTK::Value *result = 0 ;
  
  arg1 = jarg1 ? (CNTK::NDArrayViewPtr *)jarg1 : &tempnull1; 
  arg2 = jarg2 ? (CNTK::NDMaskPtr *)jarg2 : &tempnull2; 
  {
    try {
      result = (CNTK::Value *)new CNTK::Value((CNTK::NDArrayViewPtr const &)*arg1,(CNTK::NDMaskPtr const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::Value >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__Create__SWIG_4(void * jarg1, void * jarg2, void * jarg3, void * jarg4, unsigned int jarg5, unsigned int jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< CNTK::NDArrayViewPtr > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  bool arg6 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::NDArrayViewPtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::NDArrayViewPtr > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  arg6 = jarg6 ? true : false; 
  {
    try {
      result = CNTK::Value::Create((CNTK::NDShape const &)*arg1,(std::vector< std::shared_ptr< CNTK::NDArrayView > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__Create__SWIG_5(void * jarg1, void * jarg2, void * jarg3, void * jarg4, unsigned int jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< CNTK::NDArrayViewPtr > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::NDArrayViewPtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::NDArrayViewPtr > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = CNTK::Value::Create((CNTK::NDShape const &)*arg1,(std::vector< std::shared_ptr< CNTK::NDArrayView > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__Create__SWIG_6(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< CNTK::NDArrayViewPtr > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::NDArrayViewPtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::NDArrayViewPtr > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Value::Create((CNTK::NDShape const &)*arg1,(std::vector< std::shared_ptr< CNTK::NDArrayView > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__Create__SWIG_7(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< CNTK::NDArrayViewPtr > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  bool arg4 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::NDArrayViewPtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::NDArrayViewPtr > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK::Value::Create((CNTK::NDShape const &)*arg1,(std::vector< std::shared_ptr< CNTK::NDArrayView > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__Create__SWIG_8(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< CNTK::NDArrayViewPtr > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::NDArrayViewPtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::NDArrayViewPtr > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Value::Create((CNTK::NDShape const &)*arg1,(std::vector< std::shared_ptr< CNTK::NDArrayView > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_Value(void * jarg1) {
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (void)arg1; delete smartarg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__Device(void * jarg1) {
  void * jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  SwigValueWrapper< CNTK::DeviceDescriptor > result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Value const *)arg1)->Device(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::DeviceDescriptor((const CNTK::DeviceDescriptor &)result); 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_Value__GetDataType(void * jarg1) {
  int jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  CNTK::DataType result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (CNTK::DataType)((CNTK::Value const *)arg1)->GetDataType(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_Value__GetStorageFormat(void * jarg1) {
  int jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  CNTK::StorageFormat result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (CNTK::StorageFormat)((CNTK::Value const *)arg1)->GetStorageFormat(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__Shape(void * jarg1) {
  void * jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  CNTK::NDShape *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (CNTK::NDShape *) &((CNTK::Value const *)arg1)->Shape(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::shared_ptr< const CNTK::NDShape >(result SWIG_NO_NULL_DELETER_0); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Value__IsSparse(void * jarg1) {
  unsigned int jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::Value const *)arg1)->IsSparse(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Value__IsReadOnly(void * jarg1) {
  unsigned int jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::Value const *)arg1)->IsReadOnly(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Value__MaskedCount(void * jarg1) {
  unsigned long jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Value const *)arg1)->MaskedCount(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__Data(void * jarg1) {
  void * jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  CNTK::NDArrayViewPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Value const *)arg1)->Data(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDArrayViewPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__Mask(void * jarg1) {
  void * jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  CNTK::NDMaskPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Value const *)arg1)->Mask(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::NDMaskPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value_DeepClone__SWIG_0(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  bool arg2 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  CNTK::ValuePtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = ((CNTK::Value const *)arg1)->DeepClone(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value_DeepClone__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  CNTK::ValuePtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Value const *)arg1)->DeepClone(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__Alias__SWIG_0(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  bool arg2 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  CNTK::ValuePtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = ((CNTK::Value const *)arg1)->Alias(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__Alias__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  CNTK::ValuePtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Value const *)arg1)->Alias(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Value_CopyFrom(void * jarg1, void * jarg2) {
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  CNTK::Value *arg2 = 0 ;
  std::shared_ptr< CNTK::Value > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  
  arg2 = (CNTK::Value *)(((std::shared_ptr< const CNTK::Value > *)jarg2) ? ((std::shared_ptr< const CNTK::Value > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Value const & reference is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->CopyFrom((CNTK::Value const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Value_Erase(void * jarg1) {
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (arg1)->Erase(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Value__CopyVariableValueTo(void * jarg1, void * jarg2, void * jarg3) {
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::vector< std::vector< size_t > > *arg3 = 0 ;
  std::shared_ptr< CNTK::Value > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return ;
  } 
  arg3 = (std::vector< std::vector< size_t > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->CopyVariableValueTo((CNTK::Variable const &)*arg2,*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Value__IsValid(void * jarg1) {
  unsigned int jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::Value const *)arg1)->IsValid(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value_AsString(void * jarg1) {
  void * jresult ;
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  std::shared_ptr< CNTK::Value const > *smartarg1 = 0 ;
  std::wstring result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Value const *)arg1)->AsString(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateDenseFloat__SWIG_0(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< float > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  bool arg4 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< float > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateDenseFloat__SWIG_0((CNTK::NDShape const &)*arg1,(std::vector< std::vector< float > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateDenseFloat__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< float > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< float > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateDenseFloat__SWIG_0((CNTK::NDShape const &)*arg1,(std::vector< std::vector< float > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateDenseDouble__SWIG_0(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< double > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  bool arg4 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< double > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateDenseDouble__SWIG_0((CNTK::NDShape const &)*arg1,(std::vector< std::vector< double > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateDenseDouble__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< double > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< double > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateDenseDouble__SWIG_0((CNTK::NDShape const &)*arg1,(std::vector< std::vector< double > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateDenseFloat__SWIG_2(void * jarg1, void * jarg2, void * jarg3, void * jarg4, unsigned int jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< float > > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< float > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateDenseFloat__SWIG_2((CNTK::NDShape const &)*arg1,(std::vector< std::vector< float > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateDenseFloat__SWIG_3(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< float > > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< float > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateDenseFloat__SWIG_2((CNTK::NDShape const &)*arg1,(std::vector< std::vector< float > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateDenseDouble__SWIG_2(void * jarg1, void * jarg2, void * jarg3, void * jarg4, unsigned int jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< double > > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< double > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateDenseDouble__SWIG_2((CNTK::NDShape const &)*arg1,(std::vector< std::vector< double > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateDenseDouble__SWIG_3(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< double > > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< double > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateDenseDouble__SWIG_2((CNTK::NDShape const &)*arg1,(std::vector< std::vector< double > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateBatchFloat__SWIG_0(void * jarg1, float* jarg2, int jarg3, int jarg4, void * jarg5, unsigned int jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  float *arg2 = (float *) 0 ;
  int arg3 ;
  int arg4 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  bool arg6 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = (int)jarg3; 
  arg4 = (int)jarg4; 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg6 = jarg6 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateBatchFloat__SWIG_0((CNTK::NDShape const &)*arg1,(float const *)arg2,arg3,arg4,(CNTK::DeviceDescriptor const &)*arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateBatchFloat__SWIG_1(void * jarg1, float* jarg2, int jarg3, int jarg4, void * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  float *arg2 = (float *) 0 ;
  int arg3 ;
  int arg4 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = (int)jarg3; 
  arg4 = (int)jarg4; 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateBatchFloat__SWIG_0((CNTK::NDShape const &)*arg1,(float const *)arg2,arg3,arg4,(CNTK::DeviceDescriptor const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateBatchDouble__SWIG_0(void * jarg1, double* jarg2, int jarg3, int jarg4, void * jarg5, unsigned int jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  int arg4 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  bool arg6 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = (int)jarg3; 
  arg4 = (int)jarg4; 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg6 = jarg6 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateBatchDouble__SWIG_0((CNTK::NDShape const &)*arg1,(double const *)arg2,arg3,arg4,(CNTK::DeviceDescriptor const &)*arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateBatchDouble__SWIG_1(void * jarg1, double* jarg2, int jarg3, int jarg4, void * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  int arg4 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = (int)jarg3; 
  arg4 = (int)jarg4; 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateBatchDouble__SWIG_0((CNTK::NDShape const &)*arg1,(double const *)arg2,arg3,arg4,(CNTK::DeviceDescriptor const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceFloat__SWIG_0(void * jarg1, float* jarg2, int jarg3, unsigned int jarg4, void * jarg5, unsigned int jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  float *arg2 = (float *) 0 ;
  int arg3 ;
  bool arg4 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  bool arg6 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = (int)jarg3; 
  arg4 = jarg4 ? true : false; 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg6 = jarg6 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateSequenceFloat__SWIG_0((CNTK::NDShape const &)*arg1,(float const *)arg2,arg3,arg4,(CNTK::DeviceDescriptor const &)*arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceFloat__SWIG_1(void * jarg1, float* jarg2, int jarg3, unsigned int jarg4, void * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  float *arg2 = (float *) 0 ;
  int arg3 ;
  bool arg4 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = (int)jarg3; 
  arg4 = jarg4 ? true : false; 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateSequenceFloat__SWIG_0((CNTK::NDShape const &)*arg1,(float const *)arg2,arg3,arg4,(CNTK::DeviceDescriptor const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceDouble__SWIG_0(void * jarg1, double* jarg2, int jarg3, unsigned int jarg4, void * jarg5, unsigned int jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  bool arg4 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  bool arg6 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = (int)jarg3; 
  arg4 = jarg4 ? true : false; 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg6 = jarg6 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateSequenceDouble__SWIG_0((CNTK::NDShape const &)*arg1,(double const *)arg2,arg3,arg4,(CNTK::DeviceDescriptor const &)*arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceDouble__SWIG_1(void * jarg1, double* jarg2, int jarg3, unsigned int jarg4, void * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  bool arg4 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = jarg2;
  arg3 = (int)jarg3; 
  arg4 = jarg4 ? true : false; 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateSequenceDouble__SWIG_0((CNTK::NDShape const &)*arg1,(double const *)arg2,arg3,arg4,(CNTK::DeviceDescriptor const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotFloat__SWIG_0(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  bool arg4 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateOneHotFloat__SWIG_0((CNTK::NDShape const &)*arg1,(std::vector< std::vector< size_t > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotFloat__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateOneHotFloat__SWIG_0((CNTK::NDShape const &)*arg1,(std::vector< std::vector< size_t > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotDouble__SWIG_0(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  bool arg4 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateOneHotDouble__SWIG_0((CNTK::NDShape const &)*arg1,(std::vector< std::vector< size_t > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotDouble__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateOneHotDouble__SWIG_0((CNTK::NDShape const &)*arg1,(std::vector< std::vector< size_t > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotFloat__SWIG_2(void * jarg1, void * jarg2, void * jarg3, void * jarg4, unsigned int jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateOneHotFloat__SWIG_2((CNTK::NDShape const &)*arg1,(std::vector< std::vector< size_t > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotFloat__SWIG_3(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateOneHotFloat__SWIG_2((CNTK::NDShape const &)*arg1,(std::vector< std::vector< size_t > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotDouble__SWIG_2(void * jarg1, void * jarg2, void * jarg3, void * jarg4, unsigned int jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateOneHotDouble__SWIG_2((CNTK::NDShape const &)*arg1,(std::vector< std::vector< size_t > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotDouble__SWIG_3(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateOneHotDouble__SWIG_2((CNTK::NDShape const &)*arg1,(std::vector< std::vector< size_t > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotFloat__SWIG_4(unsigned long jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  size_t arg1 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  bool arg4 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateOneHotFloat__SWIG_4(arg1,(std::vector< std::vector< size_t > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotFloat__SWIG_5(unsigned long jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  size_t arg1 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateOneHotFloat__SWIG_4(arg1,(std::vector< std::vector< size_t > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotDouble__SWIG_4(unsigned long jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  size_t arg1 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  bool arg4 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateOneHotDouble__SWIG_4(arg1,(std::vector< std::vector< size_t > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotDouble__SWIG_5(unsigned long jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  size_t arg1 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateOneHotDouble__SWIG_4(arg1,(std::vector< std::vector< size_t > > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotFloat__SWIG_6(unsigned long jarg1, void * jarg2, void * jarg3, void * jarg4, unsigned int jarg5) {
  void * jresult ;
  size_t arg1 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateOneHotFloat__SWIG_6(arg1,(std::vector< std::vector< size_t > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotFloat__SWIG_7(unsigned long jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  size_t arg1 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateOneHotFloat__SWIG_6(arg1,(std::vector< std::vector< size_t > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotDouble__SWIG_6(unsigned long jarg1, void * jarg2, void * jarg3, void * jarg4, unsigned int jarg5) {
  void * jresult ;
  size_t arg1 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateOneHotDouble__SWIG_6(arg1,(std::vector< std::vector< size_t > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateOneHotDouble__SWIG_7(unsigned long jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  size_t arg1 ;
  std::vector< std::vector< size_t > > *arg2 = 0 ;
  std::vector< bool > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< std::vector< size_t > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< size_t > > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< bool > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateOneHotDouble__SWIG_6(arg1,(std::vector< std::vector< size_t > > const &)*arg2,(std::vector< bool > const &)*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateBatchFloat__SWIG_2(unsigned long jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  size_t arg1 ;
  std::vector< size_t > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  bool arg4 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateBatchFloat__SWIG_2(arg1,(std::vector< size_t > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateBatchFloat__SWIG_3(unsigned long jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  size_t arg1 ;
  std::vector< size_t > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateBatchFloat__SWIG_2(arg1,(std::vector< size_t > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateBatchDouble__SWIG_2(unsigned long jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  size_t arg1 ;
  std::vector< size_t > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  bool arg4 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateBatchDouble__SWIG_2(arg1,(std::vector< size_t > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateBatchDouble__SWIG_3(unsigned long jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  size_t arg1 ;
  std::vector< size_t > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateBatchDouble__SWIG_2(arg1,(std::vector< size_t > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceFloat__SWIG_2(unsigned long jarg1, void * jarg2, unsigned int jarg3, void * jarg4, unsigned int jarg5) {
  void * jresult ;
  size_t arg1 ;
  std::vector< size_t > *arg2 = 0 ;
  bool arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateSequenceFloat__SWIG_2(arg1,(std::vector< size_t > const &)*arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceFloat__SWIG_3(unsigned long jarg1, void * jarg2, unsigned int jarg3, void * jarg4) {
  void * jresult ;
  size_t arg1 ;
  std::vector< size_t > *arg2 = 0 ;
  bool arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateSequenceFloat__SWIG_2(arg1,(std::vector< size_t > const &)*arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceDouble__SWIG_2(unsigned long jarg1, void * jarg2, unsigned int jarg3, void * jarg4, unsigned int jarg5) {
  void * jresult ;
  size_t arg1 ;
  std::vector< size_t > *arg2 = 0 ;
  bool arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateSequenceDouble__SWIG_2(arg1,(std::vector< size_t > const &)*arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceDouble__SWIG_3(unsigned long jarg1, void * jarg2, unsigned int jarg3, void * jarg4) {
  void * jresult ;
  size_t arg1 ;
  std::vector< size_t > *arg2 = 0 ;
  bool arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (std::vector< size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateSequenceDouble__SWIG_2(arg1,(std::vector< size_t > const &)*arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceFloat__SWIG_4(void * jarg1, unsigned long jarg2, int* jarg3, int* jarg4, float* jarg5, unsigned long jarg6, unsigned int jarg7, void * jarg8, unsigned int jarg9) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  size_t arg2 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg4 = (CNTK::SparseIndexType *) 0 ;
  float *arg5 = (float *) 0 ;
  size_t arg6 ;
  bool arg7 ;
  CNTK::DeviceDescriptor *arg8 = 0 ;
  bool arg9 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = jarg5;
  arg6 = (size_t)jarg6; 
  arg7 = jarg7 ? true : false; 
  arg8 = (CNTK::DeviceDescriptor *)jarg8;
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg9 = jarg9 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateSequenceFloat__SWIG_4((CNTK::NDShape const &)*arg1,arg2,(int const *)arg3,(int const *)arg4,(float const *)arg5,arg6,arg7,(CNTK::DeviceDescriptor const &)*arg8,arg9); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceFloat__SWIG_5(void * jarg1, unsigned long jarg2, int* jarg3, int* jarg4, float* jarg5, unsigned long jarg6, unsigned int jarg7, void * jarg8) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  size_t arg2 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg4 = (CNTK::SparseIndexType *) 0 ;
  float *arg5 = (float *) 0 ;
  size_t arg6 ;
  bool arg7 ;
  CNTK::DeviceDescriptor *arg8 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = jarg5;
  arg6 = (size_t)jarg6; 
  arg7 = jarg7 ? true : false; 
  arg8 = (CNTK::DeviceDescriptor *)jarg8;
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateSequenceFloat__SWIG_4((CNTK::NDShape const &)*arg1,arg2,(int const *)arg3,(int const *)arg4,(float const *)arg5,arg6,arg7,(CNTK::DeviceDescriptor const &)*arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceDouble__SWIG_4(void * jarg1, unsigned long jarg2, int* jarg3, int* jarg4, double* jarg5, unsigned long jarg6, unsigned int jarg7, void * jarg8, unsigned int jarg9) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  size_t arg2 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg4 = (CNTK::SparseIndexType *) 0 ;
  double *arg5 = (double *) 0 ;
  size_t arg6 ;
  bool arg7 ;
  CNTK::DeviceDescriptor *arg8 = 0 ;
  bool arg9 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = jarg5;
  arg6 = (size_t)jarg6; 
  arg7 = jarg7 ? true : false; 
  arg8 = (CNTK::DeviceDescriptor *)jarg8;
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg9 = jarg9 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateSequenceDouble__SWIG_4((CNTK::NDShape const &)*arg1,arg2,(int const *)arg3,(int const *)arg4,(double const *)arg5,arg6,arg7,(CNTK::DeviceDescriptor const &)*arg8,arg9); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceDouble__SWIG_5(void * jarg1, unsigned long jarg2, int* jarg3, int* jarg4, double* jarg5, unsigned long jarg6, unsigned int jarg7, void * jarg8) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  size_t arg2 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg4 = (CNTK::SparseIndexType *) 0 ;
  double *arg5 = (double *) 0 ;
  size_t arg6 ;
  bool arg7 ;
  CNTK::DeviceDescriptor *arg8 = 0 ;
  CNTK::ValuePtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = jarg5;
  arg6 = (size_t)jarg6; 
  arg7 = jarg7 ? true : false; 
  arg8 = (CNTK::DeviceDescriptor *)jarg8;
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateSequenceDouble__SWIG_4((CNTK::NDShape const &)*arg1,arg2,(int const *)arg3,(int const *)arg4,(double const *)arg5,arg6,arg7,(CNTK::DeviceDescriptor const &)*arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceFloat__SWIG_6(unsigned long jarg1, unsigned long jarg2, int* jarg3, int* jarg4, float* jarg5, unsigned long jarg6, unsigned int jarg7, void * jarg8, unsigned int jarg9) {
  void * jresult ;
  size_t arg1 ;
  size_t arg2 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg4 = (CNTK::SparseIndexType *) 0 ;
  float *arg5 = (float *) 0 ;
  size_t arg6 ;
  bool arg7 ;
  CNTK::DeviceDescriptor *arg8 = 0 ;
  bool arg9 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = jarg5;
  arg6 = (size_t)jarg6; 
  arg7 = jarg7 ? true : false; 
  arg8 = (CNTK::DeviceDescriptor *)jarg8;
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg9 = jarg9 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateSequenceFloat__SWIG_6(arg1,arg2,(int const *)arg3,(int const *)arg4,(float const *)arg5,arg6,arg7,(CNTK::DeviceDescriptor const &)*arg8,arg9); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceFloat__SWIG_7(unsigned long jarg1, unsigned long jarg2, int* jarg3, int* jarg4, float* jarg5, unsigned long jarg6, unsigned int jarg7, void * jarg8) {
  void * jresult ;
  size_t arg1 ;
  size_t arg2 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg4 = (CNTK::SparseIndexType *) 0 ;
  float *arg5 = (float *) 0 ;
  size_t arg6 ;
  bool arg7 ;
  CNTK::DeviceDescriptor *arg8 = 0 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = jarg5;
  arg6 = (size_t)jarg6; 
  arg7 = jarg7 ? true : false; 
  arg8 = (CNTK::DeviceDescriptor *)jarg8;
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateSequenceFloat__SWIG_6(arg1,arg2,(int const *)arg3,(int const *)arg4,(float const *)arg5,arg6,arg7,(CNTK::DeviceDescriptor const &)*arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceDouble__SWIG_6(unsigned long jarg1, unsigned long jarg2, int* jarg3, int* jarg4, double* jarg5, unsigned long jarg6, unsigned int jarg7, void * jarg8, unsigned int jarg9) {
  void * jresult ;
  size_t arg1 ;
  size_t arg2 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg4 = (CNTK::SparseIndexType *) 0 ;
  double *arg5 = (double *) 0 ;
  size_t arg6 ;
  bool arg7 ;
  CNTK::DeviceDescriptor *arg8 = 0 ;
  bool arg9 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = jarg5;
  arg6 = (size_t)jarg6; 
  arg7 = jarg7 ? true : false; 
  arg8 = (CNTK::DeviceDescriptor *)jarg8;
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg9 = jarg9 ? true : false; 
  {
    try {
      result = CNTK_Value_CreateSequenceDouble__SWIG_6(arg1,arg2,(int const *)arg3,(int const *)arg4,(double const *)arg5,arg6,arg7,(CNTK::DeviceDescriptor const &)*arg8,arg9); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Value__CreateSequenceDouble__SWIG_7(unsigned long jarg1, unsigned long jarg2, int* jarg3, int* jarg4, double* jarg5, unsigned long jarg6, unsigned int jarg7, void * jarg8) {
  void * jresult ;
  size_t arg1 ;
  size_t arg2 ;
  CNTK::SparseIndexType *arg3 = (CNTK::SparseIndexType *) 0 ;
  CNTK::SparseIndexType *arg4 = (CNTK::SparseIndexType *) 0 ;
  double *arg5 = (double *) 0 ;
  size_t arg6 ;
  bool arg7 ;
  CNTK::DeviceDescriptor *arg8 = 0 ;
  CNTK::ValuePtr result;
  
  arg1 = (size_t)jarg1; 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3;
  arg4 = jarg4;
  arg5 = jarg5;
  arg6 = (size_t)jarg6; 
  arg7 = jarg7 ? true : false; 
  arg8 = (CNTK::DeviceDescriptor *)jarg8;
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_Value_CreateSequenceDouble__SWIG_6(arg1,arg2,(int const *)arg3,(int const *)arg4,(double const *)arg5,arg6,arg7,(CNTK::DeviceDescriptor const &)*arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::ValuePtr(result) : 0; 
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Value__CopyVariableValueToFloat__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::vector< std::vector< float > > *arg3 = 0 ;
  std::shared_ptr< CNTK::Value > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return ;
  } 
  arg3 = (std::vector< std::vector< float > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > & type is null", 0);
    return ;
  } 
  {
    try {
      CNTK_Value_CopyVariableValueToFloat__SWIG_0(arg1,(CNTK::Variable const &)*arg2,*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Value__CopyVariableValueToDouble__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::vector< std::vector< double > > *arg3 = 0 ;
  std::shared_ptr< CNTK::Value > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return ;
  } 
  arg3 = (std::vector< std::vector< double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > & type is null", 0);
    return ;
  } 
  {
    try {
      CNTK_Value_CopyVariableValueToDouble__SWIG_0(arg1,(CNTK::Variable const &)*arg2,*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Value__CopyVariableValueToFloat__SWIG_1(void * jarg1, void * jarg2, int* jarg3, void * jarg4, void * jarg5, void * jarg6, int* jarg7) {
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  CNTK::Variable *arg2 = 0 ;
  int *arg3 = (int *) 0 ;
  std::vector< CNTK::SparseIndexType > *arg4 = 0 ;
  std::vector< CNTK::SparseIndexType > *arg5 = 0 ;
  std::vector< float > *arg6 = 0 ;
  int *arg7 = (int *) 0 ;
  std::shared_ptr< CNTK::Value > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return ;
  } 
  arg3 = jarg3;
  arg4 = (std::vector< CNTK::SparseIndexType > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::SparseIndexType > & type is null", 0);
    return ;
  } 
  arg5 = (std::vector< CNTK::SparseIndexType > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::SparseIndexType > & type is null", 0);
    return ;
  } 
  
  arg6 = (std::vector< float > *)(((std::shared_ptr<  std::vector<float> > *)jarg6) ? ((std::shared_ptr<  std::vector<float> > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > & reference is null", 0);
    return ;
  } 
  arg7 = jarg7;
  {
    try {
      CNTK_Value_CopyVariableValueToFloat__SWIG_1(arg1,(CNTK::Variable const &)*arg2,arg3,*arg4,*arg5,*arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
  
  
  
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Value__CopyVariableValueToDouble__SWIG_1(void * jarg1, void * jarg2, int* jarg3, void * jarg4, void * jarg5, void * jarg6, int* jarg7) {
  CNTK::Value *arg1 = (CNTK::Value *) 0 ;
  CNTK::Variable *arg2 = 0 ;
  int *arg3 = (int *) 0 ;
  std::vector< CNTK::SparseIndexType > *arg4 = 0 ;
  std::vector< CNTK::SparseIndexType > *arg5 = 0 ;
  std::vector< double > *arg6 = 0 ;
  int *arg7 = (int *) 0 ;
  std::shared_ptr< CNTK::Value > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Value > *)jarg1;
  arg1 = (CNTK::Value *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return ;
  } 
  arg3 = jarg3;
  arg4 = (std::vector< CNTK::SparseIndexType > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::SparseIndexType > & type is null", 0);
    return ;
  } 
  arg5 = (std::vector< CNTK::SparseIndexType > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::SparseIndexType > & type is null", 0);
    return ;
  } 
  arg6 = (std::vector< double > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > & type is null", 0);
    return ;
  } 
  arg7 = jarg7;
  {
    try {
      CNTK_Value_CopyVariableValueToDouble__SWIG_1(arg1,(CNTK::Variable const &)*arg2,arg3,*arg4,*arg5,*arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
  
  
  
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Function_PrintNodeTiming(void * jarg1) {
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (arg1)->PrintNodeTiming(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_Function(void * jarg1) {
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (void)arg1; delete smartarg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__OpName(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::wstring *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (std::wstring *) &((CNTK::Function const *)arg1)->OpName(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Function__CurrentVersion(void * jarg1) {
  unsigned long jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->CurrentVersion(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Clone__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::vector< CNTK::Variable > *arg2 = 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::vector< CNTK::Variable > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (arg1)->Clone((std::vector< CNTK::Variable > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Function__Evaluate__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const & type is null", 0);
    return ;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > & type is null", 0);
    return ;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->Evaluate((std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const &)*arg2,*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Function__Evaluate__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg3 = 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const & type is null", 0);
    return ;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->Evaluate((std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const &)*arg2,*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Clone__SWIG_1(void * jarg1, int jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  CNTK::ParameterCloningMethod arg2 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg3 = 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::ParameterCloningMethod)jarg2; 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = ((CNTK::Function const *)arg1)->Clone(arg2,(std::unordered_map< CNTK::Variable,CNTK::Variable > const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Clone__SWIG_2(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  CNTK::ParameterCloningMethod arg2 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::ParameterCloningMethod)jarg2; 
  {
    try {
      result = ((CNTK::Function const *)arg1)->Clone(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Clone__SWIG_3(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->Clone(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function_CloneFlattened__SWIG_0(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  CNTK::ParameterCloningMethod arg2 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::ParameterCloningMethod)jarg2; 
  {
    try {
      result = ((CNTK::Function const *)arg1)->CloneFlattened(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function_CloneFlattened__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->CloneFlattened(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Name(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::wstring *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (std::wstring *) &((CNTK::Function const *)arg1)->Name(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Function_SetName(void * jarg1, wchar_t * jarg2) {
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::wstring *arg2 = 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      (arg1)->SetName((std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Uid(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::wstring *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (std::wstring *) &((CNTK::Function const *)arg1)->Uid(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__RootFunction(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->RootFunction(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Function__IsComposite(void * jarg1) {
  unsigned int jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::Function const *)arg1)->IsComposite(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Function__IsPrimitive(void * jarg1) {
  unsigned int jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::Function const *)arg1)->IsPrimitive(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Function__IsBlock(void * jarg1) {
  unsigned int jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::Function const *)arg1)->IsBlock(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function_BlockRoot(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->BlockRoot(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function_BlockArgumentsMapping(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::vector< std::pair< CNTK::Variable,CNTK::Variable > > result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->BlockArgumentsMapping(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::vector< std::pair< CNTK::Variable,CNTK::Variable > >((const std::vector< std::pair< CNTK::Variable,CNTK::Variable > > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Inputs__SWIG_0(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  bool arg2 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::vector< CNTK::Variable > result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = ((CNTK::Function const *)arg1)->Inputs(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::vector< CNTK::Variable >((const std::vector< CNTK::Variable > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Inputs__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::vector< CNTK::Variable > result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->Inputs(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::vector< CNTK::Variable >((const std::vector< CNTK::Variable > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Output(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  CNTK::Variable result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->Output(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Variable((const CNTK::Variable &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Outputs(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::vector< CNTK::Variable > result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->Outputs(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::vector< CNTK::Variable >((const std::vector< CNTK::Variable > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Arguments__SWIG_0(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  bool arg2 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::vector< CNTK::Variable > result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = ((CNTK::Function const *)arg1)->Arguments(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::vector< CNTK::Variable >((const std::vector< CNTK::Variable > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Arguments__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::vector< CNTK::Variable > result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->Arguments(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::vector< CNTK::Variable >((const std::vector< CNTK::Variable > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Parameters(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::vector< CNTK::Parameter > result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->Parameters(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::vector< CNTK::Parameter >((const std::vector< CNTK::Parameter > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function_Constants(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::vector< CNTK::Constant > result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->Constants(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::vector< CNTK::Constant >((const std::vector< CNTK::Constant > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function_Placeholders(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::vector< CNTK::Variable > result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->Placeholders(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::vector< CNTK::Variable >((const std::vector< CNTK::Variable > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__FindByName__SWIG_0(void * jarg1, wchar_t * jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::wstring *arg2 = 0 ;
  bool arg3 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = (arg1)->FindByName((std::wstring const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__FindByName__SWIG_1(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::wstring *arg2 = 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = (arg1)->FindByName((std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__FindAllWithName__SWIG_0(void * jarg1, wchar_t * jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::wstring *arg2 = 0 ;
  bool arg3 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  std::vector< CNTK::FunctionPtr > result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = (arg1)->FindAllWithName((std::wstring const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::vector< CNTK::FunctionPtr >((const std::vector< CNTK::FunctionPtr > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__FindAllWithName__SWIG_1(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::wstring *arg2 = 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  std::vector< CNTK::FunctionPtr > result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = (arg1)->FindAllWithName((std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new std::vector< CNTK::FunctionPtr >((const std::vector< CNTK::FunctionPtr > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function_Attributes(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  CNTK::Dictionary *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (CNTK::Dictionary *) &((CNTK::Function const *)arg1)->Attributes(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function_ReplacePlaceholders(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::Variable > *arg2 = 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::Variable > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (arg1)->ReplacePlaceholders((std::unordered_map< CNTK::Variable,CNTK::Variable > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function_ReplacePlaceholder(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (arg1)->ReplacePlaceholder((CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Function__Save__SWIG_0(void * jarg1, void * jarg2) {
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::vector< unsigned char > *arg2 = 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::vector< unsigned char > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< unsigned char > & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->Save(*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Function__Save__SWIG_1(void * jarg1, wchar_t * jarg2, int jarg3, unsigned int jarg4) {
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::ModelFormat arg3 ;
  bool arg4 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (CNTK::ModelFormat)jarg3; 
  arg4 = jarg4 ? true : false; 
  {
    try {
      (arg1)->Save((std::wstring const &)*arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Function__Save__SWIG_2(void * jarg1, wchar_t * jarg2, int jarg3) {
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::ModelFormat arg3 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (CNTK::ModelFormat)jarg3; 
  {
    try {
      (arg1)->Save((std::wstring const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Function__Save__SWIG_3(void * jarg1, wchar_t * jarg2) {
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::wstring *arg2 = 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      (arg1)->Save((std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Function_Restore(void * jarg1, wchar_t * jarg2) {
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::wstring *arg2 = 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      (arg1)->Restore((std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Load__SWIG_0(wchar_t * jarg1, void * jarg2, int jarg3) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  CNTK::ModelFormat arg3 ;
  CNTK::FunctionPtr result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::ModelFormat)jarg3; 
  {
    try {
      result = CNTK::Function::Load((std::wstring const &)*arg1,(CNTK::DeviceDescriptor const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Load__SWIG_1(wchar_t * jarg1, void * jarg2) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  CNTK::DeviceDescriptor *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (CNTK::DeviceDescriptor *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Function::Load((std::wstring const &)*arg1,(CNTK::DeviceDescriptor const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Load__SWIG_2(wchar_t * jarg1) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  {
    try {
      result = CNTK::Function::Load((std::wstring const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Load__SWIG_3(char* jarg1, unsigned long jarg2, void * jarg3, int jarg4) {
  void * jresult ;
  char *arg1 = (char *) 0 ;
  size_t arg2 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::ModelFormat arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (char *)jarg1; 
  arg2 = (size_t)jarg2; 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::ModelFormat)jarg4; 
  {
    try {
      result = CNTK::Function::Load((char const *)arg1,arg2,(CNTK::DeviceDescriptor const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Load__SWIG_4(char* jarg1, unsigned long jarg2, void * jarg3) {
  void * jresult ;
  char *arg1 = (char *) 0 ;
  size_t arg2 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (char *)jarg1; 
  arg2 = (size_t)jarg2; 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Function::Load((char const *)arg1,arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function__Load__SWIG_5(char* jarg1, unsigned long jarg2) {
  void * jresult ;
  char *arg1 = (char *) 0 ;
  size_t arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (char *)jarg1; 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = CNTK::Function::Load((char const *)arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function_AsString__SWIG_0(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  bool arg2 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::wstring result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = ((CNTK::Function const *)arg1)->AsString(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function_AsString__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function const > *smartarg1 = 0 ;
  std::wstring result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Function const *)arg1)->AsString(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Function_GetCustomAttributes(void * jarg1) {
  void * jresult ;
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  CNTK::Dictionary *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (CNTK::Dictionary *) &(arg1)->GetCustomAttributes(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Function_ResetCustomAttributes(void * jarg1) {
  CNTK::Function *arg1 = (CNTK::Function *) 0 ;
  std::shared_ptr< CNTK::Function > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Function > *)jarg1;
  arg1 = (CNTK::Function *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (arg1)->ResetCustomAttributes(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_Function_MaxNumOutputs_get() {
  int jresult ;
  int result;
  
  result = (int)CNTK::Function::MaxNumOutputs;
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementAnd__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ElementAnd((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementAnd__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ElementAnd((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementNot__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::ElementNot((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementNot__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ElementNot((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementOr__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ElementOr((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementOr__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ElementOr((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementXor__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ElementXor((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementXor__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ElementXor((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Negate__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Negate((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Negate__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Negate((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Sigmoid__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sigmoid((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Sigmoid__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sigmoid((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Atanh__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Atanh((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Atanh__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Atanh((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Tanh__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Tanh((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Tanh__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Tanh((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Asin__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Asin((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Asin__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Asin((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Sin__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sin((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Sin__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sin((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Acos__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Acos((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Acos__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Acos((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Cos__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Cos((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Cos__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Cos((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Atan__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Atan((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Atan__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Atan((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Tan__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Tan((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Tan__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Tan((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Cosh__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Cosh((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Cosh__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Cosh((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Asinh__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Asinh((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Asinh__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Asinh((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Sinh__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sinh((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Sinh__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sinh((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReLU__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::ReLU((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReLU__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReLU((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Exp__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Exp((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Exp__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Exp((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Log__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Log((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Log__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Log((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Square__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Square((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Square__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Square((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Sqrt__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sqrt((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Sqrt__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sqrt((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Round__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Round((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Round__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Round((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Floor__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Floor((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Floor__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Floor((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Ceil__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Ceil((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Ceil__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Ceil((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Abs__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Abs((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Abs__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Abs((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Reciprocal__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Reciprocal((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Reciprocal__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Reciprocal((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Softmax__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Softmax((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Softmax__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Softmax((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Softmax__SWIG_2(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Softmax((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Softmax__SWIG_3(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Softmax((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LogSoftmax__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::LogSoftmax((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LogSoftmax__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::LogSoftmax((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LogSoftmax__SWIG_2(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::LogSoftmax((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LogSoftmax__SWIG_3(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::LogSoftmax((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Hardmax__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Hardmax((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Hardmax__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Hardmax((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HardSigmoid__SWIG_0(void * jarg1, float jarg2, float jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  float arg2 ;
  float arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::HardSigmoid((CNTK::Variable const &)*arg1,arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HardSigmoid__SWIG_1(void * jarg1, float jarg2, float jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  float arg2 ;
  float arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  {
    try {
      result = CNTK::HardSigmoid((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TopK__SWIG_0(void * jarg1, unsigned long jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::TopK((CNTK::Variable const &)*arg1,arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TopK__SWIG_1(void * jarg1, unsigned long jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = CNTK::TopK((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TopK__SWIG_2(void * jarg1, unsigned long jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  CNTK::Axis *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::TopK((CNTK::Variable const &)*arg1,arg2,(CNTK::Axis const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TopK__SWIG_3(void * jarg1, unsigned long jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  CNTK::Axis *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::TopK((CNTK::Variable const &)*arg1,arg2,(CNTK::Axis const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TransposeAxes__SWIG_0(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::Axis *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::TransposeAxes((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(CNTK::Axis const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TransposeAxes__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::Axis *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::TransposeAxes((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(CNTK::Axis const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Transpose__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Transpose((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Transpose__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Transpose((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Transpose__SWIG_2(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Transpose((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Transpose__SWIG_3(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Transpose((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Slice__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  std::vector< int > *arg3 = 0 ;
  std::vector< int > *arg4 = 0 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  arg4 = (std::vector< int > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::Slice((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,(std::vector< int > const &)*arg3,(std::vector< int > const &)*arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Slice__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  std::vector< int > *arg3 = 0 ;
  std::vector< int > *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  arg4 = (std::vector< int > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Slice((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,(std::vector< int > const &)*arg3,(std::vector< int > const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Slice__SWIG_2(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, wchar_t * jarg6) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  std::vector< int > *arg3 = 0 ;
  std::vector< int > *arg4 = 0 ;
  std::vector< int > *arg5 = 0 ;
  std::wstring *arg6 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  arg4 = (std::vector< int > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< int > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  if (!jarg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg6_str(jarg6);
  arg6 = &arg6_str; 
  {
    try {
      result = CNTK::Slice((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,(std::vector< int > const &)*arg3,(std::vector< int > const &)*arg4,(std::vector< int > const &)*arg5,(std::wstring const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Slice__SWIG_3(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  std::vector< int > *arg3 = 0 ;
  std::vector< int > *arg4 = 0 ;
  std::vector< int > *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  arg4 = (std::vector< int > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< int > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Slice((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,(std::vector< int > const &)*arg3,(std::vector< int > const &)*arg4,(std::vector< int > const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ToBatch__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::ToBatch((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ToBatch__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ToBatch((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UnpackBatch(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::UnpackBatch((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pad__SWIG_0(void * jarg1, int jarg2, void * jarg3, void * jarg4, double jarg5, wchar_t * jarg6) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PaddingMode arg2 ;
  std::vector< size_t > *arg3 = 0 ;
  std::vector< size_t > *arg4 = 0 ;
  double arg5 ;
  std::wstring *arg6 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PaddingMode)jarg2; 
  arg3 = (std::vector< size_t > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg4 = (std::vector< size_t > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg5 = (double)jarg5; 
  if (!jarg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg6_str(jarg6);
  arg6 = &arg6_str; 
  {
    try {
      result = CNTK::Pad((CNTK::Variable const &)*arg1,arg2,(std::vector< size_t > const &)*arg3,(std::vector< size_t > const &)*arg4,arg5,(std::wstring const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pad__SWIG_1(void * jarg1, int jarg2, void * jarg3, void * jarg4, double jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PaddingMode arg2 ;
  std::vector< size_t > *arg3 = 0 ;
  std::vector< size_t > *arg4 = 0 ;
  double arg5 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PaddingMode)jarg2; 
  arg3 = (std::vector< size_t > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg4 = (std::vector< size_t > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg5 = (double)jarg5; 
  {
    try {
      result = CNTK::Pad((CNTK::Variable const &)*arg1,arg2,(std::vector< size_t > const &)*arg3,(std::vector< size_t > const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pad__SWIG_2(void * jarg1, int jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PaddingMode arg2 ;
  std::vector< size_t > *arg3 = 0 ;
  std::vector< size_t > *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PaddingMode)jarg2; 
  arg3 = (std::vector< size_t > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg4 = (std::vector< size_t > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Pad((CNTK::Variable const &)*arg1,arg2,(std::vector< size_t > const &)*arg3,(std::vector< size_t > const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_RandomSample__SWIG_0(void * jarg1, unsigned long jarg2, unsigned int jarg3, unsigned long jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  bool arg3 ;
  unsigned long arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3 ? true : false; 
  arg4 = (unsigned long)jarg4; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::RandomSample((CNTK::Variable const &)*arg1,arg2,arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_RandomSample__SWIG_1(void * jarg1, unsigned long jarg2, unsigned int jarg3, unsigned long jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  bool arg3 ;
  unsigned long arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3 ? true : false; 
  arg4 = (unsigned long)jarg4; 
  {
    try {
      result = CNTK::RandomSample((CNTK::Variable const &)*arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_RandomSample__SWIG_2(void * jarg1, unsigned long jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::RandomSample((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_RandomSampleInclusionFrequency__SWIG_0(void * jarg1, unsigned long jarg2, unsigned int jarg3, unsigned long jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  bool arg3 ;
  unsigned long arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3 ? true : false; 
  arg4 = (unsigned long)jarg4; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::RandomSampleInclusionFrequency((CNTK::Variable const &)*arg1,arg2,arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_RandomSampleInclusionFrequency__SWIG_1(void * jarg1, unsigned long jarg2, unsigned int jarg3, unsigned long jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  bool arg3 ;
  unsigned long arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3 ? true : false; 
  arg4 = (unsigned long)jarg4; 
  {
    try {
      result = CNTK::RandomSampleInclusionFrequency((CNTK::Variable const &)*arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_RandomSampleInclusionFrequency__SWIG_2(void * jarg1, unsigned long jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::RandomSampleInclusionFrequency((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Dropout__SWIG_0(void * jarg1, double jarg2, unsigned long jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  unsigned long arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (unsigned long)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::Dropout((CNTK::Variable const &)*arg1,arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Dropout__SWIG_1(void * jarg1, double jarg2, unsigned long jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  unsigned long arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (unsigned long)jarg3; 
  {
    try {
      result = CNTK::Dropout((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Dropout__SWIG_2(void * jarg1, double jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  {
    try {
      result = CNTK::Dropout((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UniformRandom__SWIG_0(void * jarg1, int jarg2, double jarg3, double jarg4, unsigned long jarg5, wchar_t * jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  double arg4 ;
  unsigned long arg5 ;
  std::wstring *arg6 = 0 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (unsigned long)jarg5; 
  if (!jarg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg6_str(jarg6);
  arg6 = &arg6_str; 
  {
    try {
      result = CNTK::UniformRandom((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,arg5,(std::wstring const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UniformRandom__SWIG_1(void * jarg1, int jarg2, double jarg3, double jarg4, unsigned long jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  double arg4 ;
  unsigned long arg5 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (unsigned long)jarg5; 
  {
    try {
      result = CNTK::UniformRandom((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UniformRandom__SWIG_2(void * jarg1, int jarg2, double jarg3, double jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  double arg4 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  {
    try {
      result = CNTK::UniformRandom((CNTK::NDShape const &)*arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UniformRandom__SWIG_3(void * jarg1, int jarg2, double jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  {
    try {
      result = CNTK::UniformRandom((CNTK::NDShape const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UniformRandom__SWIG_4(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  {
    try {
      result = CNTK::UniformRandom((CNTK::NDShape const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UniformRandomLike__SWIG_0(void * jarg1, double jarg2, double jarg3, unsigned long jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  unsigned long arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (unsigned long)jarg4; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::UniformRandomLike((CNTK::Variable const &)*arg1,arg2,arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UniformRandomLike__SWIG_1(void * jarg1, double jarg2, double jarg3, unsigned long jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  unsigned long arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (unsigned long)jarg4; 
  {
    try {
      result = CNTK::UniformRandomLike((CNTK::Variable const &)*arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UniformRandomLike__SWIG_2(void * jarg1, double jarg2, double jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  {
    try {
      result = CNTK::UniformRandomLike((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UniformRandomLike__SWIG_3(void * jarg1, double jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  {
    try {
      result = CNTK::UniformRandomLike((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_UniformRandomLike__SWIG_4(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::UniformRandomLike((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalRandom__SWIG_0(void * jarg1, int jarg2, double jarg3, double jarg4, unsigned long jarg5, wchar_t * jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  double arg4 ;
  unsigned long arg5 ;
  std::wstring *arg6 = 0 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (unsigned long)jarg5; 
  if (!jarg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg6_str(jarg6);
  arg6 = &arg6_str; 
  {
    try {
      result = CNTK::NormalRandom((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,arg5,(std::wstring const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalRandom__SWIG_1(void * jarg1, int jarg2, double jarg3, double jarg4, unsigned long jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  double arg4 ;
  unsigned long arg5 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (unsigned long)jarg5; 
  {
    try {
      result = CNTK::NormalRandom((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalRandom__SWIG_2(void * jarg1, int jarg2, double jarg3, double jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  double arg4 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  {
    try {
      result = CNTK::NormalRandom((CNTK::NDShape const &)*arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalRandom__SWIG_3(void * jarg1, int jarg2, double jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  {
    try {
      result = CNTK::NormalRandom((CNTK::NDShape const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalRandom__SWIG_4(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  {
    try {
      result = CNTK::NormalRandom((CNTK::NDShape const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalRandomLike__SWIG_0(void * jarg1, double jarg2, double jarg3, unsigned long jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  unsigned long arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (unsigned long)jarg4; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::NormalRandomLike((CNTK::Variable const &)*arg1,arg2,arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalRandomLike__SWIG_1(void * jarg1, double jarg2, double jarg3, unsigned long jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  unsigned long arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (unsigned long)jarg4; 
  {
    try {
      result = CNTK::NormalRandomLike((CNTK::Variable const &)*arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalRandomLike__SWIG_2(void * jarg1, double jarg2, double jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  {
    try {
      result = CNTK::NormalRandomLike((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalRandomLike__SWIG_3(void * jarg1, double jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  {
    try {
      result = CNTK::NormalRandomLike((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NormalRandomLike__SWIG_4(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::NormalRandomLike((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GumbelRandom__SWIG_0(void * jarg1, int jarg2, double jarg3, double jarg4, unsigned long jarg5, wchar_t * jarg6) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  double arg4 ;
  unsigned long arg5 ;
  std::wstring *arg6 = 0 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (unsigned long)jarg5; 
  if (!jarg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg6_str(jarg6);
  arg6 = &arg6_str; 
  {
    try {
      result = CNTK::GumbelRandom((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,arg5,(std::wstring const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GumbelRandom__SWIG_1(void * jarg1, int jarg2, double jarg3, double jarg4, unsigned long jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  double arg4 ;
  unsigned long arg5 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (unsigned long)jarg5; 
  {
    try {
      result = CNTK::GumbelRandom((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GumbelRandom__SWIG_2(void * jarg1, int jarg2, double jarg3, double jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  double arg4 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  {
    try {
      result = CNTK::GumbelRandom((CNTK::NDShape const &)*arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GumbelRandom__SWIG_3(void * jarg1, int jarg2, double jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  {
    try {
      result = CNTK::GumbelRandom((CNTK::NDShape const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GumbelRandom__SWIG_4(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  {
    try {
      result = CNTK::GumbelRandom((CNTK::NDShape const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GumbelRandomLike__SWIG_0(void * jarg1, double jarg2, double jarg3, unsigned long jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  unsigned long arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (unsigned long)jarg4; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::GumbelRandomLike((CNTK::Variable const &)*arg1,arg2,arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GumbelRandomLike__SWIG_1(void * jarg1, double jarg2, double jarg3, unsigned long jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  unsigned long arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (unsigned long)jarg4; 
  {
    try {
      result = CNTK::GumbelRandomLike((CNTK::Variable const &)*arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GumbelRandomLike__SWIG_2(void * jarg1, double jarg2, double jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  {
    try {
      result = CNTK::GumbelRandomLike((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GumbelRandomLike__SWIG_3(void * jarg1, double jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  {
    try {
      result = CNTK::GumbelRandomLike((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GumbelRandomLike__SWIG_4(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::GumbelRandomLike((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BernoulliRandom__SWIG_0(void * jarg1, int jarg2, double jarg3, unsigned long jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  unsigned long arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (unsigned long)jarg4; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::BernoulliRandom((CNTK::NDShape const &)*arg1,arg2,arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BernoulliRandom__SWIG_1(void * jarg1, int jarg2, double jarg3, unsigned long jarg4) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  unsigned long arg4 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (unsigned long)jarg4; 
  {
    try {
      result = CNTK::BernoulliRandom((CNTK::NDShape const &)*arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BernoulliRandom__SWIG_2(void * jarg1, int jarg2, double jarg3) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  double arg3 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  arg3 = (double)jarg3; 
  {
    try {
      result = CNTK::BernoulliRandom((CNTK::NDShape const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BernoulliRandom__SWIG_3(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::NDShape *arg1 = 0 ;
  CNTK::DataType arg2 ;
  CNTK::FunctionPtr result;
  
  
  arg1 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg1) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg1)->get() : 0);
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  {
    try {
      result = CNTK::BernoulliRandom((CNTK::NDShape const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BernoulliRandomLike__SWIG_0(void * jarg1, double jarg2, unsigned long jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  unsigned long arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (unsigned long)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::BernoulliRandomLike((CNTK::Variable const &)*arg1,arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BernoulliRandomLike__SWIG_1(void * jarg1, double jarg2, unsigned long jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  unsigned long arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (unsigned long)jarg3; 
  {
    try {
      result = CNTK::BernoulliRandomLike((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BernoulliRandomLike__SWIG_2(void * jarg1, double jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  {
    try {
      result = CNTK::BernoulliRandomLike((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BernoulliRandomLike__SWIG_3(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::BernoulliRandomLike((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Flatten__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Flatten((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Flatten__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Flatten((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Flatten__SWIG_2(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Flatten((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Flatten__SWIG_3(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Flatten((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Reshape__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::NDShape *arg2 = 0 ;
  CNTK::Axis *arg3 = 0 ;
  CNTK::Axis *arg4 = 0 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg2 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg2) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Axis *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::Reshape((CNTK::Variable const &)*arg1,(CNTK::NDShape const &)*arg2,(CNTK::Axis const &)*arg3,(CNTK::Axis const &)*arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Reshape__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::NDShape *arg2 = 0 ;
  CNTK::Axis *arg3 = 0 ;
  CNTK::Axis *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg2 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg2) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Axis *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Reshape((CNTK::Variable const &)*arg1,(CNTK::NDShape const &)*arg2,(CNTK::Axis const &)*arg3,(CNTK::Axis const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Reshape__SWIG_2(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::NDShape *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg2 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg2) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Reshape((CNTK::Variable const &)*arg1,(CNTK::NDShape const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Reshape__SWIG_3(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::NDShape *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg2 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg2) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg2)->get() : 0);
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Reshape((CNTK::Variable const &)*arg1,(CNTK::NDShape const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Squeeze__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Squeeze((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Squeeze__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Squeeze((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Squeeze__SWIG_2(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Squeeze((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Squeeze__SWIG_3(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Squeeze((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ExpandDims__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ExpandDims((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ExpandDims__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ExpandDims((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConstantLike__SWIG_0(void * jarg1, double jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ConstantLike((CNTK::Variable const &)*arg1,arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConstantLike__SWIG_1(void * jarg1, double jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  {
    try {
      result = CNTK::ConstantLike((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ZerosLike__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::ZerosLike((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ZerosLike__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ZerosLike((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_OnesLike__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::OnesLike((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_OnesLike__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::OnesLike((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_EyeLike__SWIG_0(void * jarg1, unsigned int jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  bool arg2 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::EyeLike((CNTK::Variable const &)*arg1,arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_EyeLike__SWIG_1(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  bool arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = CNTK::EyeLike((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Plus__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Plus((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Plus__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Plus((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Minus__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Minus((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Minus__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Minus((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LogAddExp__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::LogAddExp((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LogAddExp__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::LogAddExp((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pow__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Pow((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pow__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Pow((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementTimes__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ElementTimes((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementTimes__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ElementTimes((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementDivide__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ElementDivide((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementDivide__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ElementDivide((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementMax(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ElementMax((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementMin(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ElementMin((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Equal__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Equal((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Equal__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Equal((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NotEqual__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::NotEqual((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NotEqual__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::NotEqual((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Less__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Less((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Less__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Less((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LessEqual__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::LessEqual((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LessEqual__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::LessEqual((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Greater__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Greater((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Greater__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Greater((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GreaterEqual__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::GreaterEqual((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GreaterEqual__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::GreaterEqual((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Times__SWIG_0(void * jarg1, void * jarg2, unsigned long jarg3, int jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  int arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (int)jarg4; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::Times((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Times__SWIG_1(void * jarg1, void * jarg2, unsigned long jarg3, int jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  int arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (int)jarg4; 
  {
    try {
      result = CNTK::Times((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Times__SWIG_2(void * jarg1, void * jarg2, unsigned long jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::Times((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Times__SWIG_3(void * jarg1, void * jarg2, unsigned long jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  {
    try {
      result = CNTK::Times((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Times__SWIG_4(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Times((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Times__SWIG_5(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Times((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TransposeTimes__SWIG_0(void * jarg1, void * jarg2, unsigned long jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::TransposeTimes((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TransposeTimes__SWIG_1(void * jarg1, void * jarg2, unsigned long jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  {
    try {
      result = CNTK::TransposeTimes((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TransposeTimes__SWIG_2(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::TransposeTimes((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TransposeTimes__SWIG_3(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::TransposeTimes((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CosineDistance__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::CosineDistance((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CosineDistance__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::CosineDistance((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CosineDistanceWithNegativeSamples__SWIG_0(void * jarg1, void * jarg2, unsigned long jarg3, unsigned long jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  size_t arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::CosineDistanceWithNegativeSamples((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CosineDistanceWithNegativeSamples__SWIG_1(void * jarg1, void * jarg2, unsigned long jarg3, unsigned long jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  size_t arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  {
    try {
      result = CNTK::CosineDistanceWithNegativeSamples((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BinaryCrossEntropy__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::BinaryCrossEntropy((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BinaryCrossEntropy__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::BinaryCrossEntropy((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_WeightedBinaryCrossEntropy__SWIG_0(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::WeightedBinaryCrossEntropy((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_WeightedBinaryCrossEntropy__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::WeightedBinaryCrossEntropy((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SquaredError__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::SquaredError((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SquaredError__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::SquaredError((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CrossEntropyWithSoftmax__SWIG_0(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Axis *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::CrossEntropyWithSoftmax((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Axis const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CrossEntropyWithSoftmax__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Axis *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::CrossEntropyWithSoftmax((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Axis const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CrossEntropyWithSoftmax__SWIG_2(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::CrossEntropyWithSoftmax((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CrossEntropyWithSoftmax__SWIG_3(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::CrossEntropyWithSoftmax((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_EditDistanceError__SWIG_0(void * jarg1, void * jarg2, float jarg3, float jarg4, float jarg5, unsigned int jarg6, void * jarg7, wchar_t * jarg8) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  bool arg6 ;
  std::vector< size_t > *arg7 = 0 ;
  std::wstring *arg8 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = jarg6 ? true : false; 
  arg7 = (std::vector< size_t > *)jarg7;
  if (!arg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  if (!jarg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg8_str(jarg8);
  arg8 = &arg8_str; 
  {
    try {
      result = CNTK::EditDistanceError((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4,arg5,arg6,(std::vector< size_t > const &)*arg7,(std::wstring const &)*arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_EditDistanceError__SWIG_1(void * jarg1, void * jarg2, float jarg3, float jarg4, float jarg5, unsigned int jarg6, void * jarg7) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  bool arg6 ;
  std::vector< size_t > *arg7 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = jarg6 ? true : false; 
  arg7 = (std::vector< size_t > *)jarg7;
  if (!arg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::EditDistanceError((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4,arg5,arg6,(std::vector< size_t > const &)*arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LatticeSequenceWithSoftmax__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4, wchar_t * jarg5, wchar_t * jarg6, wchar_t * jarg7, wchar_t * jarg8, wchar_t * jarg9, float jarg10, float jarg11, unsigned int jarg12, unsigned int jarg13, float jarg14, float jarg15, float jarg16, float jarg17, wchar_t * jarg18) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::Variable *arg4 = 0 ;
  std::wstring *arg5 = 0 ;
  std::wstring *arg6 = 0 ;
  std::wstring *arg7 = 0 ;
  std::wstring *arg8 = 0 ;
  std::wstring *arg9 = 0 ;
  float arg10 ;
  float arg11 ;
  bool arg12 ;
  bool arg13 ;
  float arg14 ;
  float arg15 ;
  float arg16 ;
  float arg17 ;
  std::wstring *arg18 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Variable *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  if (!jarg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg6_str(jarg6);
  arg6 = &arg6_str; 
  if (!jarg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg7_str(jarg7);
  arg7 = &arg7_str; 
  if (!jarg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg8_str(jarg8);
  arg8 = &arg8_str; 
  if (!jarg9) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg9_str(jarg9);
  arg9 = &arg9_str; 
  arg10 = (float)jarg10; 
  arg11 = (float)jarg11; 
  arg12 = jarg12 ? true : false; 
  arg13 = jarg13 ? true : false; 
  arg14 = (float)jarg14; 
  arg15 = (float)jarg15; 
  arg16 = (float)jarg16; 
  arg17 = (float)jarg17; 
  if (!jarg18) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg18_str(jarg18);
  arg18 = &arg18_str; 
  {
    try {
      result = CNTK::LatticeSequenceWithSoftmax((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(CNTK::Variable const &)*arg4,(std::wstring const &)*arg5,(std::wstring const &)*arg6,(std::wstring const &)*arg7,(std::wstring const &)*arg8,(std::wstring const &)*arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,(std::wstring const &)*arg18); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LatticeSequenceWithSoftmax__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4, wchar_t * jarg5, wchar_t * jarg6, wchar_t * jarg7, wchar_t * jarg8, wchar_t * jarg9, float jarg10, float jarg11, unsigned int jarg12, unsigned int jarg13, float jarg14, float jarg15, float jarg16, float jarg17) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::Variable *arg4 = 0 ;
  std::wstring *arg5 = 0 ;
  std::wstring *arg6 = 0 ;
  std::wstring *arg7 = 0 ;
  std::wstring *arg8 = 0 ;
  std::wstring *arg9 = 0 ;
  float arg10 ;
  float arg11 ;
  bool arg12 ;
  bool arg13 ;
  float arg14 ;
  float arg15 ;
  float arg16 ;
  float arg17 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Variable *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  if (!jarg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg6_str(jarg6);
  arg6 = &arg6_str; 
  if (!jarg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg7_str(jarg7);
  arg7 = &arg7_str; 
  if (!jarg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg8_str(jarg8);
  arg8 = &arg8_str; 
  if (!jarg9) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg9_str(jarg9);
  arg9 = &arg9_str; 
  arg10 = (float)jarg10; 
  arg11 = (float)jarg11; 
  arg12 = jarg12 ? true : false; 
  arg13 = jarg13 ? true : false; 
  arg14 = (float)jarg14; 
  arg15 = (float)jarg15; 
  arg16 = (float)jarg16; 
  arg17 = (float)jarg17; 
  {
    try {
      result = CNTK::LatticeSequenceWithSoftmax((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(CNTK::Variable const &)*arg4,(std::wstring const &)*arg5,(std::wstring const &)*arg6,(std::wstring const &)*arg7,(std::wstring const &)*arg8,(std::wstring const &)*arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ForwardBackward__SWIG_0(void * jarg1, void * jarg2, unsigned long jarg3, int jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  int arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (int)jarg4; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::ForwardBackward((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ForwardBackward__SWIG_1(void * jarg1, void * jarg2, unsigned long jarg3, int jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  int arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (int)jarg4; 
  {
    try {
      result = CNTK::ForwardBackward((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LabelsToGraph__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::LabelsToGraph((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LabelsToGraph__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::LabelsToGraph((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ClassificationError__SWIG_0(void * jarg1, void * jarg2, unsigned long jarg3, void * jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  CNTK::Axis *arg4 = 0 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (CNTK::Axis *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::ClassificationError((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,(CNTK::Axis const &)*arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ClassificationError__SWIG_1(void * jarg1, void * jarg2, unsigned long jarg3, void * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  CNTK::Axis *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (CNTK::Axis *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ClassificationError((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,(CNTK::Axis const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ClassificationError__SWIG_2(void * jarg1, void * jarg2, unsigned long jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ClassificationError((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ClassificationError__SWIG_3(void * jarg1, void * jarg2, unsigned long jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  {
    try {
      result = CNTK::ClassificationError((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ClassificationError__SWIG_4(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Axis *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ClassificationError((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Axis const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ClassificationError__SWIG_5(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Axis *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ClassificationError((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Axis const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ClassificationError__SWIG_6(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ClassificationError((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ClassificationError__SWIG_7(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ClassificationError((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DepthToSpace__SWIG_0(void * jarg1, unsigned long jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::DepthToSpace((CNTK::Variable const &)*arg1,arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_DepthToSpace__SWIG_1(void * jarg1, unsigned long jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = CNTK::DepthToSpace((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SpaceToDepth__SWIG_0(void * jarg1, unsigned long jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::SpaceToDepth((CNTK::Variable const &)*arg1,arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SpaceToDepth__SWIG_1(void * jarg1, unsigned long jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = CNTK::SpaceToDepth((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LambdaRank__SWIG_0(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::LambdaRank((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LambdaRank__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::LambdaRank((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDCGAt1__SWIG_0(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::NDCGAt1((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_NDCGAt1__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::NDCGAt1((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PastValue__SWIG_0(void * jarg1, void * jarg2, unsigned long jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::PastValue((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PastValue__SWIG_1(void * jarg1, void * jarg2, unsigned long jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  {
    try {
      result = CNTK::PastValue((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PastValue__SWIG_2(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::PastValue((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PastValue__SWIG_3(void * jarg1, unsigned long jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::PastValue((CNTK::Variable const &)*arg1,arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PastValue__SWIG_4(void * jarg1, unsigned long jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = CNTK::PastValue((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PastValue__SWIG_5(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::PastValue((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FutureValue__SWIG_0(void * jarg1, void * jarg2, unsigned long jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::FutureValue((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FutureValue__SWIG_1(void * jarg1, void * jarg2, unsigned long jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  {
    try {
      result = CNTK::FutureValue((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FutureValue__SWIG_2(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::FutureValue((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FutureValue__SWIG_3(void * jarg1, unsigned long jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::FutureValue((CNTK::Variable const &)*arg1,arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FutureValue__SWIG_4(void * jarg1, unsigned long jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = CNTK::FutureValue((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FutureValue__SWIG_5(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::FutureValue((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_OneHotOp__SWIG_0(void * jarg1, unsigned long jarg2, unsigned int jarg3, void * jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  bool arg3 ;
  CNTK::Axis *arg4 = 0 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3 ? true : false; 
  arg4 = (CNTK::Axis *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis & type is null", 0);
    return 0;
  } 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::OneHotOp((CNTK::Variable const &)*arg1,arg2,arg3,*arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_OneHotOp__SWIG_1(void * jarg1, unsigned long jarg2, unsigned int jarg3, void * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  bool arg3 ;
  CNTK::Axis *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3 ? true : false; 
  arg4 = (CNTK::Axis *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::OneHotOp((CNTK::Variable const &)*arg1,arg2,arg3,*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GatherOp__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::GatherOp((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GatherOp__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::GatherOp((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GatherOp__SWIG_2(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Axis *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::GatherOp((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Axis const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_GatherOp__SWIG_3(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Axis *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Axis *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::GatherOp((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Axis const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceSum__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ReduceSum((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceSum__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceSum((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceLogSum__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ReduceLogSum((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceLogSum__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceLogSum((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMean__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ReduceMean((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMean__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceMean((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMax__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ReduceMax((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMax__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceMax((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMin__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ReduceMin((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMin__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceMin((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceProd__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ReduceProd((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceProd__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceProd((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceSum__SWIG_2(void * jarg1, void * jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ReduceSum((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceSum__SWIG_3(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::ReduceSum((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceSum__SWIG_4(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceSum((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceLogSum__SWIG_2(void * jarg1, void * jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ReduceLogSum((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceLogSum__SWIG_3(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::ReduceLogSum((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceLogSum__SWIG_4(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceLogSum((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMean__SWIG_2(void * jarg1, void * jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ReduceMean((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMean__SWIG_3(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::ReduceMean((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMean__SWIG_4(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceMean((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMax__SWIG_2(void * jarg1, void * jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ReduceMax((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMax__SWIG_3(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::ReduceMax((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMax__SWIG_4(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceMax((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMin__SWIG_2(void * jarg1, void * jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ReduceMin((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMin__SWIG_3(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::ReduceMin((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceMin__SWIG_4(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceMin((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceProd__SWIG_2(void * jarg1, void * jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ReduceProd((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceProd__SWIG_3(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::ReduceProd((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceProd__SWIG_4(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceProd((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceL1__SWIG_0(void * jarg1, void * jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ReduceL1((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceL1__SWIG_1(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::ReduceL1((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceL1__SWIG_2(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceL1((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceL2__SWIG_0(void * jarg1, void * jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ReduceL2((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceL2__SWIG_1(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::ReduceL2((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceL2__SWIG_2(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceL2((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceSumSquare__SWIG_0(void * jarg1, void * jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ReduceSumSquare((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceSumSquare__SWIG_1(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::ReduceSumSquare((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReduceSumSquare__SWIG_2(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::vector< CNTK::Axis > *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (std::vector< CNTK::Axis > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Axis > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReduceSumSquare((CNTK::Variable const &)*arg1,(std::vector< CNTK::Axis > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ImageScaler(void * jarg1, float jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  float arg2 ;
  std::vector< float > arg3 ;
  std::wstring *arg4 = 0 ;
  std::vector< float > *argp3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (float)jarg2; 
  
  argp3 = ((std::shared_ptr<  std::vector<float> > *)jarg3) ? ((std::shared_ptr<  std::vector<float> > *)jarg3)->get() : 0;
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::vector< float >", 0);
    return 0;
  }
  arg3 = *argp3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ImageScaler((CNTK::Variable const &)*arg1,arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PerDimMeanVarianceNormalize__SWIG_0(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::PerDimMeanVarianceNormalize((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PerDimMeanVarianceNormalize__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::PerDimMeanVarianceNormalize((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PerDimMeanVarianceNormalize__SWIG_2(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::NDArrayViewPtr *arg2 = 0 ;
  CNTK::NDArrayViewPtr *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::NDArrayViewPtr tempnull2 ;
  CNTK::NDArrayViewPtr tempnull3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? (CNTK::NDArrayViewPtr *)jarg2 : &tempnull2; 
  arg3 = jarg3 ? (CNTK::NDArrayViewPtr *)jarg3 : &tempnull3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::PerDimMeanVarianceNormalize((CNTK::Variable const &)*arg1,(std::shared_ptr< CNTK::NDArrayView > const &)*arg2,(std::shared_ptr< CNTK::NDArrayView > const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PerDimMeanVarianceNormalize__SWIG_3(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::NDArrayViewPtr *arg2 = 0 ;
  CNTK::NDArrayViewPtr *arg3 = 0 ;
  CNTK::NDArrayViewPtr tempnull2 ;
  CNTK::NDArrayViewPtr tempnull3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? (CNTK::NDArrayViewPtr *)jarg2 : &tempnull2; 
  arg3 = jarg3 ? (CNTK::NDArrayViewPtr *)jarg3 : &tempnull3; 
  {
    try {
      result = CNTK::PerDimMeanVarianceNormalize((CNTK::Variable const &)*arg1,(std::shared_ptr< CNTK::NDArrayView > const &)*arg2,(std::shared_ptr< CNTK::NDArrayView > const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MeanVarianceNormalization__SWIG_0(void * jarg1, double jarg2, unsigned int jarg3, unsigned int jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  bool arg3 ;
  bool arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = jarg3 ? true : false; 
  arg4 = jarg4 ? true : false; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::MeanVarianceNormalization((CNTK::Variable const &)*arg1,arg2,arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MeanVarianceNormalization__SWIG_1(void * jarg1, double jarg2, unsigned int jarg3, unsigned int jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  bool arg3 ;
  bool arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = jarg3 ? true : false; 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK::MeanVarianceNormalization((CNTK::Variable const &)*arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MeanVarianceNormalization__SWIG_2(void * jarg1, double jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::MeanVarianceNormalization((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MeanVarianceNormalization__SWIG_3(void * jarg1, double jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  {
    try {
      result = CNTK::MeanVarianceNormalization((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MeanVarianceNormalization__SWIG_4(void * jarg1, unsigned int jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  bool arg2 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::MeanVarianceNormalization((CNTK::Variable const &)*arg1,arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MeanVarianceNormalization__SWIG_5(void * jarg1, unsigned int jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  bool arg2 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::MeanVarianceNormalization((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MeanVarianceNormalization__SWIG_6(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  bool arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = CNTK::MeanVarianceNormalization((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MeanVarianceNormalization__SWIG_7(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::MeanVarianceNormalization((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Convolution__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned long jarg7, unsigned long jarg8, unsigned long jarg9, unsigned int jarg10, wchar_t * jarg11) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  size_t arg7 ;
  size_t arg8 ;
  size_t arg9 ;
  bool arg10 ;
  std::wstring *arg11 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg7 = (size_t)jarg7; 
  arg8 = (size_t)jarg8; 
  arg9 = (size_t)jarg9; 
  arg10 = jarg10 ? true : false; 
  if (!jarg11) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg11_str(jarg11);
  arg11 = &arg11_str; 
  {
    try {
      result = CNTK::Convolution((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,arg7,arg8,arg9,arg10,(std::wstring const &)*arg11); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Convolution__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned long jarg7, unsigned long jarg8, unsigned long jarg9, unsigned int jarg10) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  size_t arg7 ;
  size_t arg8 ;
  size_t arg9 ;
  bool arg10 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg7 = (size_t)jarg7; 
  arg8 = (size_t)jarg8; 
  arg9 = (size_t)jarg9; 
  arg10 = jarg10 ? true : false; 
  {
    try {
      result = CNTK::Convolution((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,arg7,arg8,arg9,arg10); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Convolution__SWIG_2(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned long jarg7, unsigned long jarg8, unsigned long jarg9) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  size_t arg7 ;
  size_t arg8 ;
  size_t arg9 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg7 = (size_t)jarg7; 
  arg8 = (size_t)jarg8; 
  arg9 = (size_t)jarg9; 
  {
    try {
      result = CNTK::Convolution((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,arg7,arg8,arg9); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Convolution__SWIG_3(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned long jarg7, unsigned long jarg8) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  size_t arg7 ;
  size_t arg8 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg7 = (size_t)jarg7; 
  arg8 = (size_t)jarg8; 
  {
    try {
      result = CNTK::Convolution((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,arg7,arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Convolution__SWIG_4(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned long jarg7) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  size_t arg7 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg7 = (size_t)jarg7; 
  {
    try {
      result = CNTK::Convolution((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Convolution__SWIG_5(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Convolution((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Convolution__SWIG_6(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Convolution((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Convolution__SWIG_7(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Convolution((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Convolution__SWIG_8(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Convolution((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Convolution__SWIG_9(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Convolution((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionTranspose__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, void * jarg7, unsigned long jarg8, unsigned long jarg9, wchar_t * jarg10) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  CNTK::NDShape *arg7 = 0 ;
  size_t arg8 ;
  size_t arg9 ;
  std::wstring *arg10 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg7 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg7) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg7)->get() : 0);
  if (!arg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg8 = (size_t)jarg8; 
  arg9 = (size_t)jarg9; 
  if (!jarg10) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg10_str(jarg10);
  arg10 = &arg10_str; 
  {
    try {
      result = CNTK::ConvolutionTranspose((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,(CNTK::NDShape const &)*arg7,arg8,arg9,(std::wstring const &)*arg10); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionTranspose__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, void * jarg7, unsigned long jarg8, unsigned long jarg9) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  CNTK::NDShape *arg7 = 0 ;
  size_t arg8 ;
  size_t arg9 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg7 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg7) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg7)->get() : 0);
  if (!arg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg8 = (size_t)jarg8; 
  arg9 = (size_t)jarg9; 
  {
    try {
      result = CNTK::ConvolutionTranspose((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,(CNTK::NDShape const &)*arg7,arg8,arg9); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionTranspose__SWIG_2(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, void * jarg7, unsigned long jarg8) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  CNTK::NDShape *arg7 = 0 ;
  size_t arg8 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg7 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg7) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg7)->get() : 0);
  if (!arg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg8 = (size_t)jarg8; 
  {
    try {
      result = CNTK::ConvolutionTranspose((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,(CNTK::NDShape const &)*arg7,arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionTranspose__SWIG_3(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, void * jarg7) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  CNTK::NDShape *arg7 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg7 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg7) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg7)->get() : 0);
  if (!arg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ConvolutionTranspose((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6,(CNTK::NDShape const &)*arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionTranspose__SWIG_4(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::NDShape *arg6 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  
  arg6 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg6) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg6)->get() : 0);
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ConvolutionTranspose((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5,(CNTK::NDShape const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionTranspose__SWIG_5(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ConvolutionTranspose((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< bool > const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionTranspose__SWIG_6(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ConvolutionTranspose((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionTranspose__SWIG_7(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ConvolutionTranspose((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionTranspose__SWIG_8(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ConvolutionTranspose((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionTranspose__SWIG_9(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, void * jarg7, void * jarg8, unsigned long jarg9, wchar_t * jarg10) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< size_t > *arg5 = 0 ;
  std::vector< size_t > *arg6 = 0 ;
  CNTK::NDShape *arg7 = 0 ;
  CNTK::NDShape *arg8 = 0 ;
  size_t arg9 ;
  std::wstring *arg10 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< size_t > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg6 = (std::vector< size_t > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  
  arg7 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg7) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg7)->get() : 0);
  if (!arg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg8 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg8) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg8)->get() : 0);
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg9 = (size_t)jarg9; 
  if (!jarg10) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg10_str(jarg10);
  arg10 = &arg10_str; 
  {
    try {
      result = CNTK::ConvolutionTranspose((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< size_t > const &)*arg5,(std::vector< size_t > const &)*arg6,(CNTK::NDShape const &)*arg7,(CNTK::NDShape const &)*arg8,arg9,(std::wstring const &)*arg10); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ConvolutionTranspose__SWIG_10(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, void * jarg7, void * jarg8, unsigned long jarg9) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  std::vector< bool > *arg4 = 0 ;
  std::vector< size_t > *arg5 = 0 ;
  std::vector< size_t > *arg6 = 0 ;
  CNTK::NDShape *arg7 = 0 ;
  CNTK::NDShape *arg8 = 0 ;
  size_t arg9 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (std::vector< bool > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< size_t > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg6 = (std::vector< size_t > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  
  arg7 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg7) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg7)->get() : 0);
  if (!arg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg8 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg8) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg8)->get() : 0);
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg9 = (size_t)jarg9; 
  {
    try {
      result = CNTK::ConvolutionTranspose((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::NDShape const &)*arg3,(std::vector< bool > const &)*arg4,(std::vector< size_t > const &)*arg5,(std::vector< size_t > const &)*arg6,(CNTK::NDShape const &)*arg7,(CNTK::NDShape const &)*arg8,arg9); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ROIPooling(void * jarg1, void * jarg2, int jarg3, void * jarg4, double jarg5, wchar_t * jarg6) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::PoolingType arg3 ;
  CNTK::NDShape *arg4 = 0 ;
  double arg5 ;
  std::wstring *arg6 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::PoolingType)jarg3; 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg5 = (double)jarg5; 
  if (!jarg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg6_str(jarg6);
  arg6 = &arg6_str; 
  {
    try {
      result = CNTK::ROIPooling((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,(CNTK::NDShape const &)*arg4,arg5,(std::wstring const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pooling__SWIG_0(void * jarg1, int jarg2, void * jarg3, void * jarg4, void * jarg5, unsigned int jarg6, unsigned int jarg7, wchar_t * jarg8) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PoolingType arg2 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::NDShape *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  bool arg6 ;
  bool arg7 ;
  std::wstring *arg8 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PoolingType)jarg2; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg6 = jarg6 ? true : false; 
  arg7 = jarg7 ? true : false; 
  if (!jarg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg8_str(jarg8);
  arg8 = &arg8_str; 
  {
    try {
      result = CNTK::Pooling((CNTK::Variable const &)*arg1,arg2,(CNTK::NDShape const &)*arg3,(CNTK::NDShape const &)*arg4,(std::vector< bool > const &)*arg5,arg6,arg7,(std::wstring const &)*arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pooling__SWIG_1(void * jarg1, int jarg2, void * jarg3, void * jarg4, void * jarg5, unsigned int jarg6, unsigned int jarg7) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PoolingType arg2 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::NDShape *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  bool arg6 ;
  bool arg7 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PoolingType)jarg2; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg6 = jarg6 ? true : false; 
  arg7 = jarg7 ? true : false; 
  {
    try {
      result = CNTK::Pooling((CNTK::Variable const &)*arg1,arg2,(CNTK::NDShape const &)*arg3,(CNTK::NDShape const &)*arg4,(std::vector< bool > const &)*arg5,arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pooling__SWIG_2(void * jarg1, int jarg2, void * jarg3, void * jarg4, void * jarg5, unsigned int jarg6) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PoolingType arg2 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::NDShape *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  bool arg6 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PoolingType)jarg2; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  arg6 = jarg6 ? true : false; 
  {
    try {
      result = CNTK::Pooling((CNTK::Variable const &)*arg1,arg2,(CNTK::NDShape const &)*arg3,(CNTK::NDShape const &)*arg4,(std::vector< bool > const &)*arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pooling__SWIG_3(void * jarg1, int jarg2, void * jarg3, void * jarg4, void * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PoolingType arg2 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::NDShape *arg4 = 0 ;
  std::vector< bool > *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PoolingType)jarg2; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg5 = (std::vector< bool > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Pooling((CNTK::Variable const &)*arg1,arg2,(CNTK::NDShape const &)*arg3,(CNTK::NDShape const &)*arg4,(std::vector< bool > const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pooling__SWIG_4(void * jarg1, int jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PoolingType arg2 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::NDShape *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PoolingType)jarg2; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Pooling((CNTK::Variable const &)*arg1,arg2,(CNTK::NDShape const &)*arg3,(CNTK::NDShape const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pooling__SWIG_5(void * jarg1, int jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PoolingType arg2 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PoolingType)jarg2; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Pooling((CNTK::Variable const &)*arg1,arg2,(CNTK::NDShape const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pooling__SWIG_6(void * jarg1, int jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned int jarg7, unsigned int jarg8, wchar_t * jarg9) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PoolingType arg2 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::NDShape *arg4 = 0 ;
  std::vector< size_t > *arg5 = 0 ;
  std::vector< size_t > *arg6 = 0 ;
  bool arg7 ;
  bool arg8 ;
  std::wstring *arg9 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PoolingType)jarg2; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg5 = (std::vector< size_t > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg6 = (std::vector< size_t > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  arg8 = jarg8 ? true : false; 
  if (!jarg9) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg9_str(jarg9);
  arg9 = &arg9_str; 
  {
    try {
      result = CNTK::Pooling((CNTK::Variable const &)*arg1,arg2,(CNTK::NDShape const &)*arg3,(CNTK::NDShape const &)*arg4,(std::vector< size_t > const &)*arg5,(std::vector< size_t > const &)*arg6,arg7,arg8,(std::wstring const &)*arg9); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pooling__SWIG_7(void * jarg1, int jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned int jarg7, unsigned int jarg8) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PoolingType arg2 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::NDShape *arg4 = 0 ;
  std::vector< size_t > *arg5 = 0 ;
  std::vector< size_t > *arg6 = 0 ;
  bool arg7 ;
  bool arg8 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PoolingType)jarg2; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg5 = (std::vector< size_t > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg6 = (std::vector< size_t > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  arg8 = jarg8 ? true : false; 
  {
    try {
      result = CNTK::Pooling((CNTK::Variable const &)*arg1,arg2,(CNTK::NDShape const &)*arg3,(CNTK::NDShape const &)*arg4,(std::vector< size_t > const &)*arg5,(std::vector< size_t > const &)*arg6,arg7,arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pooling__SWIG_8(void * jarg1, int jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned int jarg7) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PoolingType arg2 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::NDShape *arg4 = 0 ;
  std::vector< size_t > *arg5 = 0 ;
  std::vector< size_t > *arg6 = 0 ;
  bool arg7 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PoolingType)jarg2; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg5 = (std::vector< size_t > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg6 = (std::vector< size_t > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  {
    try {
      result = CNTK::Pooling((CNTK::Variable const &)*arg1,arg2,(CNTK::NDShape const &)*arg3,(CNTK::NDShape const &)*arg4,(std::vector< size_t > const &)*arg5,(std::vector< size_t > const &)*arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Pooling__SWIG_9(void * jarg1, int jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::PoolingType arg2 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::NDShape *arg4 = 0 ;
  std::vector< size_t > *arg5 = 0 ;
  std::vector< size_t > *arg6 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::PoolingType)jarg2; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg5 = (std::vector< size_t > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  arg6 = (std::vector< size_t > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< size_t > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Pooling((CNTK::Variable const &)*arg1,arg2,(CNTK::NDShape const &)*arg3,(CNTK::NDShape const &)*arg4,(std::vector< size_t > const &)*arg5,(std::vector< size_t > const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Unpooling__SWIG_0(void * jarg1, void * jarg2, int jarg3, void * jarg4, void * jarg5, void * jarg6, wchar_t * jarg7) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::PoolingType arg3 ;
  CNTK::NDShape *arg4 = 0 ;
  CNTK::NDShape *arg5 = 0 ;
  std::vector< bool > *arg6 = 0 ;
  std::wstring *arg7 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::PoolingType)jarg3; 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg5 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg5) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg5)->get() : 0);
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg6 = (std::vector< bool > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  if (!jarg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg7_str(jarg7);
  arg7 = &arg7_str; 
  {
    try {
      result = CNTK::Unpooling((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,(CNTK::NDShape const &)*arg4,(CNTK::NDShape const &)*arg5,(std::vector< bool > const &)*arg6,(std::wstring const &)*arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Unpooling__SWIG_1(void * jarg1, void * jarg2, int jarg3, void * jarg4, void * jarg5, void * jarg6) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::PoolingType arg3 ;
  CNTK::NDShape *arg4 = 0 ;
  CNTK::NDShape *arg5 = 0 ;
  std::vector< bool > *arg6 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::PoolingType)jarg3; 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg5 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg5) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg5)->get() : 0);
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg6 = (std::vector< bool > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< bool > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Unpooling((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,(CNTK::NDShape const &)*arg4,(CNTK::NDShape const &)*arg5,(std::vector< bool > const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Unpooling__SWIG_2(void * jarg1, void * jarg2, int jarg3, void * jarg4, void * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::PoolingType arg3 ;
  CNTK::NDShape *arg4 = 0 ;
  CNTK::NDShape *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::PoolingType)jarg3; 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  
  arg5 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg5) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg5)->get() : 0);
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Unpooling((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,(CNTK::NDShape const &)*arg4,(CNTK::NDShape const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Unpooling__SWIG_3(void * jarg1, void * jarg2, int jarg3, void * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::PoolingType arg3 ;
  CNTK::NDShape *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::PoolingType)jarg3; 
  
  arg4 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg4) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg4)->get() : 0);
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Unpooling((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,(CNTK::NDShape const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BatchNormalization__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned int jarg7, double jarg8, double jarg9, double jarg10, unsigned int jarg11, unsigned int jarg12, wchar_t * jarg13) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::Variable *arg4 = 0 ;
  CNTK::Variable *arg5 = 0 ;
  CNTK::Variable *arg6 = 0 ;
  bool arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  bool arg11 ;
  bool arg12 ;
  std::wstring *arg13 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Variable *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg5 = (CNTK::Variable *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg6 = (CNTK::Variable *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  arg8 = (double)jarg8; 
  arg9 = (double)jarg9; 
  arg10 = (double)jarg10; 
  arg11 = jarg11 ? true : false; 
  arg12 = jarg12 ? true : false; 
  if (!jarg13) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg13_str(jarg13);
  arg13 = &arg13_str; 
  {
    try {
      result = CNTK::BatchNormalization((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(CNTK::Variable const &)*arg4,(CNTK::Variable const &)*arg5,(CNTK::Variable const &)*arg6,arg7,arg8,arg9,arg10,arg11,arg12,(std::wstring const &)*arg13); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BatchNormalization__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned int jarg7, double jarg8, double jarg9, double jarg10, unsigned int jarg11, unsigned int jarg12) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::Variable *arg4 = 0 ;
  CNTK::Variable *arg5 = 0 ;
  CNTK::Variable *arg6 = 0 ;
  bool arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  bool arg11 ;
  bool arg12 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Variable *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg5 = (CNTK::Variable *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg6 = (CNTK::Variable *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  arg8 = (double)jarg8; 
  arg9 = (double)jarg9; 
  arg10 = (double)jarg10; 
  arg11 = jarg11 ? true : false; 
  arg12 = jarg12 ? true : false; 
  {
    try {
      result = CNTK::BatchNormalization((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(CNTK::Variable const &)*arg4,(CNTK::Variable const &)*arg5,(CNTK::Variable const &)*arg6,arg7,arg8,arg9,arg10,arg11,arg12); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BatchNormalization__SWIG_2(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned int jarg7, double jarg8, double jarg9, double jarg10, unsigned int jarg11) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::Variable *arg4 = 0 ;
  CNTK::Variable *arg5 = 0 ;
  CNTK::Variable *arg6 = 0 ;
  bool arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  bool arg11 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Variable *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg5 = (CNTK::Variable *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg6 = (CNTK::Variable *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  arg8 = (double)jarg8; 
  arg9 = (double)jarg9; 
  arg10 = (double)jarg10; 
  arg11 = jarg11 ? true : false; 
  {
    try {
      result = CNTK::BatchNormalization((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(CNTK::Variable const &)*arg4,(CNTK::Variable const &)*arg5,(CNTK::Variable const &)*arg6,arg7,arg8,arg9,arg10,arg11); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BatchNormalization__SWIG_3(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned int jarg7, double jarg8, double jarg9, double jarg10) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::Variable *arg4 = 0 ;
  CNTK::Variable *arg5 = 0 ;
  CNTK::Variable *arg6 = 0 ;
  bool arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Variable *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg5 = (CNTK::Variable *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg6 = (CNTK::Variable *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  arg8 = (double)jarg8; 
  arg9 = (double)jarg9; 
  arg10 = (double)jarg10; 
  {
    try {
      result = CNTK::BatchNormalization((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(CNTK::Variable const &)*arg4,(CNTK::Variable const &)*arg5,(CNTK::Variable const &)*arg6,arg7,arg8,arg9,arg10); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BatchNormalization__SWIG_4(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned int jarg7, double jarg8, double jarg9) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::Variable *arg4 = 0 ;
  CNTK::Variable *arg5 = 0 ;
  CNTK::Variable *arg6 = 0 ;
  bool arg7 ;
  double arg8 ;
  double arg9 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Variable *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg5 = (CNTK::Variable *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg6 = (CNTK::Variable *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  arg8 = (double)jarg8; 
  arg9 = (double)jarg9; 
  {
    try {
      result = CNTK::BatchNormalization((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(CNTK::Variable const &)*arg4,(CNTK::Variable const &)*arg5,(CNTK::Variable const &)*arg6,arg7,arg8,arg9); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BatchNormalization__SWIG_5(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned int jarg7, double jarg8) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::Variable *arg4 = 0 ;
  CNTK::Variable *arg5 = 0 ;
  CNTK::Variable *arg6 = 0 ;
  bool arg7 ;
  double arg8 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Variable *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg5 = (CNTK::Variable *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg6 = (CNTK::Variable *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  arg8 = (double)jarg8; 
  {
    try {
      result = CNTK::BatchNormalization((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(CNTK::Variable const &)*arg4,(CNTK::Variable const &)*arg5,(CNTK::Variable const &)*arg6,arg7,arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_BatchNormalization__SWIG_6(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, unsigned int jarg7) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::Variable *arg4 = 0 ;
  CNTK::Variable *arg5 = 0 ;
  CNTK::Variable *arg6 = 0 ;
  bool arg7 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Variable *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg5 = (CNTK::Variable *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg6 = (CNTK::Variable *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg7 = jarg7 ? true : false; 
  {
    try {
      result = CNTK::BatchNormalization((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(CNTK::Variable const &)*arg4,(CNTK::Variable const &)*arg5,(CNTK::Variable const &)*arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LocalResponseNormalization__SWIG_0(void * jarg1, unsigned long jarg2, double jarg3, double jarg4, double jarg5, wchar_t * jarg6) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  std::wstring *arg6 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  if (!jarg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg6_str(jarg6);
  arg6 = &arg6_str; 
  {
    try {
      result = CNTK::LocalResponseNormalization((CNTK::Variable const &)*arg1,arg2,arg3,arg4,arg5,(std::wstring const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LocalResponseNormalization__SWIG_1(void * jarg1, unsigned long jarg2, double jarg3, double jarg4, double jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  size_t arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  {
    try {
      result = CNTK::LocalResponseNormalization((CNTK::Variable const &)*arg1,arg2,arg3,arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_OptimizedRNNStack__SWIG_0(void * jarg1, void * jarg2, unsigned long jarg3, unsigned long jarg4, unsigned int jarg5, wchar_t * jarg6, wchar_t * jarg7) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  size_t arg4 ;
  bool arg5 ;
  std::wstring *arg6 = 0 ;
  std::wstring *arg7 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  arg5 = jarg5 ? true : false; 
  if (!jarg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg6_str(jarg6);
  arg6 = &arg6_str; 
  if (!jarg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg7_str(jarg7);
  arg7 = &arg7_str; 
  {
    try {
      result = CNTK::OptimizedRNNStack((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4,arg5,(std::wstring const &)*arg6,(std::wstring const &)*arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_OptimizedRNNStack__SWIG_1(void * jarg1, void * jarg2, unsigned long jarg3, unsigned long jarg4, unsigned int jarg5, wchar_t * jarg6) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  size_t arg4 ;
  bool arg5 ;
  std::wstring *arg6 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  arg5 = jarg5 ? true : false; 
  if (!jarg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg6_str(jarg6);
  arg6 = &arg6_str; 
  {
    try {
      result = CNTK::OptimizedRNNStack((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4,arg5,(std::wstring const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_OptimizedRNNStack__SWIG_2(void * jarg1, void * jarg2, unsigned long jarg3, unsigned long jarg4, unsigned int jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  size_t arg4 ;
  bool arg5 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = CNTK::OptimizedRNNStack((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_OptimizedRNNStack__SWIG_3(void * jarg1, void * jarg2, unsigned long jarg3, unsigned long jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  size_t arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  {
    try {
      result = CNTK::OptimizedRNNStack((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Clip__SWIG_0(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::Clip((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Clip__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Clip((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementSelect__SWIG_0(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ElementSelect((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ElementSelect__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ElementSelect((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Splice__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Splice((std::vector< CNTK::Variable > const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Splice__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Splice((std::vector< CNTK::Variable > const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Combine__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Combine((std::vector< CNTK::Variable > const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Combine__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Combine((std::vector< CNTK::Variable > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Mean__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Mean((std::vector< CNTK::Variable > const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Mean__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Mean((std::vector< CNTK::Variable > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Sum__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sum((std::vector< CNTK::Variable > const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Sum__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sum((std::vector< CNTK::Variable > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Alias__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Alias((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Alias__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Alias((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StopGradient__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::StopGradient((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StopGradient__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::StopGradient((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Assign__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Assign(*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Assign__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Assign(*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AsComposite__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::FunctionPtr *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr tempnull1 ;
  CNTK::FunctionPtr result;
  
  arg1 = jarg1 ? (CNTK::FunctionPtr *)jarg1 : &tempnull1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::AsComposite((std::shared_ptr< CNTK::Function > const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AsComposite__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::FunctionPtr *arg1 = 0 ;
  CNTK::FunctionPtr tempnull1 ;
  CNTK::FunctionPtr result;
  
  arg1 = jarg1 ? (CNTK::FunctionPtr *)jarg1 : &tempnull1; 
  {
    try {
      result = CNTK::AsComposite((std::shared_ptr< CNTK::Function > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ELU__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::ELU((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ELU__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ELU((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ELU__SWIG_2(void * jarg1, double jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ELU((CNTK::Variable const &)*arg1,arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ELU__SWIG_3(void * jarg1, double jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  {
    try {
      result = CNTK::ELU((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SELU__SWIG_0(void * jarg1, double jarg2, double jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::SELU((CNTK::Variable const &)*arg1,arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SELU__SWIG_1(void * jarg1, double jarg2, double jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  {
    try {
      result = CNTK::SELU((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SELU__SWIG_2(void * jarg1, double jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  {
    try {
      result = CNTK::SELU((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SELU__SWIG_3(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::SELU((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LeakyReLU__SWIG_0(void * jarg1, double jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::LeakyReLU((CNTK::Variable const &)*arg1,arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LeakyReLU__SWIG_1(void * jarg1, double jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  {
    try {
      result = CNTK::LeakyReLU((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PReLU__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::PReLU((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_PReLU__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::PReLU((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Softplus__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Softplus((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Softplus__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Softplus((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Softsign__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Softsign((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Softsign__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Softsign((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Argmax__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Argmax((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Argmax__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Argmax((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Argmin__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Argmin((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Argmin__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Axis *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Axis *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Axis const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Argmin((CNTK::Variable const &)*arg1,(CNTK::Axis const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StraightThrough__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::StraightThrough((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StraightThrough__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::StraightThrough((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ToSequence__SWIG_0(void * jarg1, wchar_t * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ToSequence((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ToSequence__SWIG_1(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::ToSequence((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ToSequence__SWIG_2(void * jarg1, void * jarg2, wchar_t * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ToSequence((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ToSequence__SWIG_3(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ToSequence((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ToSequenceLike__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ToSequenceLike((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ToSequenceLike__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ToSequenceLike((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReconcileDynamicAxes__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::ReconcileDynamicAxes((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReconcileDynamicAxes__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ReconcileDynamicAxes((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CustomProxyOp__SWIG_0(void * jarg1, wchar_t * jarg2, void * jarg3, int jarg4, wchar_t * jarg5) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::DataType arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DataType)jarg4; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::CustomProxyOp((std::vector< CNTK::Variable > const &)*arg1,(std::wstring const &)*arg2,(CNTK::NDShape const &)*arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CustomProxyOp__SWIG_1(void * jarg1, wchar_t * jarg2, void * jarg3, int jarg4) {
  void * jresult ;
  std::vector< CNTK::Variable > *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::NDShape *arg3 = 0 ;
  CNTK::DataType arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (std::vector< CNTK::Variable > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Variable > const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  
  arg3 = (CNTK::NDShape *)(((std::shared_ptr< const CNTK::NDShape > *)jarg3) ? ((std::shared_ptr< const CNTK::NDShape > *)jarg3)->get() : 0);
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::NDShape const & reference is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DataType)jarg4; 
  {
    try {
      result = CNTK::CustomProxyOp((std::vector< CNTK::Variable > const &)*arg1,(std::wstring const &)*arg2,(CNTK::NDShape const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceIsFirst__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sequence::IsFirst((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceIsFirst__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::IsFirst((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceIsLast__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sequence::IsLast((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceIsLast__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::IsLast((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceSlice__SWIG_0(void * jarg1, int jarg2, int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  int arg2 ;
  int arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::Sequence::Slice((CNTK::Variable const &)*arg1,arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceSlice__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  int arg2 ;
  int arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  {
    try {
      result = CNTK::Sequence::Slice((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceReduceSum__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sequence::ReduceSum((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceReduceSum__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::ReduceSum((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceReduceMax__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sequence::ReduceMax((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceReduceMax__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::ReduceMax((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceSoftmax__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sequence::Softmax((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceSoftmax__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::Softmax((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceFirst__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sequence::First((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceFirst__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::First((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceLast__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sequence::Last((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceLast__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::Last((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceWhere__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::Sequence::Where((CNTK::Variable const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceWhere__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::Where((CNTK::Variable const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceGather__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Sequence::Gather((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceGather__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::Gather((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceGather__SWIG_2(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::pair< size_t,int > *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (std::pair< size_t,int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,int > const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::Sequence::Gather((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::pair< size_t,int > const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceGather__SWIG_3(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::pair< size_t,int > *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (std::pair< size_t,int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,int > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::Gather((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::pair< size_t,int > const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceScatter__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Sequence::Scatter((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceScatter__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::Scatter((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceScatter__SWIG_2(void * jarg1, void * jarg2, void * jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::pair< size_t,int > *arg3 = 0 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (std::pair< size_t,int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,int > const & type is null", 0);
    return 0;
  } 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::Sequence::Scatter((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::pair< size_t,int > const &)*arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceScatter__SWIG_3(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::pair< size_t,int > *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (std::pair< size_t,int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,int > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::Scatter((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::pair< size_t,int > const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceBroadcastAs__SWIG_0(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Sequence::BroadcastAs((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceBroadcastAs__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Sequence::BroadcastAs((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceUnpack__SWIG_0(void * jarg1, double jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::Sequence::Unpack((CNTK::Variable const &)*arg1,arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SequenceUnpack__SWIG_1(void * jarg1, double jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  double arg2 ;
  bool arg3 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::Sequence::Unpack((CNTK::Variable const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_MomentumFromTimeConstant(double jarg1) {
  double jresult ;
  double arg1 ;
  double result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = (double)CNTK::MomentumFromTimeConstant(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MomentumAsTimeConstantSchedule__SWIG_0(double jarg1) {
  void * jresult ;
  double arg1 ;
  SwigValueWrapper< CNTK::TrainingParameterSchedule< double > > result;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = CNTK::MomentumAsTimeConstantSchedule(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::MomentumSchedule((const CNTK::MomentumSchedule &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MomentumAsTimeConstantSchedule__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::MomentumSchedule *arg1 = 0 ;
  SwigValueWrapper< CNTK::TrainingParameterSchedule< double > > result;
  
  arg1 = (CNTK::MomentumSchedule *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::MomentumAsTimeConstantSchedule((CNTK::TrainingParameterSchedule< double > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::MomentumSchedule((const CNTK::MomentumSchedule &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MomentumAsTimeConstantSchedule__SWIG_2(void * jarg1, unsigned long jarg2) {
  void * jresult ;
  std::vector< double > *arg1 = 0 ;
  size_t arg2 ;
  SwigValueWrapper< CNTK::TrainingParameterSchedule< double > > result;
  
  arg1 = (std::vector< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = CNTK::MomentumAsTimeConstantSchedule((std::vector< double > const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::MomentumSchedule((const CNTK::MomentumSchedule &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MomentumAsTimeConstantSchedule__SWIG_3(void * jarg1) {
  void * jresult ;
  std::vector< double > *arg1 = 0 ;
  SwigValueWrapper< CNTK::TrainingParameterSchedule< double > > result;
  
  arg1 = (std::vector< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::MomentumAsTimeConstantSchedule((std::vector< double > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::MomentumSchedule((const CNTK::MomentumSchedule &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MomentumAsTimeConstantSchedule__SWIG_4(void * jarg1, unsigned long jarg2) {
  void * jresult ;
  std::vector< std::pair< size_t,double > > *arg1 = 0 ;
  size_t arg2 ;
  SwigValueWrapper< CNTK::TrainingParameterSchedule< double > > result;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< size_t,double > > const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = CNTK::MomentumAsTimeConstantSchedule((std::vector< std::pair< size_t,double > > const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::MomentumSchedule((const CNTK::MomentumSchedule &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MomentumAsTimeConstantSchedule__SWIG_5(void * jarg1) {
  void * jresult ;
  std::vector< std::pair< size_t,double > > *arg1 = 0 ;
  SwigValueWrapper< CNTK::TrainingParameterSchedule< double > > result;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< size_t,double > > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::MomentumAsTimeConstantSchedule((std::vector< std::pair< size_t,double > > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::MomentumSchedule((const CNTK::MomentumSchedule &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AdditionalLearningOptions_l1RegularizationWeight_set(void * jarg1, double jarg2) {
  CNTK::AdditionalLearningOptions *arg1 = (CNTK::AdditionalLearningOptions *) 0 ;
  double arg2 ;
  
  arg1 = (CNTK::AdditionalLearningOptions *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->l1RegularizationWeight = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_AdditionalLearningOptions_l1RegularizationWeight_get(void * jarg1) {
  double jresult ;
  CNTK::AdditionalLearningOptions *arg1 = (CNTK::AdditionalLearningOptions *) 0 ;
  double result;
  
  arg1 = (CNTK::AdditionalLearningOptions *)jarg1; 
  result = (double) ((arg1)->l1RegularizationWeight);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AdditionalLearningOptions_l2RegularizationWeight_set(void * jarg1, double jarg2) {
  CNTK::AdditionalLearningOptions *arg1 = (CNTK::AdditionalLearningOptions *) 0 ;
  double arg2 ;
  
  arg1 = (CNTK::AdditionalLearningOptions *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->l2RegularizationWeight = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_AdditionalLearningOptions_l2RegularizationWeight_get(void * jarg1) {
  double jresult ;
  CNTK::AdditionalLearningOptions *arg1 = (CNTK::AdditionalLearningOptions *) 0 ;
  double result;
  
  arg1 = (CNTK::AdditionalLearningOptions *)jarg1; 
  result = (double) ((arg1)->l2RegularizationWeight);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AdditionalLearningOptions_gradientClippingThresholdPerSample_set(void * jarg1, double jarg2) {
  CNTK::AdditionalLearningOptions *arg1 = (CNTK::AdditionalLearningOptions *) 0 ;
  double arg2 ;
  
  arg1 = (CNTK::AdditionalLearningOptions *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->gradientClippingThresholdPerSample = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_AdditionalLearningOptions_gradientClippingThresholdPerSample_get(void * jarg1) {
  double jresult ;
  CNTK::AdditionalLearningOptions *arg1 = (CNTK::AdditionalLearningOptions *) 0 ;
  double result;
  
  arg1 = (CNTK::AdditionalLearningOptions *)jarg1; 
  result = (double) ((arg1)->gradientClippingThresholdPerSample);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AdditionalLearningOptions_gradientClippingWithTruncation_set(void * jarg1, unsigned int jarg2) {
  CNTK::AdditionalLearningOptions *arg1 = (CNTK::AdditionalLearningOptions *) 0 ;
  bool arg2 ;
  
  arg1 = (CNTK::AdditionalLearningOptions *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->gradientClippingWithTruncation = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_AdditionalLearningOptions_gradientClippingWithTruncation_get(void * jarg1) {
  unsigned int jresult ;
  CNTK::AdditionalLearningOptions *arg1 = (CNTK::AdditionalLearningOptions *) 0 ;
  bool result;
  
  arg1 = (CNTK::AdditionalLearningOptions *)jarg1; 
  result = (bool) ((arg1)->gradientClippingWithTruncation);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_AdditionalLearningOptions_dictOptions_set(void * jarg1, void * jarg2) {
  CNTK::AdditionalLearningOptions *arg1 = (CNTK::AdditionalLearningOptions *) 0 ;
  CNTK::Dictionary *arg2 = (CNTK::Dictionary *) 0 ;
  
  arg1 = (CNTK::AdditionalLearningOptions *)jarg1; 
  arg2 = (CNTK::Dictionary *)jarg2; 
  if (arg1) (arg1)->dictOptions = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdditionalLearningOptions_dictOptions_get(void * jarg1) {
  void * jresult ;
  CNTK::AdditionalLearningOptions *arg1 = (CNTK::AdditionalLearningOptions *) 0 ;
  CNTK::Dictionary *result = 0 ;
  
  arg1 = (CNTK::AdditionalLearningOptions *)jarg1; 
  result = (CNTK::Dictionary *)& ((arg1)->dictOptions);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_AdditionalLearningOptions() {
  void * jresult ;
  CNTK::AdditionalLearningOptions *result = 0 ;
  
  {
    try {
      result = (CNTK::AdditionalLearningOptions *)new CNTK::AdditionalLearningOptions(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_AdditionalLearningOptions(void * jarg1) {
  CNTK::AdditionalLearningOptions *arg1 = (CNTK::AdditionalLearningOptions *) 0 ;
  
  arg1 = (CNTK::AdditionalLearningOptions *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Learner_MinibatchSizeKey_get() {
  void * jresult ;
  std::wstring *result = 0 ;
  
  result = (std::wstring *) &CNTK::Learner::MinibatchSizeKey;
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Learner_IgnoredMinibatchSize_get() {
  unsigned long jresult ;
  size_t result;
  
  result = (size_t)CNTK::Learner::IgnoredMinibatchSize;
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Learner_Update(void * jarg1, void * jarg2, unsigned long jarg3, unsigned int jarg4) {
  unsigned int jresult ;
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::unordered_map< CNTK::Parameter,CNTK::NDArrayViewPtr > *arg2 = 0 ;
  size_t arg3 ;
  bool arg4 ;
  std::shared_ptr< CNTK::Learner > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Parameter,CNTK::NDArrayViewPtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Parameter,CNTK::NDArrayViewPtr > & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = (bool)(arg1)->Update(*arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Learner_Parameters(void * jarg1) {
  void * jresult ;
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner const > *smartarg1 = 0 ;
  std::vector< CNTK::Parameter > *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (std::vector< CNTK::Parameter > *) &((CNTK::Learner const *)arg1)->Parameters(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Learner_CreateCheckpoint(void * jarg1) {
  void * jresult ;
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner > *smartarg1 = 0 ;
  CNTK::Dictionary result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (arg1)->CreateCheckpoint(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Dictionary((const CNTK::Dictionary &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Learner_RestoreFromCheckpoint(void * jarg1, void * jarg2) {
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  CNTK::Dictionary *arg2 = 0 ;
  std::shared_ptr< CNTK::Learner > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::Dictionary *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->RestoreFromCheckpoint((CNTK::Dictionary const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_Learner(void * jarg1) {
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (void)arg1; delete smartarg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Learner_CurrentVersion(void * jarg1) {
  unsigned long jresult ;
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Learner const *)arg1)->CurrentVersion(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Learner_ResetLearningRate(void * jarg1, void * jarg2) {
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  std::shared_ptr< CNTK::Learner > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->ResetLearningRate((CNTK::LearningRateSchedule const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Learner_ResetSmoothedGradients(void * jarg1) {
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (arg1)->ResetSmoothedGradients(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Learner_SetNeedToUpdateMasterParameter(void * jarg1) {
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (arg1)->SetNeedToUpdateMasterParameter(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Learner_LearningRate(void * jarg1) {
  double jresult ;
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner const > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (double)((CNTK::Learner const *)arg1)->LearningRate(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Learner_TotalNumberOfSamplesSeen(void * jarg1) {
  unsigned long jresult ;
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Learner const *)arg1)->TotalNumberOfSamplesSeen(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Learner_TotalNumberOfMinibatchesSeen(void * jarg1) {
  unsigned long jresult ;
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Learner const *)arg1)->TotalNumberOfMinibatchesSeen(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Learner_TotalNumberOfSweepsSeen(void * jarg1) {
  unsigned long jresult ;
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Learner const *)arg1)->TotalNumberOfSweepsSeen(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Learner_AddProgressWriters(void * jarg1, void * jarg2) {
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::vector< CNTK::ProgressWriterPtr > *arg2 = 0 ;
  std::shared_ptr< CNTK::Learner > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::vector< CNTK::ProgressWriterPtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::ProgressWriterPtr > const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->AddProgressWriters((std::vector< CNTK::ProgressWriterPtr > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Learner_SetMinibatchSize(void * jarg1, unsigned long jarg2) {
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::size_t arg2 ;
  std::shared_ptr< CNTK::Learner > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::size_t)jarg2; 
  {
    try {
      (arg1)->SetMinibatchSize(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Learner_GetMinibatchSize(void * jarg1) {
  unsigned long jresult ;
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner const > *smartarg1 = 0 ;
  std::size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Learner const *)arg1)->GetMinibatchSize(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Learner_SetLearningRateSchedule(void * jarg1, void * jarg2) {
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  std::shared_ptr< CNTK::Learner > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->SetLearningRateSchedule((CNTK::LearningRateSchedule const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Learner_GetLearningRateSchedule(void * jarg1) {
  void * jresult ;
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner const > *smartarg1 = 0 ;
  CNTK::LearningRateSchedule *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (CNTK::LearningRateSchedule *) &((CNTK::Learner const *)arg1)->GetLearningRateSchedule(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Learner_IsCompatibleMode(void * jarg1) {
  unsigned int jresult ;
  CNTK::Learner *arg1 = (CNTK::Learner *) 0 ;
  std::shared_ptr< CNTK::Learner const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Learner > *)jarg1;
  arg1 = (CNTK::Learner *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)((CNTK::Learner const *)arg1)->IsCompatibleMode(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SGDLearner__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::AdditionalLearningOptions arg3 ;
  CNTK::AdditionalLearningOptions *argp3 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  argp3 = (CNTK::AdditionalLearningOptions *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null CNTK::AdditionalLearningOptions", 0);
    return 0;
  }
  arg3 = *argp3; 
  {
    try {
      result = CNTK::SGDLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_SGDLearner__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::SGDLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MomentumSGDLearner__SWIG_0(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4, void * jarg5) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  bool arg4 ;
  CNTK::AdditionalLearningOptions arg5 ;
  CNTK::AdditionalLearningOptions *argp5 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  argp5 = (CNTK::AdditionalLearningOptions *)jarg5; 
  if (!argp5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null CNTK::AdditionalLearningOptions", 0);
    return 0;
  }
  arg5 = *argp5; 
  {
    try {
      result = CNTK::MomentumSGDLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3,arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MomentumSGDLearner__SWIG_1(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  bool arg4 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK::MomentumSGDLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MomentumSGDLearner__SWIG_2(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::MomentumSGDLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FSAdaGradLearner__SWIG_0(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4, void * jarg5, void * jarg6) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  bool arg4 ;
  CNTK::MomentumSchedule *arg5 = 0 ;
  CNTK::AdditionalLearningOptions arg6 ;
  CNTK::AdditionalLearningOptions *argp6 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  arg5 = (CNTK::MomentumSchedule *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  argp6 = (CNTK::AdditionalLearningOptions *)jarg6; 
  if (!argp6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null CNTK::AdditionalLearningOptions", 0);
    return 0;
  }
  arg6 = *argp6; 
  {
    try {
      result = CNTK::FSAdaGradLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3,arg4,(CNTK::TrainingParameterSchedule< double > const &)*arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FSAdaGradLearner__SWIG_1(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4, void * jarg5) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  bool arg4 ;
  CNTK::MomentumSchedule *arg5 = 0 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  arg5 = (CNTK::MomentumSchedule *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::FSAdaGradLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3,arg4,(CNTK::TrainingParameterSchedule< double > const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FSAdaGradLearner__SWIG_2(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  bool arg4 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK::FSAdaGradLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_FSAdaGradLearner__SWIG_3(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::FSAdaGradLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdamLearner__SWIG_0(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4, void * jarg5, double jarg6, unsigned int jarg7, void * jarg8) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  bool arg4 ;
  CNTK::MomentumSchedule *arg5 = 0 ;
  double arg6 ;
  bool arg7 ;
  CNTK::AdditionalLearningOptions arg8 ;
  CNTK::AdditionalLearningOptions *argp8 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  arg5 = (CNTK::MomentumSchedule *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg6 = (double)jarg6; 
  arg7 = jarg7 ? true : false; 
  argp8 = (CNTK::AdditionalLearningOptions *)jarg8; 
  if (!argp8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null CNTK::AdditionalLearningOptions", 0);
    return 0;
  }
  arg8 = *argp8; 
  {
    try {
      result = CNTK::AdamLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3,arg4,(CNTK::TrainingParameterSchedule< double > const &)*arg5,arg6,arg7,arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdamLearner__SWIG_1(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4, void * jarg5, double jarg6, unsigned int jarg7) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  bool arg4 ;
  CNTK::MomentumSchedule *arg5 = 0 ;
  double arg6 ;
  bool arg7 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  arg5 = (CNTK::MomentumSchedule *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg6 = (double)jarg6; 
  arg7 = jarg7 ? true : false; 
  {
    try {
      result = CNTK::AdamLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3,arg4,(CNTK::TrainingParameterSchedule< double > const &)*arg5,arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdamLearner__SWIG_2(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4, void * jarg5, double jarg6) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  bool arg4 ;
  CNTK::MomentumSchedule *arg5 = 0 ;
  double arg6 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  arg5 = (CNTK::MomentumSchedule *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg6 = (double)jarg6; 
  {
    try {
      result = CNTK::AdamLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3,arg4,(CNTK::TrainingParameterSchedule< double > const &)*arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdamLearner__SWIG_3(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4, void * jarg5) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  bool arg4 ;
  CNTK::MomentumSchedule *arg5 = 0 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  arg5 = (CNTK::MomentumSchedule *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::AdamLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3,arg4,(CNTK::TrainingParameterSchedule< double > const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdamLearner__SWIG_4(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  bool arg4 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK::AdamLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdamLearner__SWIG_5(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::MomentumSchedule *arg3 = 0 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::MomentumSchedule *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MomentumSchedule const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::AdamLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,(CNTK::TrainingParameterSchedule< double > const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdaGradLearner__SWIG_0(void * jarg1, void * jarg2, unsigned int jarg3, void * jarg4) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  bool arg3 ;
  CNTK::AdditionalLearningOptions arg4 ;
  CNTK::AdditionalLearningOptions *argp4 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  argp4 = (CNTK::AdditionalLearningOptions *)jarg4; 
  if (!argp4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null CNTK::AdditionalLearningOptions", 0);
    return 0;
  }
  arg4 = *argp4; 
  {
    try {
      result = CNTK::AdaGradLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdaGradLearner__SWIG_1(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  bool arg3 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = CNTK::AdaGradLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdaGradLearner__SWIG_2(void * jarg1, void * jarg2) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::AdaGradLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_RMSPropLearner__SWIG_0(void * jarg1, void * jarg2, double jarg3, double jarg4, double jarg5, double jarg6, double jarg7, unsigned int jarg8, void * jarg9) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  bool arg8 ;
  CNTK::AdditionalLearningOptions arg9 ;
  CNTK::AdditionalLearningOptions *argp9 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (double)jarg6; 
  arg7 = (double)jarg7; 
  arg8 = jarg8 ? true : false; 
  argp9 = (CNTK::AdditionalLearningOptions *)jarg9; 
  if (!argp9) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null CNTK::AdditionalLearningOptions", 0);
    return 0;
  }
  arg9 = *argp9; 
  {
    try {
      result = CNTK::RMSPropLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_RMSPropLearner__SWIG_1(void * jarg1, void * jarg2, double jarg3, double jarg4, double jarg5, double jarg6, double jarg7, unsigned int jarg8) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  bool arg8 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (double)jarg6; 
  arg7 = (double)jarg7; 
  arg8 = jarg8 ? true : false; 
  {
    try {
      result = CNTK::RMSPropLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_RMSPropLearner__SWIG_2(void * jarg1, void * jarg2, double jarg3, double jarg4, double jarg5, double jarg6, double jarg7) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (double)jarg6; 
  arg7 = (double)jarg7; 
  {
    try {
      result = CNTK::RMSPropLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdaDeltaLearner__SWIG_0(void * jarg1, void * jarg2, double jarg3, double jarg4, void * jarg5) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  double arg3 ;
  double arg4 ;
  CNTK::AdditionalLearningOptions arg5 ;
  CNTK::AdditionalLearningOptions *argp5 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  argp5 = (CNTK::AdditionalLearningOptions *)jarg5; 
  if (!argp5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null CNTK::AdditionalLearningOptions", 0);
    return 0;
  }
  arg5 = *argp5; 
  {
    try {
      result = CNTK::AdaDeltaLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,arg3,arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdaDeltaLearner__SWIG_1(void * jarg1, void * jarg2, double jarg3, double jarg4) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  double arg3 ;
  double arg4 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  {
    try {
      result = CNTK::AdaDeltaLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdaDeltaLearner__SWIG_2(void * jarg1, void * jarg2, double jarg3) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  double arg3 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  arg3 = (double)jarg3; 
  {
    try {
      result = CNTK::AdaDeltaLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_AdaDeltaLearner__SWIG_3(void * jarg1, void * jarg2) {
  void * jresult ;
  std::vector< CNTK::Parameter > *arg1 = 0 ;
  CNTK::LearningRateSchedule *arg2 = 0 ;
  CNTK::LearnerPtr result;
  
  arg1 = (std::vector< CNTK::Parameter > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Parameter > const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::LearningRateSchedule *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::LearningRateSchedule const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::AdaDeltaLearner((std::vector< CNTK::Parameter > const &)*arg1,(CNTK::TrainingParameterSchedule< double > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::LearnerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Evaluator_TestMinibatch__SWIG_0(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  double jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  bool arg4 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = (double)(arg1)->TestMinibatch((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Evaluator_TestMinibatch__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  double jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (double)(arg1)->TestMinibatch((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Evaluator_TestMinibatch__SWIG_2(void * jarg1, void * jarg2) {
  double jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg2 = 0 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (double)(arg1)->TestMinibatch((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Evaluator_TestMinibatch__SWIG_3(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  double jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  bool arg4 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = (double)(arg1)->TestMinibatch((std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Evaluator_TestMinibatch__SWIG_4(void * jarg1, void * jarg2, void * jarg3) {
  double jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (double)(arg1)->TestMinibatch((std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Evaluator_TestMinibatch__SWIG_5(void * jarg1, void * jarg2) {
  double jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg2 = 0 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (double)(arg1)->TestMinibatch((std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Evaluator_TestMinibatch__SWIG_6(void * jarg1, void * jarg2, void * jarg3, void * jarg4, unsigned int jarg5) {
  double jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = (double)(arg1)->TestMinibatch((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const &)*arg2,*arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Evaluator_TestMinibatch__SWIG_7(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  double jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (double)(arg1)->TestMinibatch((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const &)*arg2,*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Evaluator_TestMinibatch__SWIG_8(void * jarg1, void * jarg2, void * jarg3) {
  double jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg3 = 0 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (double)(arg1)->TestMinibatch((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const &)*arg2,*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Evaluator_TestMinibatch__SWIG_9(void * jarg1, void * jarg2, void * jarg3, void * jarg4, unsigned int jarg5) {
  double jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  bool arg5 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = (double)(arg1)->TestMinibatch((std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const &)*arg2,*arg3,(CNTK::DeviceDescriptor const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Evaluator_TestMinibatch__SWIG_10(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  double jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (double)(arg1)->TestMinibatch((std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const &)*arg2,*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Evaluator_TestMinibatch__SWIG_11(void * jarg1, void * jarg2, void * jarg3) {
  double jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg3 = 0 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (double)(arg1)->TestMinibatch((std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const &)*arg2,*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Evaluator_EvaluationFunction(void * jarg1) {
  void * jresult ;
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::shared_ptr< CNTK::Evaluator const > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Evaluator const *)arg1)->EvaluationFunction(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Evaluator_SummarizeTestProgress(void * jarg1) {
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (arg1)->SummarizeTestProgress(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Evaluator_PrintNodeTiming(void * jarg1) {
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (arg1)->PrintNodeTiming(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_Evaluator(void * jarg1) {
  CNTK::Evaluator *arg1 = (CNTK::Evaluator *) 0 ;
  std::shared_ptr< CNTK::Evaluator > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Evaluator > *)jarg1;
  arg1 = (CNTK::Evaluator *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (void)arg1; delete smartarg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CreateEvaluator__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::FunctionPtr *arg1 = 0 ;
  std::vector< CNTK::ProgressWriterPtr > *arg2 = 0 ;
  CNTK::FunctionPtr tempnull1 ;
  CNTK::EvaluatorPtr result;
  
  arg1 = jarg1 ? (CNTK::FunctionPtr *)jarg1 : &tempnull1; 
  arg2 = (std::vector< CNTK::ProgressWriterPtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::ProgressWriterPtr > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::CreateEvaluator((std::shared_ptr< CNTK::Function > const &)*arg1,(std::vector< std::shared_ptr< CNTK::ProgressWriter > > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::EvaluatorPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CreateEvaluator__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::FunctionPtr *arg1 = 0 ;
  CNTK::FunctionPtr tempnull1 ;
  CNTK::EvaluatorPtr result;
  
  arg1 = jarg1 ? (CNTK::FunctionPtr *)jarg1 : &tempnull1; 
  {
    try {
      result = CNTK::CreateEvaluator((std::shared_ptr< CNTK::Function > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::EvaluatorPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Trainer__TrainMinibatch__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  unsigned int jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)(arg1)->TrainMinibatch((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const &)*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Trainer__TrainMinibatch__SWIG_1(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg2 = 0 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)(arg1)->TrainMinibatch((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Trainer__TrainMinibatch__SWIG_2(void * jarg1, void * jarg2, unsigned int jarg3, void * jarg4) {
  unsigned int jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg2 = 0 ;
  bool arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)(arg1)->TrainMinibatch((std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const &)*arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Trainer__TrainMinibatch__SWIG_3(void * jarg1, void * jarg2, unsigned int jarg3) {
  unsigned int jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg2 = 0 ;
  bool arg3 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = (bool)(arg1)->TrainMinibatch((std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Trainer__TrainMinibatch__SWIG_4(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  unsigned int jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg3 = 0 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)(arg1)->TrainMinibatch((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const &)*arg2,*arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Trainer__TrainMinibatch__SWIG_5(void * jarg1, void * jarg2, void * jarg3) {
  unsigned int jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *arg2 = 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg3 = 0 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::MinibatchData > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)(arg1)->TrainMinibatch((std::unordered_map< CNTK::Variable,CNTK::MinibatchData > const &)*arg2,*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Trainer__TrainMinibatch__SWIG_6(void * jarg1, void * jarg2, unsigned int jarg3, void * jarg4, void * jarg5) {
  unsigned int jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg2 = 0 ;
  bool arg3 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg4 = 0 ;
  CNTK::DeviceDescriptor *arg5 = 0 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  arg4 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > & type is null", 0);
    return 0;
  } 
  arg5 = (CNTK::DeviceDescriptor *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)(arg1)->TrainMinibatch((std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const &)*arg2,arg3,*arg4,(CNTK::DeviceDescriptor const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_Trainer__TrainMinibatch__SWIG_7(void * jarg1, void * jarg2, unsigned int jarg3, void * jarg4) {
  unsigned int jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg2 = 0 ;
  bool arg3 ;
  std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *arg4 = 0 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const & type is null", 0);
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  arg4 = (std::unordered_map< CNTK::Variable,CNTK::ValuePtr > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::Variable,CNTK::ValuePtr > & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)(arg1)->TrainMinibatch((std::unordered_map< CNTK::Variable,CNTK::ValuePtr > const &)*arg2,arg3,*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Trainer_SaveCheckpoint__SWIG_0(void * jarg1, wchar_t * jarg2, void * jarg3) {
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::Dictionary arg3 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  CNTK::Dictionary *argp3 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  argp3 = (CNTK::Dictionary *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null CNTK::Dictionary", 0);
    return ;
  }
  arg3 = *argp3; 
  {
    try {
      (arg1)->SaveCheckpoint((std::wstring const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Trainer_SaveCheckpoint__SWIG_1(void * jarg1, wchar_t * jarg2) {
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::wstring *arg2 = 0 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      (arg1)->SaveCheckpoint((std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Trainer_RestoreFromCheckpoint(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::wstring *arg2 = 0 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  CNTK::Dictionary result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = (arg1)->RestoreFromCheckpoint((std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Dictionary((const CNTK::Dictionary &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Trainer_Model(void * jarg1) {
  void * jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::shared_ptr< CNTK::Trainer const > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Trainer const *)arg1)->Model(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Trainer_LossFunction(void * jarg1) {
  void * jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::shared_ptr< CNTK::Trainer const > *smartarg1 = 0 ;
  CNTK::FunctionPtr result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Trainer const *)arg1)->LossFunction(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Trainer_PreviousMinibatchLossAverage(void * jarg1) {
  double jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::shared_ptr< CNTK::Trainer const > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (double)((CNTK::Trainer const *)arg1)->PreviousMinibatchLossAverage(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CNTK_Trainer_PreviousMinibatchEvaluationAverage(void * jarg1) {
  double jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::shared_ptr< CNTK::Trainer const > *smartarg1 = 0 ;
  double result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (double)((CNTK::Trainer const *)arg1)->PreviousMinibatchEvaluationAverage(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Trainer_PreviousMinibatchSampleCount(void * jarg1) {
  unsigned long jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::shared_ptr< CNTK::Trainer const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Trainer const *)arg1)->PreviousMinibatchSampleCount(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Trainer_TotalNumberOfSamplesSeen(void * jarg1) {
  unsigned long jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::shared_ptr< CNTK::Trainer const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Trainer const *)arg1)->TotalNumberOfSamplesSeen(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Trainer_TotalNumberOfUnitsSeen__SWIG_0(void * jarg1, int jarg2) {
  unsigned long jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  CNTK::DataUnit arg2 ;
  std::shared_ptr< CNTK::Trainer const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::DataUnit)jarg2; 
  {
    try {
      result = ((CNTK::Trainer const *)arg1)->TotalNumberOfUnitsSeen(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_Trainer_TotalNumberOfUnitsSeen__SWIG_1(void * jarg1) {
  unsigned long jresult ;
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::shared_ptr< CNTK::Trainer const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::Trainer const *)arg1)->TotalNumberOfUnitsSeen(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Trainer_SummarizeTrainingProgress(void * jarg1) {
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (arg1)->SummarizeTrainingProgress(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_Trainer_PrintNodeTiming(void * jarg1) {
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (arg1)->PrintNodeTiming(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_Trainer(void * jarg1) {
  CNTK::Trainer *arg1 = (CNTK::Trainer *) 0 ;
  std::shared_ptr< CNTK::Trainer > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::Trainer > *)jarg1;
  arg1 = (CNTK::Trainer *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (void)arg1; delete smartarg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CreateTrainer__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::FunctionPtr *arg1 = 0 ;
  CNTK::FunctionPtr *arg2 = 0 ;
  std::vector< CNTK::LearnerPtr > *arg3 = 0 ;
  std::vector< CNTK::ProgressWriterPtr > *arg4 = 0 ;
  CNTK::FunctionPtr tempnull1 ;
  CNTK::FunctionPtr tempnull2 ;
  CNTK::TrainerPtr result;
  
  arg1 = jarg1 ? (CNTK::FunctionPtr *)jarg1 : &tempnull1; 
  arg2 = jarg2 ? (CNTK::FunctionPtr *)jarg2 : &tempnull2; 
  arg3 = (std::vector< CNTK::LearnerPtr > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::LearnerPtr > const & type is null", 0);
    return 0;
  } 
  arg4 = (std::vector< CNTK::ProgressWriterPtr > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::ProgressWriterPtr > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::CreateTrainer((std::shared_ptr< CNTK::Function > const &)*arg1,(std::shared_ptr< CNTK::Function > const &)*arg2,(std::vector< std::shared_ptr< CNTK::Learner > > const &)*arg3,(std::vector< std::shared_ptr< CNTK::ProgressWriter > > const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::TrainerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CreateTrainer__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CNTK::FunctionPtr *arg1 = 0 ;
  CNTK::FunctionPtr *arg2 = 0 ;
  std::vector< CNTK::LearnerPtr > *arg3 = 0 ;
  CNTK::FunctionPtr tempnull1 ;
  CNTK::FunctionPtr tempnull2 ;
  CNTK::TrainerPtr result;
  
  arg1 = jarg1 ? (CNTK::FunctionPtr *)jarg1 : &tempnull1; 
  arg2 = jarg2 ? (CNTK::FunctionPtr *)jarg2 : &tempnull2; 
  arg3 = (std::vector< CNTK::LearnerPtr > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::LearnerPtr > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::CreateTrainer((std::shared_ptr< CNTK::Function > const &)*arg1,(std::shared_ptr< CNTK::Function > const &)*arg2,(std::vector< std::shared_ptr< CNTK::Learner > > const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::TrainerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CreateTrainer__SWIG_2(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5) {
  void * jresult ;
  CNTK::FunctionPtr *arg1 = 0 ;
  CNTK::FunctionPtr *arg2 = 0 ;
  CNTK::FunctionPtr *arg3 = 0 ;
  std::vector< CNTK::LearnerPtr > *arg4 = 0 ;
  std::vector< CNTK::ProgressWriterPtr > *arg5 = 0 ;
  CNTK::FunctionPtr tempnull1 ;
  CNTK::FunctionPtr tempnull2 ;
  CNTK::FunctionPtr tempnull3 ;
  CNTK::TrainerPtr result;
  
  arg1 = jarg1 ? (CNTK::FunctionPtr *)jarg1 : &tempnull1; 
  arg2 = jarg2 ? (CNTK::FunctionPtr *)jarg2 : &tempnull2; 
  arg3 = jarg3 ? (CNTK::FunctionPtr *)jarg3 : &tempnull3; 
  arg4 = (std::vector< CNTK::LearnerPtr > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::LearnerPtr > const & type is null", 0);
    return 0;
  } 
  arg5 = (std::vector< CNTK::ProgressWriterPtr > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::ProgressWriterPtr > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::CreateTrainer((std::shared_ptr< CNTK::Function > const &)*arg1,(std::shared_ptr< CNTK::Function > const &)*arg2,(std::shared_ptr< CNTK::Function > const &)*arg3,(std::vector< std::shared_ptr< CNTK::Learner > > const &)*arg4,(std::vector< std::shared_ptr< CNTK::ProgressWriter > > const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::TrainerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CreateTrainer__SWIG_3(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::FunctionPtr *arg1 = 0 ;
  CNTK::FunctionPtr *arg2 = 0 ;
  CNTK::FunctionPtr *arg3 = 0 ;
  std::vector< CNTK::LearnerPtr > *arg4 = 0 ;
  CNTK::FunctionPtr tempnull1 ;
  CNTK::FunctionPtr tempnull2 ;
  CNTK::FunctionPtr tempnull3 ;
  CNTK::TrainerPtr result;
  
  arg1 = jarg1 ? (CNTK::FunctionPtr *)jarg1 : &tempnull1; 
  arg2 = jarg2 ? (CNTK::FunctionPtr *)jarg2 : &tempnull2; 
  arg3 = jarg3 ? (CNTK::FunctionPtr *)jarg3 : &tempnull3; 
  arg4 = (std::vector< CNTK::LearnerPtr > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::LearnerPtr > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::CreateTrainer((std::shared_ptr< CNTK::Function > const &)*arg1,(std::shared_ptr< CNTK::Function > const &)*arg2,(std::shared_ptr< CNTK::Function > const &)*arg3,(std::vector< std::shared_ptr< CNTK::Learner > > const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::TrainerPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_MinibatchData__SWIG_0() {
  void * jresult ;
  CNTK::MinibatchData *result = 0 ;
  
  {
    try {
      result = (CNTK::MinibatchData *)new CNTK::MinibatchData(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_MinibatchData__SWIG_1(void * jarg1) {
  void * jresult ;
  CNTK::ValuePtr arg1 ;
  CNTK::MinibatchData *result = 0 ;
  
  if (jarg1) arg1 = *(CNTK::ValuePtr *)jarg1; 
  {
    try {
      result = (CNTK::MinibatchData *)new CNTK::MinibatchData(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_MinibatchData__SWIG_2(void * jarg1, unsigned long jarg2, unsigned int jarg3) {
  void * jresult ;
  CNTK::ValuePtr arg1 ;
  size_t arg2 ;
  bool arg3 ;
  CNTK::MinibatchData *result = 0 ;
  
  if (jarg1) arg1 = *(CNTK::ValuePtr *)jarg1; 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = (CNTK::MinibatchData *)new CNTK::MinibatchData(arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_MinibatchData__SWIG_3(void * jarg1, unsigned long jarg2) {
  void * jresult ;
  CNTK::ValuePtr arg1 ;
  size_t arg2 ;
  CNTK::MinibatchData *result = 0 ;
  
  if (jarg1) arg1 = *(CNTK::ValuePtr *)jarg1; 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = (CNTK::MinibatchData *)new CNTK::MinibatchData(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_MinibatchData__SWIG_4(void * jarg1, unsigned long jarg2, unsigned long jarg3, unsigned int jarg4) {
  void * jresult ;
  CNTK::ValuePtr arg1 ;
  size_t arg2 ;
  size_t arg3 ;
  bool arg4 ;
  CNTK::MinibatchData *result = 0 ;
  
  if (jarg1) arg1 = *(CNTK::ValuePtr *)jarg1; 
  arg2 = (size_t)jarg2; 
  arg3 = (size_t)jarg3; 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = (CNTK::MinibatchData *)new CNTK::MinibatchData(arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchData_AsString(void * jarg1) {
  void * jresult ;
  CNTK::MinibatchData *arg1 = (CNTK::MinibatchData *) 0 ;
  std::wstring result;
  
  arg1 = (CNTK::MinibatchData *)jarg1; 
  {
    try {
      result = ((CNTK::MinibatchData const *)arg1)->AsString(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchData_data_set(void * jarg1, void * jarg2) {
  CNTK::MinibatchData *arg1 = (CNTK::MinibatchData *) 0 ;
  CNTK::ValuePtr *arg2 = 0 ;
  CNTK::ValuePtr tempnull2 ;
  
  arg1 = (CNTK::MinibatchData *)jarg1; 
  arg2 = jarg2 ? (CNTK::ValuePtr *)jarg2 : &tempnull2; 
  if (arg1) (arg1)->data = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchData_data_get(void * jarg1) {
  void * jresult ;
  CNTK::MinibatchData *arg1 = (CNTK::MinibatchData *) 0 ;
  CNTK::ValuePtr *result = 0 ;
  
  arg1 = (CNTK::MinibatchData *)jarg1; 
  result = (CNTK::ValuePtr *) & ((arg1)->data);
  jresult = *result ? new CNTK::ValuePtr(*result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchData_numberOfSequences_set(void * jarg1, unsigned long jarg2) {
  CNTK::MinibatchData *arg1 = (CNTK::MinibatchData *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::MinibatchData *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->numberOfSequences = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_MinibatchData_numberOfSequences_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::MinibatchData *arg1 = (CNTK::MinibatchData *) 0 ;
  size_t result;
  
  arg1 = (CNTK::MinibatchData *)jarg1; 
  result =  ((arg1)->numberOfSequences);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchData_numberOfSamples_set(void * jarg1, unsigned long jarg2) {
  CNTK::MinibatchData *arg1 = (CNTK::MinibatchData *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::MinibatchData *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->numberOfSamples = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_MinibatchData_numberOfSamples_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::MinibatchData *arg1 = (CNTK::MinibatchData *) 0 ;
  size_t result;
  
  arg1 = (CNTK::MinibatchData *)jarg1; 
  result =  ((arg1)->numberOfSamples);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchData_sweepEnd_set(void * jarg1, unsigned int jarg2) {
  CNTK::MinibatchData *arg1 = (CNTK::MinibatchData *) 0 ;
  bool arg2 ;
  
  arg1 = (CNTK::MinibatchData *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->sweepEnd = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_MinibatchData_sweepEnd_get(void * jarg1) {
  unsigned int jresult ;
  CNTK::MinibatchData *arg1 = (CNTK::MinibatchData *) 0 ;
  bool result;
  
  arg1 = (CNTK::MinibatchData *)jarg1; 
  result = (bool) ((arg1)->sweepEnd);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_MinibatchData(void * jarg1) {
  CNTK::MinibatchData *arg1 = (CNTK::MinibatchData *) 0 ;
  
  arg1 = (CNTK::MinibatchData *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_GetNextMinibatch__SWIG_0(void * jarg1, unsigned long jarg2, unsigned long jarg3, void * jarg4) {
  void * jresult ;
  CNTK::MinibatchSource *arg1 = (CNTK::MinibatchSource *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  CNTK::DeviceDescriptor *arg4 = 0 ;
  std::shared_ptr< CNTK::MinibatchSource > *smartarg1 = 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::MinibatchSource > *)jarg1;
  arg1 = (CNTK::MinibatchSource *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (size_t)jarg2; 
  arg3 = (size_t)jarg3; 
  arg4 = (CNTK::DeviceDescriptor *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) &(arg1)->GetNextMinibatch(arg2,arg3,(CNTK::DeviceDescriptor const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_GetNextMinibatch__SWIG_1(void * jarg1, unsigned long jarg2, unsigned long jarg3) {
  void * jresult ;
  CNTK::MinibatchSource *arg1 = (CNTK::MinibatchSource *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  std::shared_ptr< CNTK::MinibatchSource > *smartarg1 = 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::MinibatchSource > *)jarg1;
  arg1 = (CNTK::MinibatchSource *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (size_t)jarg2; 
  arg3 = (size_t)jarg3; 
  {
    try {
      result = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) &(arg1)->GetNextMinibatch(arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_GetNextMinibatch__SWIG_2(void * jarg1, unsigned long jarg2, unsigned long jarg3, unsigned long jarg4, unsigned long jarg5, void * jarg6) {
  void * jresult ;
  CNTK::MinibatchSource *arg1 = (CNTK::MinibatchSource *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  CNTK::DeviceDescriptor *arg6 = 0 ;
  std::shared_ptr< CNTK::MinibatchSource > *smartarg1 = 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::MinibatchSource > *)jarg1;
  arg1 = (CNTK::MinibatchSource *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (size_t)jarg2; 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  arg5 = (size_t)jarg5; 
  arg6 = (CNTK::DeviceDescriptor *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) &(arg1)->GetNextMinibatch(arg2,arg3,arg4,arg5,(CNTK::DeviceDescriptor const &)*arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_GetNextMinibatch__SWIG_3(void * jarg1, unsigned long jarg2, unsigned long jarg3, unsigned long jarg4, unsigned long jarg5) {
  void * jresult ;
  CNTK::MinibatchSource *arg1 = (CNTK::MinibatchSource *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  std::shared_ptr< CNTK::MinibatchSource > *smartarg1 = 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::MinibatchSource > *)jarg1;
  arg1 = (CNTK::MinibatchSource *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (size_t)jarg2; 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  arg5 = (size_t)jarg5; 
  {
    try {
      result = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) &(arg1)->GetNextMinibatch(arg2,arg3,arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_MinibatchSource(void * jarg1) {
  CNTK::MinibatchSource *arg1 = (CNTK::MinibatchSource *) 0 ;
  std::shared_ptr< CNTK::MinibatchSource > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::MinibatchSource > *)jarg1;
  arg1 = (CNTK::MinibatchSource *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (void)arg1; delete smartarg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_GetCheckpointState(void * jarg1) {
  void * jresult ;
  CNTK::MinibatchSource *arg1 = (CNTK::MinibatchSource *) 0 ;
  std::shared_ptr< CNTK::MinibatchSource const > *smartarg1 = 0 ;
  CNTK::Dictionary result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::MinibatchSource > *)jarg1;
  arg1 = (CNTK::MinibatchSource *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::MinibatchSource const *)arg1)->GetCheckpointState(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Dictionary((const CNTK::Dictionary &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSource_RestoreFromCheckpoint(void * jarg1, void * jarg2) {
  CNTK::MinibatchSource *arg1 = (CNTK::MinibatchSource *) 0 ;
  CNTK::Dictionary *arg2 = 0 ;
  std::shared_ptr< CNTK::MinibatchSource > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::MinibatchSource > *)jarg1;
  arg1 = (CNTK::MinibatchSource *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::Dictionary *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->RestoreFromCheckpoint((CNTK::Dictionary const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_MinibatchSource_IsInfinite(void * jarg1) {
  unsigned int jresult ;
  CNTK::MinibatchSource *arg1 = (CNTK::MinibatchSource *) 0 ;
  std::shared_ptr< CNTK::MinibatchSource > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::MinibatchSource > *)jarg1;
  arg1 = (CNTK::MinibatchSource *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = (bool)(arg1)->IsInfinite(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_StreamInfo__SWIG_0(void * jarg1, wchar_t * jarg2) {
  void * jresult ;
  CNTK::MinibatchSource *arg1 = (CNTK::MinibatchSource *) 0 ;
  std::wstring *arg2 = 0 ;
  std::shared_ptr< CNTK::MinibatchSource > *smartarg1 = 0 ;
  CNTK::StreamInformation *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::MinibatchSource > *)jarg1;
  arg1 = (CNTK::MinibatchSource *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = (CNTK::StreamInformation *) &(arg1)->StreamInfo((std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_StreamInfo__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::MinibatchSource *arg1 = (CNTK::MinibatchSource *) 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::shared_ptr< CNTK::MinibatchSource > *smartarg1 = 0 ;
  CNTK::StreamInformation *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::MinibatchSource > *)jarg1;
  arg1 = (CNTK::MinibatchSource *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::StreamInformation *) &(arg1)->StreamInfo((CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_GetNextMinibatch__SWIG_4(void * jarg1, unsigned long jarg2, void * jarg3) {
  void * jresult ;
  CNTK::MinibatchSource *arg1 = (CNTK::MinibatchSource *) 0 ;
  size_t arg2 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  std::shared_ptr< CNTK::MinibatchSource > *smartarg1 = 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::MinibatchSource > *)jarg1;
  arg1 = (CNTK::MinibatchSource *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (size_t)jarg2; 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) &(arg1)->GetNextMinibatch(arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_GetNextMinibatch__SWIG_5(void * jarg1, unsigned long jarg2) {
  void * jresult ;
  CNTK::MinibatchSource *arg1 = (CNTK::MinibatchSource *) 0 ;
  size_t arg2 ;
  std::shared_ptr< CNTK::MinibatchSource > *smartarg1 = 0 ;
  std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::MinibatchSource > *)jarg1;
  arg1 = (CNTK::MinibatchSource *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = (std::unordered_map< CNTK::StreamInformation,CNTK::MinibatchData > *) &(arg1)->GetNextMinibatch(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_0(wchar_t * jarg1, void * jarg2, unsigned long long jarg3, unsigned int jarg4, unsigned long long jarg5, unsigned int jarg6) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  unsigned long long arg3 ;
  bool arg4 ;
  unsigned long long arg5 ;
  bool arg6 ;
  std::shared_ptr< CNTK::MinibatchSource > result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  arg3 = (unsigned long long)jarg3; 
  arg4 = jarg4 ? true : false; 
  arg5 = (unsigned long long)jarg5; 
  arg6 = jarg6 ? true : false; 
  {
    try {
      result = CNTK_MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_0((std::wstring const &)*arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2,arg3,arg4,arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new std::shared_ptr< CNTK::MinibatchSource >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_1(wchar_t * jarg1, void * jarg2, unsigned long long jarg3, unsigned int jarg4, unsigned long long jarg5) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  unsigned long long arg3 ;
  bool arg4 ;
  unsigned long long arg5 ;
  std::shared_ptr< CNTK::MinibatchSource > result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  arg3 = (unsigned long long)jarg3; 
  arg4 = jarg4 ? true : false; 
  arg5 = (unsigned long long)jarg5; 
  {
    try {
      result = CNTK_MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_0((std::wstring const &)*arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2,arg3,arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new std::shared_ptr< CNTK::MinibatchSource >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_2(wchar_t * jarg1, void * jarg2, unsigned long long jarg3, unsigned int jarg4) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  unsigned long long arg3 ;
  bool arg4 ;
  std::shared_ptr< CNTK::MinibatchSource > result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  arg3 = (unsigned long long)jarg3; 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK_MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_0((std::wstring const &)*arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new std::shared_ptr< CNTK::MinibatchSource >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_3(wchar_t * jarg1, void * jarg2, unsigned long long jarg3) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  unsigned long long arg3 ;
  std::shared_ptr< CNTK::MinibatchSource > result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  arg3 = (unsigned long long)jarg3; 
  {
    try {
      result = CNTK_MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_0((std::wstring const &)*arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new std::shared_ptr< CNTK::MinibatchSource >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_4(wchar_t * jarg1, void * jarg2) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  std::shared_ptr< CNTK::MinibatchSource > result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK_MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_0((std::wstring const &)*arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new std::shared_ptr< CNTK::MinibatchSource >(result) : 0; 
  return jresult;
}


SWIGEXPORT unsigned long long SWIGSTDCALL CSharp_CNTK_MinibatchSource_GetFullDataSweep() {
  unsigned long long jresult ;
  unsigned long long result;
  
  {
    try {
      result = (unsigned long long)CNTK_MinibatchSource_GetFullDataSweep(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned long long SWIGSTDCALL CSharp_CNTK_MinibatchSource_GetInfinitelyRepeat() {
  unsigned long long jresult ;
  unsigned long long result;
  
  {
    try {
      result = (unsigned long long)CNTK_MinibatchSource_GetInfinitelyRepeat(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned long long SWIGSTDCALL CSharp_CNTK_MinibatchSource_GetDefaultRandomizationWindowInChunks() {
  unsigned long long jresult ;
  unsigned long long result;
  
  {
    try {
      result = (unsigned long long)CNTK_MinibatchSource_GetDefaultRandomizationWindowInChunks(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_MinibatchSourceConfig__SWIG_0(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  std::vector< CNTK::Deserializer > *arg1 = 0 ;
  bool arg2 ;
  CNTK::MinibatchSourceConfig *result = 0 ;
  
  arg1 = (std::vector< CNTK::Deserializer > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Deserializer > const & type is null", 0);
    return 0;
  } 
  arg2 = jarg2 ? true : false; 
  {
    try {
      result = (CNTK::MinibatchSourceConfig *)new CNTK::MinibatchSourceConfig((std::vector< CNTK::Deserializer > const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_MinibatchSourceConfig__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::Deserializer > *arg1 = 0 ;
  CNTK::MinibatchSourceConfig *result = 0 ;
  
  arg1 = (std::vector< CNTK::Deserializer > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::Deserializer > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::MinibatchSourceConfig *)new CNTK::MinibatchSourceConfig((std::vector< CNTK::Deserializer > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_maxSamples_set(void * jarg1, unsigned long jarg2) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->maxSamples = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_maxSamples_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t result;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  result =  ((arg1)->maxSamples);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_maxSweeps_set(void * jarg1, unsigned long jarg2) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->maxSweeps = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_maxSweeps_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t result;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  result =  ((arg1)->maxSweeps);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_randomizationWindowInChunks_set(void * jarg1, unsigned long jarg2) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->randomizationWindowInChunks = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_randomizationWindowInChunks_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t result;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  result =  ((arg1)->randomizationWindowInChunks);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_randomizationWindowInSamples_set(void * jarg1, unsigned long jarg2) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->randomizationWindowInSamples = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_randomizationWindowInSamples_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t result;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  result =  ((arg1)->randomizationWindowInSamples);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_randomizationSeed_set(void * jarg1, unsigned long jarg2) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->randomizationSeed = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_randomizationSeed_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t result;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  result =  ((arg1)->randomizationSeed);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_traceLevel_set(void * jarg1, int jarg2) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  CNTK::TraceLevel arg2 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  arg2 = (CNTK::TraceLevel)jarg2; 
  if (arg1) (arg1)->traceLevel = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_traceLevel_get(void * jarg1) {
  int jresult ;
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  CNTK::TraceLevel result;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  result = (CNTK::TraceLevel) ((arg1)->traceLevel);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_truncationLength_set(void * jarg1, unsigned long jarg2) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->truncationLength = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_truncationLength_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t result;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  result =  ((arg1)->truncationLength);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_isFrameModeEnabled_set(void * jarg1, unsigned int jarg2) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  bool arg2 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->isFrameModeEnabled = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_isFrameModeEnabled_get(void * jarg1) {
  unsigned int jresult ;
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  bool result;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  result = (bool) ((arg1)->isFrameModeEnabled);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_deserializers_set(void * jarg1, void * jarg2) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  std::vector< CNTK::Deserializer > *arg2 = (std::vector< CNTK::Deserializer > *) 0 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  arg2 = (std::vector< CNTK::Deserializer > *)jarg2; 
  if (arg1) (arg1)->deserializers = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_deserializers_get(void * jarg1) {
  void * jresult ;
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  std::vector< CNTK::Deserializer > *result = 0 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  result = (std::vector< CNTK::Deserializer > *)& ((arg1)->deserializers);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_maxErrors_set(void * jarg1, unsigned long jarg2) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->maxErrors = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_maxErrors_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  size_t result;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  result =  ((arg1)->maxErrors);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long long SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_GetMaxSamples(void * jarg1) {
  unsigned long long jresult ;
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  unsigned long long result;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  {
    try {
      result = (unsigned long long)CNTK_MinibatchSourceConfig_GetMaxSamples(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_SetMaxSamples(void * jarg1, unsigned long long jarg2) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  unsigned long long arg2 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  arg2 = (unsigned long long)jarg2; 
  {
    try {
      CNTK_MinibatchSourceConfig_SetMaxSamples(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned long long SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_GetMaxSweeps(void * jarg1) {
  unsigned long long jresult ;
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  unsigned long long result;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  {
    try {
      result = (unsigned long long)CNTK_MinibatchSourceConfig_GetMaxSweeps(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_MinibatchSourceConfig_SetMaxSweeps(void * jarg1, unsigned long long jarg2) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  unsigned long long arg2 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  arg2 = (unsigned long long)jarg2; 
  {
    try {
      CNTK_MinibatchSourceConfig_SetMaxSweeps(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_MinibatchSourceConfig(void * jarg1) {
  CNTK::MinibatchSourceConfig *arg1 = (CNTK::MinibatchSourceConfig *) 0 ;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CreateCompositeMinibatchSource(void * jarg1) {
  void * jresult ;
  CNTK::MinibatchSourceConfig *arg1 = 0 ;
  CNTK::MinibatchSourcePtr result;
  
  arg1 = (CNTK::MinibatchSourceConfig *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::MinibatchSourceConfig const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::CreateCompositeMinibatchSource((CNTK::MinibatchSourceConfig const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::MinibatchSourcePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_StreamConfiguration__SWIG_0(wchar_t * jarg1, unsigned long jarg2, unsigned int jarg3, wchar_t * jarg4, unsigned int jarg5) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  size_t arg2 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  bool arg5 ;
  CNTK::StreamConfiguration *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = (CNTK::StreamConfiguration *)new CNTK::StreamConfiguration((std::wstring const &)*arg1,arg2,arg3,(std::wstring const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_StreamConfiguration__SWIG_1(wchar_t * jarg1, unsigned long jarg2, unsigned int jarg3, wchar_t * jarg4) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  size_t arg2 ;
  bool arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::StreamConfiguration *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3 ? true : false; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = (CNTK::StreamConfiguration *)new CNTK::StreamConfiguration((std::wstring const &)*arg1,arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_StreamConfiguration__SWIG_2(wchar_t * jarg1, unsigned long jarg2, unsigned int jarg3) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  size_t arg2 ;
  bool arg3 ;
  CNTK::StreamConfiguration *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (size_t)jarg2; 
  arg3 = jarg3 ? true : false; 
  {
    try {
      result = (CNTK::StreamConfiguration *)new CNTK::StreamConfiguration((std::wstring const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_StreamConfiguration__SWIG_3(wchar_t * jarg1, unsigned long jarg2) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  size_t arg2 ;
  CNTK::StreamConfiguration *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = (CNTK::StreamConfiguration *)new CNTK::StreamConfiguration((std::wstring const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfiguration_m_streamName_set(void * jarg1, wchar_t * jarg2) {
  CNTK::StreamConfiguration *arg1 = (CNTK::StreamConfiguration *) 0 ;
  std::wstring *arg2 = 0 ;
  
  arg1 = (CNTK::StreamConfiguration *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->m_streamName = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StreamConfiguration_m_streamName_get(void * jarg1) {
  void * jresult ;
  CNTK::StreamConfiguration *arg1 = (CNTK::StreamConfiguration *) 0 ;
  std::wstring *result = 0 ;
  
  arg1 = (CNTK::StreamConfiguration *)jarg1; 
  result = (std::wstring *) & ((arg1)->m_streamName);
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfiguration_m_dim_set(void * jarg1, unsigned long jarg2) {
  CNTK::StreamConfiguration *arg1 = (CNTK::StreamConfiguration *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::StreamConfiguration *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->m_dim = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_StreamConfiguration_m_dim_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::StreamConfiguration *arg1 = (CNTK::StreamConfiguration *) 0 ;
  size_t result;
  
  arg1 = (CNTK::StreamConfiguration *)jarg1; 
  result =  ((arg1)->m_dim);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfiguration_m_isSparse_set(void * jarg1, unsigned int jarg2) {
  CNTK::StreamConfiguration *arg1 = (CNTK::StreamConfiguration *) 0 ;
  bool arg2 ;
  
  arg1 = (CNTK::StreamConfiguration *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->m_isSparse = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_StreamConfiguration_m_isSparse_get(void * jarg1) {
  unsigned int jresult ;
  CNTK::StreamConfiguration *arg1 = (CNTK::StreamConfiguration *) 0 ;
  bool result;
  
  arg1 = (CNTK::StreamConfiguration *)jarg1; 
  result = (bool) ((arg1)->m_isSparse);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfiguration_m_streamAlias_set(void * jarg1, wchar_t * jarg2) {
  CNTK::StreamConfiguration *arg1 = (CNTK::StreamConfiguration *) 0 ;
  std::wstring *arg2 = 0 ;
  
  arg1 = (CNTK::StreamConfiguration *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->m_streamAlias = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_StreamConfiguration_m_streamAlias_get(void * jarg1) {
  void * jresult ;
  CNTK::StreamConfiguration *arg1 = (CNTK::StreamConfiguration *) 0 ;
  std::wstring *result = 0 ;
  
  arg1 = (CNTK::StreamConfiguration *)jarg1; 
  result = (std::wstring *) & ((arg1)->m_streamAlias);
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_StreamConfiguration_m_definesMbSize_set(void * jarg1, unsigned int jarg2) {
  CNTK::StreamConfiguration *arg1 = (CNTK::StreamConfiguration *) 0 ;
  bool arg2 ;
  
  arg1 = (CNTK::StreamConfiguration *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->m_definesMbSize = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_StreamConfiguration_m_definesMbSize_get(void * jarg1) {
  unsigned int jresult ;
  CNTK::StreamConfiguration *arg1 = (CNTK::StreamConfiguration *) 0 ;
  bool result;
  
  arg1 = (CNTK::StreamConfiguration *)jarg1; 
  result = (bool) ((arg1)->m_definesMbSize);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_StreamConfiguration(void * jarg1) {
  CNTK::StreamConfiguration *arg1 = (CNTK::StreamConfiguration *) 0 ;
  
  arg1 = (CNTK::StreamConfiguration *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_HTKFeatureConfiguration__SWIG_0(wchar_t * jarg1, wchar_t * jarg2, unsigned long jarg3, unsigned long jarg4, unsigned long jarg5, unsigned int jarg6, unsigned int jarg7, unsigned long jarg8) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  size_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  bool arg6 ;
  bool arg7 ;
  size_t arg8 ;
  CNTK::HTKFeatureConfiguration *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  arg5 = (size_t)jarg5; 
  arg6 = jarg6 ? true : false; 
  arg7 = jarg7 ? true : false; 
  arg8 = (size_t)jarg8; 
  {
    try {
      result = (CNTK::HTKFeatureConfiguration *)new CNTK::HTKFeatureConfiguration((std::wstring const &)*arg1,(std::wstring const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_HTKFeatureConfiguration__SWIG_1(wchar_t * jarg1, wchar_t * jarg2, unsigned long jarg3, unsigned long jarg4, unsigned long jarg5, unsigned int jarg6, unsigned int jarg7) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  size_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  bool arg6 ;
  bool arg7 ;
  CNTK::HTKFeatureConfiguration *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  arg5 = (size_t)jarg5; 
  arg6 = jarg6 ? true : false; 
  arg7 = jarg7 ? true : false; 
  {
    try {
      result = (CNTK::HTKFeatureConfiguration *)new CNTK::HTKFeatureConfiguration((std::wstring const &)*arg1,(std::wstring const &)*arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_HTKFeatureConfiguration__SWIG_2(wchar_t * jarg1, wchar_t * jarg2, unsigned long jarg3, unsigned long jarg4, unsigned long jarg5, unsigned int jarg6) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  size_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  bool arg6 ;
  CNTK::HTKFeatureConfiguration *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  arg5 = (size_t)jarg5; 
  arg6 = jarg6 ? true : false; 
  {
    try {
      result = (CNTK::HTKFeatureConfiguration *)new CNTK::HTKFeatureConfiguration((std::wstring const &)*arg1,(std::wstring const &)*arg2,arg3,arg4,arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_streamName_set(void * jarg1, wchar_t * jarg2) {
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  std::wstring *arg2 = 0 ;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->m_streamName = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_streamName_get(void * jarg1) {
  void * jresult ;
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  std::wstring *result = 0 ;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  result = (std::wstring *) & ((arg1)->m_streamName);
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_scp_set(void * jarg1, wchar_t * jarg2) {
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  std::wstring *arg2 = 0 ;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->m_scp = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_scp_get(void * jarg1) {
  void * jresult ;
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  std::wstring *result = 0 ;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  result = (std::wstring *) & ((arg1)->m_scp);
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_dim_set(void * jarg1, unsigned long jarg2) {
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->m_dim = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_dim_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  size_t result;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  result =  ((arg1)->m_dim);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_left_set(void * jarg1, unsigned long jarg2) {
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->m_left = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_left_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  size_t result;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  result =  ((arg1)->m_left);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_right_set(void * jarg1, unsigned long jarg2) {
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->m_right = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_right_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  size_t result;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  result =  ((arg1)->m_right);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_broadcast_set(void * jarg1, unsigned int jarg2) {
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  bool arg2 ;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->m_broadcast = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_broadcast_get(void * jarg1) {
  unsigned int jresult ;
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  bool result;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  result = (bool) ((arg1)->m_broadcast);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_definesMbSize_set(void * jarg1, unsigned int jarg2) {
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  bool arg2 ;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->m_definesMbSize = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_definesMbSize_get(void * jarg1) {
  unsigned int jresult ;
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  bool result;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  result = (bool) ((arg1)->m_definesMbSize);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_maxSequenceLength_set(void * jarg1, unsigned long jarg2) {
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  arg2 = (size_t)jarg2; 
  if (arg1) (arg1)->m_maxSequenceLength = arg2;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_HTKFeatureConfiguration_m_maxSequenceLength_get(void * jarg1) {
  unsigned long jresult ;
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  size_t result;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  result =  ((arg1)->m_maxSequenceLength);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_HTKFeatureConfiguration(void * jarg1) {
  CNTK::HTKFeatureConfiguration *arg1 = (CNTK::HTKFeatureConfiguration *) 0 ;
  
  arg1 = (CNTK::HTKFeatureConfiguration *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderCrop__SWIG_0(wchar_t * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, wchar_t * jarg6) {
  void * jresult ;
  wchar_t *arg1 = (wchar_t *) 0 ;
  std::pair< int,int > arg2 ;
  std::pair< float,float > arg3 ;
  std::pair< float,float > arg4 ;
  std::pair< float,float > arg5 ;
  wchar_t *arg6 = (wchar_t *) 0 ;
  std::pair< int,int > *argp2 ;
  std::pair< float,float > *argp3 ;
  std::pair< float,float > *argp4 ;
  std::pair< float,float > *argp5 ;
  CNTK::ImageTransform result;
  
  arg1 = (wchar_t *)jarg1; 
  argp2 = (std::pair< int,int > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< int,int >", 0);
    return 0;
  }
  arg2 = *argp2; 
  argp3 = (std::pair< float,float > *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< float,float >", 0);
    return 0;
  }
  arg3 = *argp3; 
  argp4 = (std::pair< float,float > *)jarg4; 
  if (!argp4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< float,float >", 0);
    return 0;
  }
  arg4 = *argp4; 
  argp5 = (std::pair< float,float > *)jarg5; 
  if (!argp5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< float,float >", 0);
    return 0;
  }
  arg5 = *argp5; 
  arg6 = (wchar_t *)jarg6; 
  {
    try {
      result = CNTK::ReaderCrop((wchar_t const *)arg1,arg2,arg3,arg4,arg5,(wchar_t const *)arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderCrop__SWIG_1(wchar_t * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5) {
  void * jresult ;
  wchar_t *arg1 = (wchar_t *) 0 ;
  std::pair< int,int > arg2 ;
  std::pair< float,float > arg3 ;
  std::pair< float,float > arg4 ;
  std::pair< float,float > arg5 ;
  std::pair< int,int > *argp2 ;
  std::pair< float,float > *argp3 ;
  std::pair< float,float > *argp4 ;
  std::pair< float,float > *argp5 ;
  CNTK::ImageTransform result;
  
  arg1 = (wchar_t *)jarg1; 
  argp2 = (std::pair< int,int > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< int,int >", 0);
    return 0;
  }
  arg2 = *argp2; 
  argp3 = (std::pair< float,float > *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< float,float >", 0);
    return 0;
  }
  arg3 = *argp3; 
  argp4 = (std::pair< float,float > *)jarg4; 
  if (!argp4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< float,float >", 0);
    return 0;
  }
  arg4 = *argp4; 
  argp5 = (std::pair< float,float > *)jarg5; 
  if (!argp5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< float,float >", 0);
    return 0;
  }
  arg5 = *argp5; 
  {
    try {
      result = CNTK::ReaderCrop((wchar_t const *)arg1,arg2,arg3,arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderCrop__SWIG_2(wchar_t * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  wchar_t *arg1 = (wchar_t *) 0 ;
  std::pair< int,int > arg2 ;
  std::pair< float,float > arg3 ;
  std::pair< float,float > arg4 ;
  std::pair< int,int > *argp2 ;
  std::pair< float,float > *argp3 ;
  std::pair< float,float > *argp4 ;
  CNTK::ImageTransform result;
  
  arg1 = (wchar_t *)jarg1; 
  argp2 = (std::pair< int,int > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< int,int >", 0);
    return 0;
  }
  arg2 = *argp2; 
  argp3 = (std::pair< float,float > *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< float,float >", 0);
    return 0;
  }
  arg3 = *argp3; 
  argp4 = (std::pair< float,float > *)jarg4; 
  if (!argp4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< float,float >", 0);
    return 0;
  }
  arg4 = *argp4; 
  {
    try {
      result = CNTK::ReaderCrop((wchar_t const *)arg1,arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderCrop__SWIG_3(wchar_t * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  wchar_t *arg1 = (wchar_t *) 0 ;
  std::pair< int,int > arg2 ;
  std::pair< float,float > arg3 ;
  std::pair< int,int > *argp2 ;
  std::pair< float,float > *argp3 ;
  CNTK::ImageTransform result;
  
  arg1 = (wchar_t *)jarg1; 
  argp2 = (std::pair< int,int > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< int,int >", 0);
    return 0;
  }
  arg2 = *argp2; 
  argp3 = (std::pair< float,float > *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< float,float >", 0);
    return 0;
  }
  arg3 = *argp3; 
  {
    try {
      result = CNTK::ReaderCrop((wchar_t const *)arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderCrop__SWIG_4(wchar_t * jarg1, void * jarg2) {
  void * jresult ;
  wchar_t *arg1 = (wchar_t *) 0 ;
  std::pair< int,int > arg2 ;
  std::pair< int,int > *argp2 ;
  CNTK::ImageTransform result;
  
  arg1 = (wchar_t *)jarg1; 
  argp2 = (std::pair< int,int > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::pair< int,int >", 0);
    return 0;
  }
  arg2 = *argp2; 
  {
    try {
      result = CNTK::ReaderCrop((wchar_t const *)arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderCrop__SWIG_5(wchar_t * jarg1) {
  void * jresult ;
  wchar_t *arg1 = (wchar_t *) 0 ;
  CNTK::ImageTransform result;
  
  arg1 = (wchar_t *)jarg1; 
  {
    try {
      result = CNTK::ReaderCrop((wchar_t const *)arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderCrop__SWIG_6() {
  void * jresult ;
  CNTK::ImageTransform result;
  
  {
    try {
      result = CNTK::ReaderCrop(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderScale__SWIG_0(int jarg1, int jarg2, int jarg3, wchar_t * jarg4, wchar_t * jarg5, int jarg6) {
  void * jresult ;
  int arg1 ;
  int arg2 ;
  int arg3 ;
  wchar_t *arg4 = (wchar_t *) 0 ;
  wchar_t *arg5 = (wchar_t *) 0 ;
  int arg6 ;
  CNTK::ImageTransform result;
  
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (wchar_t *)jarg4; 
  arg5 = (wchar_t *)jarg5; 
  arg6 = (int)jarg6; 
  {
    try {
      result = CNTK::ReaderScale(arg1,arg2,arg3,(wchar_t const *)arg4,(wchar_t const *)arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderScale__SWIG_1(int jarg1, int jarg2, int jarg3, wchar_t * jarg4, wchar_t * jarg5) {
  void * jresult ;
  int arg1 ;
  int arg2 ;
  int arg3 ;
  wchar_t *arg4 = (wchar_t *) 0 ;
  wchar_t *arg5 = (wchar_t *) 0 ;
  CNTK::ImageTransform result;
  
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (wchar_t *)jarg4; 
  arg5 = (wchar_t *)jarg5; 
  {
    try {
      result = CNTK::ReaderScale(arg1,arg2,arg3,(wchar_t const *)arg4,(wchar_t const *)arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderScale__SWIG_2(int jarg1, int jarg2, int jarg3, wchar_t * jarg4) {
  void * jresult ;
  int arg1 ;
  int arg2 ;
  int arg3 ;
  wchar_t *arg4 = (wchar_t *) 0 ;
  CNTK::ImageTransform result;
  
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (wchar_t *)jarg4; 
  {
    try {
      result = CNTK::ReaderScale(arg1,arg2,arg3,(wchar_t const *)arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderScale__SWIG_3(int jarg1, int jarg2, int jarg3) {
  void * jresult ;
  int arg1 ;
  int arg2 ;
  int arg3 ;
  CNTK::ImageTransform result;
  
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  {
    try {
      result = CNTK::ReaderScale(arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderMean(wchar_t * jarg1) {
  void * jresult ;
  wchar_t *arg1 = (wchar_t *) 0 ;
  CNTK::ImageTransform result;
  
  arg1 = (wchar_t *)jarg1; 
  {
    try {
      result = CNTK::ReaderMean((wchar_t const *)arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderColor__SWIG_0(float jarg1, float jarg2, float jarg3) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  CNTK::ImageTransform result;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  {
    try {
      result = CNTK::ReaderColor(arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderColor__SWIG_1(float jarg1, float jarg2) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  CNTK::ImageTransform result;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  {
    try {
      result = CNTK::ReaderColor(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderColor__SWIG_2(float jarg1) {
  void * jresult ;
  float arg1 ;
  CNTK::ImageTransform result;
  
  arg1 = (float)jarg1; 
  {
    try {
      result = CNTK::ReaderColor(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ReaderColor__SWIG_3() {
  void * jresult ;
  CNTK::ImageTransform result;
  
  {
    try {
      result = CNTK::ReaderColor(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::ImageTransform((const CNTK::ImageTransform &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ImageDeserializer__SWIG_0(wchar_t * jarg1, wchar_t * jarg2, unsigned long jarg3, wchar_t * jarg4, void * jarg5) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  size_t arg3 ;
  std::wstring *arg4 = 0 ;
  std::vector< CNTK::ImageTransform > *arg5 = 0 ;
  CNTK::Deserializer result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (size_t)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  arg5 = (std::vector< CNTK::ImageTransform > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::ImageTransform > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::ImageDeserializer((std::wstring const &)*arg1,(std::wstring const &)*arg2,arg3,(std::wstring const &)*arg4,(std::vector< CNTK::Dictionary > const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Deserializer((const CNTK::Deserializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_ImageDeserializer__SWIG_1(wchar_t * jarg1, wchar_t * jarg2, unsigned long jarg3, wchar_t * jarg4) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  size_t arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::Deserializer result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (size_t)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::ImageDeserializer((std::wstring const &)*arg1,(std::wstring const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Deserializer((const CNTK::Deserializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Base64ImageDeserializer__SWIG_0(wchar_t * jarg1, wchar_t * jarg2, unsigned long jarg3, wchar_t * jarg4, void * jarg5) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  size_t arg3 ;
  std::wstring *arg4 = 0 ;
  std::vector< CNTK::ImageTransform > *arg5 = 0 ;
  CNTK::Deserializer result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (size_t)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  arg5 = (std::vector< CNTK::ImageTransform > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::ImageTransform > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Base64ImageDeserializer((std::wstring const &)*arg1,(std::wstring const &)*arg2,arg3,(std::wstring const &)*arg4,(std::vector< CNTK::Dictionary > const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Deserializer((const CNTK::Deserializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Base64ImageDeserializer__SWIG_1(wchar_t * jarg1, wchar_t * jarg2, unsigned long jarg3, wchar_t * jarg4) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  size_t arg3 ;
  std::wstring *arg4 = 0 ;
  CNTK::Deserializer result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (size_t)jarg3; 
  if (!jarg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg4_str(jarg4);
  arg4 = &arg4_str; 
  {
    try {
      result = CNTK::Base64ImageDeserializer((std::wstring const &)*arg1,(std::wstring const &)*arg2,arg3,(std::wstring const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Deserializer((const CNTK::Deserializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CTFDeserializer(wchar_t * jarg1, void * jarg2) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  CNTK::Deserializer result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::CTFDeserializer((std::wstring const &)*arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Deserializer((const CNTK::Deserializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CBFDeserializer__SWIG_0(wchar_t * jarg1, void * jarg2) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  CNTK::Deserializer result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::CBFDeserializer((std::wstring const &)*arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Deserializer((const CNTK::Deserializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_CBFDeserializer__SWIG_1(wchar_t * jarg1) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  CNTK::Deserializer result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  {
    try {
      result = CNTK::CBFDeserializer((std::wstring const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Deserializer((const CNTK::Deserializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HTKFeatureDeserializer(void * jarg1) {
  void * jresult ;
  std::vector< CNTK::HTKFeatureConfiguration > *arg1 = 0 ;
  CNTK::Deserializer result;
  
  arg1 = (std::vector< CNTK::HTKFeatureConfiguration > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::HTKFeatureConfiguration > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::HTKFeatureDeserializer((std::vector< CNTK::HTKFeatureConfiguration > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Deserializer((const CNTK::Deserializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HTKMLFDeserializer__SWIG_0(wchar_t * jarg1, wchar_t * jarg2, unsigned long jarg3, void * jarg4, unsigned int jarg5) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  size_t arg3 ;
  std::vector< std::wstring > *arg4 = 0 ;
  bool arg5 ;
  CNTK::Deserializer result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (size_t)jarg3; 
  arg4 = (std::vector< std::wstring > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::wstring > const & type is null", 0);
    return 0;
  } 
  arg5 = jarg5 ? true : false; 
  {
    try {
      result = CNTK::HTKMLFDeserializer((std::wstring const &)*arg1,(std::wstring const &)*arg2,arg3,(std::vector< std::wstring > const &)*arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Deserializer((const CNTK::Deserializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HTKMLFDeserializer__SWIG_1(wchar_t * jarg1, wchar_t * jarg2, unsigned long jarg3, void * jarg4) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  size_t arg3 ;
  std::vector< std::wstring > *arg4 = 0 ;
  CNTK::Deserializer result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (size_t)jarg3; 
  arg4 = (std::vector< std::wstring > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::wstring > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::HTKMLFDeserializer((std::wstring const &)*arg1,(std::wstring const &)*arg2,arg3,(std::vector< std::wstring > const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Deserializer((const CNTK::Deserializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_HTKMLFBinaryDeserializer(wchar_t * jarg1, void * jarg2, unsigned long jarg3) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< std::wstring > *arg2 = 0 ;
  size_t arg3 ;
  CNTK::Deserializer result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< std::wstring > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::wstring > const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  {
    try {
      result = CNTK::HTKMLFBinaryDeserializer((std::wstring const &)*arg1,(std::vector< std::wstring > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Deserializer((const CNTK::Deserializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_LatticeDeserializer(wchar_t * jarg1, wchar_t * jarg2) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::wstring *arg2 = 0 ;
  CNTK::Deserializer result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  {
    try {
      result = CNTK::LatticeDeserializer((std::wstring const &)*arg1,(std::wstring const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Deserializer((const CNTK::Deserializer &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TextFormatMinibatchSource__SWIG_0(wchar_t * jarg1, void * jarg2, unsigned long jarg3, unsigned int jarg4, unsigned long jarg5, unsigned int jarg6) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  size_t arg3 ;
  bool arg4 ;
  size_t arg5 ;
  bool arg6 ;
  CNTK::MinibatchSourcePtr result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = jarg4 ? true : false; 
  arg5 = (size_t)jarg5; 
  arg6 = jarg6 ? true : false; 
  {
    try {
      result = CNTK::TextFormatMinibatchSource((std::wstring const &)*arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2,arg3,arg4,arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::MinibatchSourcePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TextFormatMinibatchSource__SWIG_1(wchar_t * jarg1, void * jarg2, unsigned long jarg3, unsigned int jarg4, unsigned long jarg5) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  size_t arg3 ;
  bool arg4 ;
  size_t arg5 ;
  CNTK::MinibatchSourcePtr result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = jarg4 ? true : false; 
  arg5 = (size_t)jarg5; 
  {
    try {
      result = CNTK::TextFormatMinibatchSource((std::wstring const &)*arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2,arg3,arg4,arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::MinibatchSourcePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TextFormatMinibatchSource__SWIG_2(wchar_t * jarg1, void * jarg2, unsigned long jarg3, unsigned int jarg4) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  size_t arg3 ;
  bool arg4 ;
  CNTK::MinibatchSourcePtr result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = CNTK::TextFormatMinibatchSource((std::wstring const &)*arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::MinibatchSourcePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TextFormatMinibatchSource__SWIG_3(wchar_t * jarg1, void * jarg2, unsigned long jarg3) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  size_t arg3 ;
  CNTK::MinibatchSourcePtr result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  {
    try {
      result = CNTK::TextFormatMinibatchSource((std::wstring const &)*arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::MinibatchSourcePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TextFormatMinibatchSource__SWIG_4(wchar_t * jarg1, void * jarg2) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  std::vector< CNTK::StreamConfiguration > *arg2 = 0 ;
  CNTK::MinibatchSourcePtr result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (std::vector< CNTK::StreamConfiguration > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CNTK::StreamConfiguration > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::TextFormatMinibatchSource((std::wstring const &)*arg1,(std::vector< CNTK::StreamConfiguration > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::MinibatchSourcePtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ComputeInputPerDimMeansAndInvStdDevs__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  CNTK::MinibatchSourcePtr *arg1 = 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< CNTK::NDArrayViewPtr,CNTK::NDArrayViewPtr > > *arg2 = 0 ;
  CNTK::DeviceDescriptor *arg3 = 0 ;
  CNTK::MinibatchSourcePtr tempnull1 ;
  
  arg1 = jarg1 ? (CNTK::MinibatchSourcePtr *)jarg1 : &tempnull1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,std::pair< CNTK::NDArrayViewPtr,CNTK::NDArrayViewPtr > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,std::pair< CNTK::NDArrayViewPtr,CNTK::NDArrayViewPtr > > & type is null", 0);
    return ;
  } 
  arg3 = (CNTK::DeviceDescriptor *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::DeviceDescriptor const & type is null", 0);
    return ;
  } 
  {
    try {
      CNTK::ComputeInputPerDimMeansAndInvStdDevs((std::shared_ptr< CNTK::MinibatchSource > const &)*arg1,*arg2,(CNTK::DeviceDescriptor const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ComputeInputPerDimMeansAndInvStdDevs__SWIG_1(void * jarg1, void * jarg2) {
  CNTK::MinibatchSourcePtr *arg1 = 0 ;
  std::unordered_map< CNTK::StreamInformation,std::pair< CNTK::NDArrayViewPtr,CNTK::NDArrayViewPtr > > *arg2 = 0 ;
  CNTK::MinibatchSourcePtr tempnull1 ;
  
  arg1 = jarg1 ? (CNTK::MinibatchSourcePtr *)jarg1 : &tempnull1; 
  arg2 = (std::unordered_map< CNTK::StreamInformation,std::pair< CNTK::NDArrayViewPtr,CNTK::NDArrayViewPtr > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::unordered_map< CNTK::StreamInformation,std::pair< CNTK::NDArrayViewPtr,CNTK::NDArrayViewPtr > > & type is null", 0);
    return ;
  } 
  {
    try {
      CNTK::ComputeInputPerDimMeansAndInvStdDevs((std::shared_ptr< CNTK::MinibatchSource > const &)*arg1,*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_SetMaxNumCPUThreads(unsigned long jarg1) {
  size_t arg1 ;
  
  arg1 = (size_t)jarg1; 
  {
    try {
      CNTK::SetMaxNumCPUThreads(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_GetMaxNumCPUThreads() {
  unsigned long jresult ;
  size_t result;
  
  {
    try {
      result = CNTK::GetMaxNumCPUThreads(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_ProgressWriter(unsigned long jarg1, unsigned long jarg2, unsigned long jarg3, unsigned long jarg4, unsigned long jarg5, unsigned long jarg6) {
  void * jresult ;
  size_t arg1 ;
  size_t arg2 ;
  size_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  size_t arg6 ;
  CNTK::ProgressWriter *result = 0 ;
  
  arg1 = (size_t)jarg1; 
  arg2 = (size_t)jarg2; 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  arg5 = (size_t)jarg5; 
  arg6 = (size_t)jarg6; 
  {
    try {
      result = (CNTK::ProgressWriter *)new CNTK::ProgressWriter(arg1,arg2,arg3,arg4,arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  
  jresult = result ? new std::shared_ptr<  CNTK::ProgressWriter >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_ProgressWriter(void * jarg1) {
  CNTK::ProgressWriter *arg1 = (CNTK::ProgressWriter *) 0 ;
  std::shared_ptr< CNTK::ProgressWriter > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::ProgressWriter > *)jarg1;
  arg1 = (CNTK::ProgressWriter *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (void)arg1; delete smartarg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriter_OnWriteTrainingUpdate(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5) {
  CNTK::ProgressWriter *arg1 = (CNTK::ProgressWriter *) 0 ;
  std::pair< size_t,size_t > *arg2 = 0 ;
  std::pair< size_t,size_t > *arg3 = 0 ;
  std::pair< double,double > *arg4 = 0 ;
  std::pair< double,double > *arg5 = 0 ;
  std::shared_ptr< CNTK::ProgressWriter > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::ProgressWriter > *)jarg1;
  arg1 = (CNTK::ProgressWriter *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::pair< size_t,size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,size_t > const & type is null", 0);
    return ;
  } 
  arg3 = (std::pair< size_t,size_t > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,size_t > const & type is null", 0);
    return ;
  } 
  arg4 = (std::pair< double,double > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< double,double > const & type is null", 0);
    return ;
  } 
  arg5 = (std::pair< double,double > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< double,double > const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->OnWriteTrainingUpdate((std::pair< size_t,size_t > const &)*arg2,(std::pair< size_t,size_t > const &)*arg3,(std::pair< double,double > const &)*arg4,(std::pair< double,double > const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriter_OnWriteTestUpdate(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  CNTK::ProgressWriter *arg1 = (CNTK::ProgressWriter *) 0 ;
  std::pair< size_t,size_t > *arg2 = 0 ;
  std::pair< size_t,size_t > *arg3 = 0 ;
  std::pair< double,double > *arg4 = 0 ;
  std::shared_ptr< CNTK::ProgressWriter > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::ProgressWriter > *)jarg1;
  arg1 = (CNTK::ProgressWriter *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::pair< size_t,size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,size_t > const & type is null", 0);
    return ;
  } 
  arg3 = (std::pair< size_t,size_t > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,size_t > const & type is null", 0);
    return ;
  } 
  arg4 = (std::pair< double,double > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< double,double > const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->OnWriteTestUpdate((std::pair< size_t,size_t > const &)*arg2,(std::pair< size_t,size_t > const &)*arg3,(std::pair< double,double > const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriter_OnWriteDistributedSyncUpdate(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  CNTK::ProgressWriter *arg1 = (CNTK::ProgressWriter *) 0 ;
  std::pair< size_t,size_t > *arg2 = 0 ;
  std::pair< size_t,size_t > *arg3 = 0 ;
  std::pair< double,double > *arg4 = 0 ;
  std::shared_ptr< CNTK::ProgressWriter > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::ProgressWriter > *)jarg1;
  arg1 = (CNTK::ProgressWriter *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (std::pair< size_t,size_t > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,size_t > const & type is null", 0);
    return ;
  } 
  arg3 = (std::pair< size_t,size_t > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< size_t,size_t > const & type is null", 0);
    return ;
  } 
  arg4 = (std::pair< double,double > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< double,double > const & type is null", 0);
    return ;
  } 
  {
    try {
      (arg1)->OnWriteDistributedSyncUpdate((std::pair< size_t,size_t > const &)*arg2,(std::pair< size_t,size_t > const &)*arg3,(std::pair< double,double > const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriter_OnTrainingUpdateEnd(void * jarg1) {
  CNTK::ProgressWriter *arg1 = (CNTK::ProgressWriter *) 0 ;
  std::shared_ptr< CNTK::ProgressWriter > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::ProgressWriter > *)jarg1;
  arg1 = (CNTK::ProgressWriter *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      (arg1)->OnTrainingUpdateEnd(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriter_OnWriteTrainingSummary(void * jarg1, unsigned long jarg2, unsigned long jarg3, unsigned long jarg4, double jarg5, double jarg6, unsigned long jarg7) {
  CNTK::ProgressWriter *arg1 = (CNTK::ProgressWriter *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  size_t arg4 ;
  double arg5 ;
  double arg6 ;
  size_t arg7 ;
  std::shared_ptr< CNTK::ProgressWriter > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::ProgressWriter > *)jarg1;
  arg1 = (CNTK::ProgressWriter *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (size_t)jarg2; 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (double)jarg6; 
  arg7 = (size_t)jarg7; 
  {
    try {
      (arg1)->OnWriteTrainingSummary(arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriter_OnWriteTestSummary(void * jarg1, unsigned long jarg2, unsigned long jarg3, unsigned long jarg4, double jarg5, unsigned long jarg6) {
  CNTK::ProgressWriter *arg1 = (CNTK::ProgressWriter *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  size_t arg4 ;
  double arg5 ;
  size_t arg6 ;
  std::shared_ptr< CNTK::ProgressWriter > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::ProgressWriter > *)jarg1;
  arg1 = (CNTK::ProgressWriter *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (size_t)jarg2; 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (size_t)jarg6; 
  {
    try {
      (arg1)->OnWriteTestSummary(arg2,arg3,arg4,arg5,arg6); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_ProgressWriter_Write(void * jarg1, wchar_t * jarg2, double jarg3) {
  CNTK::ProgressWriter *arg1 = (CNTK::ProgressWriter *) 0 ;
  std::wstring *arg2 = 0 ;
  double arg3 ;
  std::shared_ptr< CNTK::ProgressWriter > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  CNTK::ProgressWriter > *)jarg1;
  arg1 = (CNTK::ProgressWriter *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (double)jarg3; 
  {
    try {
      (arg1)->Write((std::wstring const &)*arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_ProgressWriter_TotalTrainingUpdates(void * jarg1) {
  unsigned long jresult ;
  CNTK::ProgressWriter *arg1 = (CNTK::ProgressWriter *) 0 ;
  std::shared_ptr< CNTK::ProgressWriter const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::ProgressWriter > *)jarg1;
  arg1 = (CNTK::ProgressWriter *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::ProgressWriter const *)arg1)->TotalTrainingUpdates(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_ProgressWriter_TotalTestUpdates(void * jarg1) {
  unsigned long jresult ;
  CNTK::ProgressWriter *arg1 = (CNTK::ProgressWriter *) 0 ;
  std::shared_ptr< CNTK::ProgressWriter const > *smartarg1 = 0 ;
  size_t result;
  
  
  smartarg1 = (std::shared_ptr< const CNTK::ProgressWriter > *)jarg1;
  arg1 = (CNTK::ProgressWriter *)(smartarg1 ? smartarg1->get() : 0); 
  {
    try {
      result = ((CNTK::ProgressWriter const *)arg1)->TotalTestUpdates(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Crop__SWIG_0(void * jarg1, void * jarg2, unsigned long jarg3, unsigned long jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  size_t arg4 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::Crop((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Crop__SWIG_1(void * jarg1, void * jarg2, unsigned long jarg3, unsigned long jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  size_t arg3 ;
  size_t arg4 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (size_t)jarg3; 
  arg4 = (size_t)jarg4; 
  {
    try {
      result = CNTK::Crop((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,arg3,arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Crop__SWIG_2(void * jarg1, void * jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Crop((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Crop__SWIG_3(void * jarg1, void * jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Crop((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Crop__SWIG_4(void * jarg1, void * jarg2, void * jarg3, void * jarg4, wchar_t * jarg5) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::Variable *arg4 = 0 ;
  std::wstring *arg5 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Variable *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  if (!jarg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg5_str(jarg5);
  arg5 = &arg5_str; 
  {
    try {
      result = CNTK::Crop((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(CNTK::Variable const &)*arg4,(std::wstring const &)*arg5); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Crop__SWIG_5(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::Variable *arg2 = 0 ;
  CNTK::Variable *arg3 = 0 ;
  CNTK::Variable *arg4 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::Variable *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg3 = (CNTK::Variable *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg4 = (CNTK::Variable *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::Crop((CNTK::Variable const &)*arg1,(CNTK::Variable const &)*arg2,(CNTK::Variable const &)*arg3,(CNTK::Variable const &)*arg4); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Cast__SWIG_0(void * jarg1, int jarg2, wchar_t * jarg3) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::DataType arg2 ;
  std::wstring *arg3 = 0 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  {
    try {
      result = CNTK::Cast((CNTK::Variable const &)*arg1,arg2,(std::wstring const &)*arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_Cast__SWIG_1(void * jarg1, int jarg2) {
  void * jresult ;
  CNTK::Variable *arg1 = 0 ;
  CNTK::DataType arg2 ;
  CNTK::FunctionPtr result;
  
  arg1 = (CNTK::Variable *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Variable const & type is null", 0);
    return 0;
  } 
  arg2 = (CNTK::DataType)jarg2; 
  {
    try {
      result = CNTK::Cast((CNTK::Variable const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result ? new CNTK::FunctionPtr(result) : 0; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_TrainingParameterScheduleDouble_FullDataSweep_get() {
  unsigned long jresult ;
  size_t result;
  
  result = CNTK::TrainingParameterSchedule< double >::FullDataSweep;
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_TrainingParameterScheduleDouble_IgnoredMinibatchSize_get() {
  unsigned long jresult ;
  size_t result;
  
  result = CNTK::TrainingParameterSchedule< double >::IgnoredMinibatchSize;
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_TrainingParameterScheduleDouble__SWIG_0(double jarg1, unsigned long jarg2) {
  void * jresult ;
  double arg1 ;
  size_t arg2 ;
  CNTK::TrainingParameterSchedule< double > *result = 0 ;
  
  arg1 = (double)jarg1; 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = (CNTK::TrainingParameterSchedule< double > *)new CNTK::TrainingParameterSchedule< double >(arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_TrainingParameterScheduleDouble__SWIG_1(double jarg1) {
  void * jresult ;
  double arg1 ;
  CNTK::TrainingParameterSchedule< double > *result = 0 ;
  
  arg1 = (double)jarg1; 
  {
    try {
      result = (CNTK::TrainingParameterSchedule< double > *)new CNTK::TrainingParameterSchedule< double >(arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_TrainingParameterScheduleDouble__SWIG_2(void * jarg1, unsigned long jarg2, unsigned long jarg3) {
  void * jresult ;
  std::vector< std::pair< size_t,double > > *arg1 = 0 ;
  size_t arg2 ;
  size_t arg3 ;
  CNTK::TrainingParameterSchedule< double > *result = 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< size_t,double > > const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  arg3 = (size_t)jarg3; 
  {
    try {
      result = (CNTK::TrainingParameterSchedule< double > *)new CNTK::TrainingParameterSchedule< double >((std::vector< std::pair< size_t,double > > const &)*arg1,arg2,arg3); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_TrainingParameterScheduleDouble__SWIG_3(void * jarg1, unsigned long jarg2) {
  void * jresult ;
  std::vector< std::pair< size_t,double > > *arg1 = 0 ;
  size_t arg2 ;
  CNTK::TrainingParameterSchedule< double > *result = 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< size_t,double > > const & type is null", 0);
    return 0;
  } 
  arg2 = (size_t)jarg2; 
  {
    try {
      result = (CNTK::TrainingParameterSchedule< double > *)new CNTK::TrainingParameterSchedule< double >((std::vector< std::pair< size_t,double > > const &)*arg1,arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_TrainingParameterScheduleDouble__SWIG_4(void * jarg1) {
  void * jresult ;
  std::vector< std::pair< size_t,double > > *arg1 = 0 ;
  CNTK::TrainingParameterSchedule< double > *result = 0 ;
  
  arg1 = (std::vector< std::pair< size_t,double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< size_t,double > > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::TrainingParameterSchedule< double > *)new CNTK::TrainingParameterSchedule< double >((std::vector< std::pair< size_t,double > > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_TrainingParameterScheduleDouble_IsSweepBased(void * jarg1) {
  unsigned int jresult ;
  CNTK::TrainingParameterSchedule< double > *arg1 = (CNTK::TrainingParameterSchedule< double > *) 0 ;
  bool result;
  
  arg1 = (CNTK::TrainingParameterSchedule< double > *)jarg1; 
  {
    try {
      result = (bool)((CNTK::TrainingParameterSchedule< double > const *)arg1)->IsSweepBased(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_delete_TrainingParameterScheduleDouble(void * jarg1) {
  CNTK::TrainingParameterSchedule< double > *arg1 = (CNTK::TrainingParameterSchedule< double > *) 0 ;
  
  arg1 = (CNTK::TrainingParameterSchedule< double > *)jarg1; 
  {
    try {
      delete arg1; 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_new_TrainingParameterScheduleDouble__SWIG_5(void * jarg1) {
  void * jresult ;
  CNTK::TrainingParameterSchedule< double > *arg1 = 0 ;
  CNTK::TrainingParameterSchedule< double > *result = 0 ;
  
  arg1 = (CNTK::TrainingParameterSchedule< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::TrainingParameterSchedule< double > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (CNTK::TrainingParameterSchedule< double > *)new CNTK::TrainingParameterSchedule< double >((CNTK::TrainingParameterSchedule< double > const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TrainingParameterScheduleDouble_Serialize(void * jarg1) {
  void * jresult ;
  CNTK::TrainingParameterSchedule< double > *arg1 = (CNTK::TrainingParameterSchedule< double > *) 0 ;
  CNTK::Dictionary result;
  
  arg1 = (CNTK::TrainingParameterSchedule< double > *)jarg1; 
  {
    try {
      result = ((CNTK::TrainingParameterSchedule< double > const *)arg1)->Serialize(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::Dictionary((const CNTK::Dictionary &)result); 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_TrainingParameterScheduleDouble_CurrentVersion(void * jarg1) {
  unsigned long jresult ;
  CNTK::TrainingParameterSchedule< double > *arg1 = (CNTK::TrainingParameterSchedule< double > *) 0 ;
  size_t result;
  
  arg1 = (CNTK::TrainingParameterSchedule< double > *)jarg1; 
  {
    try {
      result = ((CNTK::TrainingParameterSchedule< double > const *)arg1)->CurrentVersion(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CNTK_TrainingParameterScheduleDouble_Deserialize(void * jarg1) {
  void * jresult ;
  CNTK::Dictionary *arg1 = 0 ;
  SwigValueWrapper< CNTK::TrainingParameterSchedule< double > > result;
  
  arg1 = (CNTK::Dictionary *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::Dictionary const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = CNTK::TrainingParameterSchedule< double >::SWIGTEMPLATEDISAMBIGUATOR Deserialize((CNTK::Dictionary const &)*arg1); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = new CNTK::TrainingParameterSchedule< double >((const CNTK::TrainingParameterSchedule< double > &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CNTK_TrainingParameterScheduleDouble_AreEqual(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  CNTK::TrainingParameterSchedule< double > *arg1 = (CNTK::TrainingParameterSchedule< double > *) 0 ;
  CNTK::TrainingParameterSchedule< double > *arg2 = 0 ;
  bool result;
  
  arg1 = (CNTK::TrainingParameterSchedule< double > *)jarg1; 
  arg2 = (CNTK::TrainingParameterSchedule< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CNTK::TrainingParameterSchedule< double > const & type is null", 0);
    return 0;
  } 
  {
    try {
      result = (bool)(arg1)->operator ==((CNTK::TrainingParameterSchedule< double > const &)*arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CNTK_TrainingParameterScheduleDouble_GetMinibatchSize(void * jarg1) {
  unsigned long jresult ;
  CNTK::TrainingParameterSchedule< double > *arg1 = (CNTK::TrainingParameterSchedule< double > *) 0 ;
  size_t result;
  
  arg1 = (CNTK::TrainingParameterSchedule< double > *)jarg1; 
  {
    try {
      result = ((CNTK::TrainingParameterSchedule< double > const *)arg1)->GetMinibatchSize(); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return 0; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return 0; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return 0; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return 0; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return 0; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return 0; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return 0; 
      }; 
    }
  }
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CNTK_TrainingParameterScheduleDouble_SetMinibatchSize(void * jarg1, unsigned long jarg2) {
  CNTK::TrainingParameterSchedule< double > *arg1 = (CNTK::TrainingParameterSchedule< double > *) 0 ;
  size_t arg2 ;
  
  arg1 = (CNTK::TrainingParameterSchedule< double > *)jarg1; 
  arg2 = (size_t)jarg2; 
  {
    try {
      (arg1)->SetMinibatchSize(arg2); 
    }
    catch (const Swig::DirectorException &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const Microsoft::MSR::CNTK::IExceptionWithCallStackBase& err)
    {
      auto msg = std::string(dynamic_cast<const std::exception&>(err).what());
      msg = msg + "\n" + err.CallStack();
      
      if (dynamic_cast<const std::invalid_argument*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_ValueError, msg.c_str()); return ; 
        }; 
      }
      
      if (dynamic_cast<const std::logic_error*>(&err) || 
        dynamic_cast<const std::runtime_error*>(&err)) 
      {
        {
          SWIG_CSharpException(SWIG_RuntimeError, msg.c_str()); return ; 
        }; 
      }
      
      {
        SWIG_CSharpException(SWIG_UnknownError, msg.c_str()); return ; 
      }; 
    }
    catch (const std::runtime_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::invalid_argument &e) {
      {
        SWIG_CSharpException(SWIG_ValueError, e.what()); return ; 
      }; 
    }
    catch (const std::logic_error &e) {
      {
        SWIG_CSharpException(SWIG_RuntimeError, e.what()); return ; 
      }; 
    }
    catch (const std::exception &e) {
      {
        SWIG_CSharpException(SWIG_UnknownError, e.what()); return ; 
      }; 
    }
    catch (...) {
      {
        SWIG_CSharpException(SWIG_UnknownError, "Runtime exception"); return ; 
      }; 
    }
  }
}


SWIGEXPORT CNTK::Variable * SWIGSTDCALL CSharp_CNTK_Parameter_SWIGUpcast(CNTK::Parameter *jarg1) {
    return (CNTK::Variable *)jarg1;
}

SWIGEXPORT CNTK::Variable * SWIGSTDCALL CSharp_CNTK_Constant_SWIGUpcast(CNTK::Constant *jarg1) {
    return (CNTK::Variable *)jarg1;
}

SWIGEXPORT std::shared_ptr< CNTK::Evaluator > * SWIGSTDCALL CSharp_CNTK_Trainer_SWIGSmartPtrUpcast(std::shared_ptr< CNTK::Trainer > *jarg1) {
    return jarg1 ? new std::shared_ptr< CNTK::Evaluator >(*jarg1) : 0;
}

#ifdef __cplusplus
}
#endif

