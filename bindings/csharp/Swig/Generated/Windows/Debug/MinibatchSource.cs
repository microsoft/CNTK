//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace CNTK {

public partial class MinibatchSource : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  private bool swigCMemOwnBase;

  internal MinibatchSource(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwnBase = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(MinibatchSource obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~MinibatchSource() {
    Dispose();
  }

  public virtual void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwnBase) {
          swigCMemOwnBase = false;
          CNTKLibPINVOKE.delete_MinibatchSource(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
    }
  }

  public UnorderedMapStreamInformationMinibatchData GetNextMinibatch(uint minibatchSizeInSequences, uint minibatchSizeInSamples, DeviceDescriptor device) {
    UnorderedMapStreamInformationMinibatchData ret = new UnorderedMapStreamInformationMinibatchData(CNTKLibPINVOKE.MinibatchSource_GetNextMinibatch__SWIG_0(swigCPtr, minibatchSizeInSequences, minibatchSizeInSamples, DeviceDescriptor.getCPtr(device)), false);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public UnorderedMapStreamInformationMinibatchData GetNextMinibatch(uint minibatchSizeInSequences, uint minibatchSizeInSamples) {
    UnorderedMapStreamInformationMinibatchData ret = new UnorderedMapStreamInformationMinibatchData(CNTKLibPINVOKE.MinibatchSource_GetNextMinibatch__SWIG_1(swigCPtr, minibatchSizeInSequences, minibatchSizeInSamples), false);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual UnorderedMapStreamInformationMinibatchData GetNextMinibatch(uint minibatchSizeInSequences, uint minibatchSizeInSamples, uint numberOfWorkers, uint workerRank, DeviceDescriptor device) {
    UnorderedMapStreamInformationMinibatchData ret = new UnorderedMapStreamInformationMinibatchData(CNTKLibPINVOKE.MinibatchSource_GetNextMinibatch__SWIG_2(swigCPtr, minibatchSizeInSequences, minibatchSizeInSamples, numberOfWorkers, workerRank, DeviceDescriptor.getCPtr(device)), false);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual UnorderedMapStreamInformationMinibatchData GetNextMinibatch(uint minibatchSizeInSequences, uint minibatchSizeInSamples, uint numberOfWorkers, uint workerRank) {
    UnorderedMapStreamInformationMinibatchData ret = new UnorderedMapStreamInformationMinibatchData(CNTKLibPINVOKE.MinibatchSource_GetNextMinibatch__SWIG_3(swigCPtr, minibatchSizeInSequences, minibatchSizeInSamples, numberOfWorkers, workerRank), false);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual CNTKDictionary GetCheckpointState() {
    CNTKDictionary ret = new CNTKDictionary(CNTKLibPINVOKE.MinibatchSource_GetCheckpointState(swigCPtr), true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual void RestoreFromCheckpoint(CNTKDictionary arg0) {
    CNTKLibPINVOKE.MinibatchSource_RestoreFromCheckpoint(swigCPtr, CNTKDictionary.getCPtr(arg0));
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public virtual bool IsInfinite() {
    bool ret = CNTKLibPINVOKE.MinibatchSource_IsInfinite(swigCPtr);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public StreamInformation StreamInfo(string streamName) {
    StreamInformation ret = new StreamInformation(CNTKLibPINVOKE.MinibatchSource_StreamInfo__SWIG_0(swigCPtr, streamName), false);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public StreamInformation StreamInfo(Variable variableToMatch) {
    StreamInformation ret = new StreamInformation(CNTKLibPINVOKE.MinibatchSource_StreamInfo__SWIG_1(swigCPtr, Variable.getCPtr(variableToMatch)), false);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public UnorderedMapStreamInformationMinibatchData GetNextMinibatch(uint minibatchSizeInSamples, DeviceDescriptor device) {
    UnorderedMapStreamInformationMinibatchData ret = new UnorderedMapStreamInformationMinibatchData(CNTKLibPINVOKE.MinibatchSource_GetNextMinibatch__SWIG_4(swigCPtr, minibatchSizeInSamples, DeviceDescriptor.getCPtr(device)), false);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public UnorderedMapStreamInformationMinibatchData GetNextMinibatch(uint minibatchSizeInSamples) {
    UnorderedMapStreamInformationMinibatchData ret = new UnorderedMapStreamInformationMinibatchData(CNTKLibPINVOKE.MinibatchSource_GetNextMinibatch__SWIG_5(swigCPtr, minibatchSizeInSamples), false);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static MinibatchSource TextFormatMinibatchSourceInternal(string dataFilePath, StreamConfigurationVector streamConfigs, ulong epochSize, bool randomize, ulong randomizationWindow, bool sampleBasedRandomizationWindow) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_0(dataFilePath, StreamConfigurationVector.getCPtr(streamConfigs), epochSize, randomize, randomizationWindow, sampleBasedRandomizationWindow);
    MinibatchSource ret = (cPtr == global::System.IntPtr.Zero) ? null : new MinibatchSource(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static MinibatchSource TextFormatMinibatchSourceInternal(string dataFilePath, StreamConfigurationVector streamConfigs, ulong epochSize, bool randomize, ulong randomizationWindow) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_1(dataFilePath, StreamConfigurationVector.getCPtr(streamConfigs), epochSize, randomize, randomizationWindow);
    MinibatchSource ret = (cPtr == global::System.IntPtr.Zero) ? null : new MinibatchSource(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static MinibatchSource TextFormatMinibatchSourceInternal(string dataFilePath, StreamConfigurationVector streamConfigs, ulong epochSize, bool randomize) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_2(dataFilePath, StreamConfigurationVector.getCPtr(streamConfigs), epochSize, randomize);
    MinibatchSource ret = (cPtr == global::System.IntPtr.Zero) ? null : new MinibatchSource(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static MinibatchSource TextFormatMinibatchSourceInternal(string dataFilePath, StreamConfigurationVector streamConfigs, ulong epochSize) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_3(dataFilePath, StreamConfigurationVector.getCPtr(streamConfigs), epochSize);
    MinibatchSource ret = (cPtr == global::System.IntPtr.Zero) ? null : new MinibatchSource(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static MinibatchSource TextFormatMinibatchSourceInternal(string dataFilePath, StreamConfigurationVector streamConfigs) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.MinibatchSource_TextFormatMinibatchSourceInternal__SWIG_4(dataFilePath, StreamConfigurationVector.getCPtr(streamConfigs));
    MinibatchSource ret = (cPtr == global::System.IntPtr.Zero) ? null : new MinibatchSource(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static ulong GetFullDataSweep() {
    ulong ret = CNTKLibPINVOKE.MinibatchSource_GetFullDataSweep();
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static ulong GetInfinitelyRepeat() {
    ulong ret = CNTKLibPINVOKE.MinibatchSource_GetInfinitelyRepeat();
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static ulong GetDefaultRandomizationWindowInChunks() {
    ulong ret = CNTKLibPINVOKE.MinibatchSource_GetDefaultRandomizationWindowInChunks();
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}
