# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_cntk_py')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_cntk_py')
    _cntk_py = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_cntk_py', [dirname(__file__)])
        except ImportError:
            import _cntk_py
            return _cntk_py
        if fp is not None:
            try:
                _mod = imp.load_module('_cntk_py', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _cntk_py = swig_import_helper()
    del swig_import_helper
else:
    import _cntk_py
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cntk_py.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _cntk_py.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _cntk_py.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _cntk_py.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _cntk_py.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _cntk_py.SwigPyIterator_equal(self, x)

    def copy(self):
        return _cntk_py.SwigPyIterator_copy(self)

    def next(self):
        return _cntk_py.SwigPyIterator_next(self)

    def __next__(self):
        return _cntk_py.SwigPyIterator___next__(self)

    def previous(self):
        return _cntk_py.SwigPyIterator_previous(self)

    def advance(self, n):
        return _cntk_py.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _cntk_py.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _cntk_py.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _cntk_py.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _cntk_py.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _cntk_py.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _cntk_py.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _cntk_py.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _cntk_py.SHARED_PTR_DISOWN
InferredDimension = _cntk_py.InferredDimension

def is_within(*args):
    return _cntk_py.is_within(*args)
is_within = _cntk_py.is_within

def packed_index(*args):
    return _cntk_py.packed_index(*args)
packed_index = _cntk_py.packed_index

def gather_packed(*args):
    return _cntk_py.gather_packed(*args)
gather_packed = _cntk_py.gather_packed

def scatter_packed(*args):
    return _cntk_py.scatter_packed(*args)
scatter_packed = _cntk_py.scatter_packed

def zeroes_like(operand):
    return _cntk_py.zeroes_like(operand)
zeroes_like = _cntk_py.zeroes_like

def reduce_elements(*args):
    return _cntk_py.reduce_elements(*args)
reduce_elements = _cntk_py.reduce_elements

def new_unique_id():
    return _cntk_py.new_unique_id()
new_unique_id = _cntk_py.new_unique_id

def enable_reversing_tensor_shapes_in_error_messages():
    return _cntk_py.enable_reversing_tensor_shapes_in_error_messages()
enable_reversing_tensor_shapes_in_error_messages = _cntk_py.enable_reversing_tensor_shapes_in_error_messages
DataType_Unknown = _cntk_py.DataType_Unknown
DataType_Float = _cntk_py.DataType_Float
DataType_Double = _cntk_py.DataType_Double

def data_type_name(dataType):
    return _cntk_py.data_type_name(dataType)
data_type_name = _cntk_py.data_type_name
StorageFormat_Dense = _cntk_py.StorageFormat_Dense
StorageFormat_SparseCSC = _cntk_py.StorageFormat_SparseCSC
StorageFormat_SparseBlockCol = _cntk_py.StorageFormat_SparseBlockCol

def is_sparse_storage_format(storageFormat):
    return _cntk_py.is_sparse_storage_format(storageFormat)
is_sparse_storage_format = _cntk_py.is_sparse_storage_format
DeviceKind_CPU = _cntk_py.DeviceKind_CPU
DeviceKind_GPU = _cntk_py.DeviceKind_GPU
class DeviceDescriptor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeviceDescriptor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DeviceDescriptor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def id(self):
        return _cntk_py.DeviceDescriptor_id(self)

    def type(self):
        return _cntk_py.DeviceDescriptor_type(self)
    if _newclass:
        cpu_device = staticmethod(_cntk_py.DeviceDescriptor_cpu_device)
    else:
        cpu_device = _cntk_py.DeviceDescriptor_cpu_device
    if _newclass:
        gpu_device = staticmethod(_cntk_py.DeviceDescriptor_gpu_device)
    else:
        gpu_device = _cntk_py.DeviceDescriptor_gpu_device
    if _newclass:
        default_device = staticmethod(_cntk_py.DeviceDescriptor_default_device)
    else:
        default_device = _cntk_py.DeviceDescriptor_default_device
    if _newclass:
        use_default_device = staticmethod(_cntk_py.DeviceDescriptor_use_default_device)
    else:
        use_default_device = _cntk_py.DeviceDescriptor_use_default_device
    if _newclass:
        set_default_device = staticmethod(_cntk_py.DeviceDescriptor_set_default_device)
    else:
        set_default_device = _cntk_py.DeviceDescriptor_set_default_device
    __swig_destroy__ = _cntk_py.delete_DeviceDescriptor
    __del__ = lambda self: None
DeviceDescriptor_swigregister = _cntk_py.DeviceDescriptor_swigregister
DeviceDescriptor_swigregister(DeviceDescriptor)

def DeviceDescriptor_cpu_device():
    return _cntk_py.DeviceDescriptor_cpu_device()
DeviceDescriptor_cpu_device = _cntk_py.DeviceDescriptor_cpu_device

def DeviceDescriptor_gpu_device(deviceId):
    return _cntk_py.DeviceDescriptor_gpu_device(deviceId)
DeviceDescriptor_gpu_device = _cntk_py.DeviceDescriptor_gpu_device

def DeviceDescriptor_default_device():
    return _cntk_py.DeviceDescriptor_default_device()
DeviceDescriptor_default_device = _cntk_py.DeviceDescriptor_default_device

def DeviceDescriptor_use_default_device():
    return _cntk_py.DeviceDescriptor_use_default_device()
DeviceDescriptor_use_default_device = _cntk_py.DeviceDescriptor_use_default_device

def DeviceDescriptor_set_default_device(newDefaultDevice):
    return _cntk_py.DeviceDescriptor_set_default_device(newDefaultDevice)
DeviceDescriptor_set_default_device = _cntk_py.DeviceDescriptor_set_default_device

class NDShape(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NDShape, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NDShape, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_NDShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def rank(self):
        return _cntk_py.NDShape_rank(self)

    def sub_shape(self, *args):
        return _cntk_py.NDShape_sub_shape(self, *args)

    def has_inferred_dimension(self):
        return _cntk_py.NDShape_has_inferred_dimension(self)

    def total_size(self):
        return _cntk_py.NDShape_total_size(self)

    def as_string(self):
        return _cntk_py.NDShape_as_string(self)

    def __getitem__(self, i):
        return _cntk_py.NDShape___getitem__(self, i)

    def dimensions(self):
        return _cntk_py.NDShape_dimensions(self)

    def __hash__(self):
        return _cntk_py.NDShape___hash__(self)
    __swig_destroy__ = _cntk_py.delete_NDShape
    __del__ = lambda self: None
NDShape_swigregister = _cntk_py.NDShape_swigregister
NDShape_swigregister(NDShape)

def NDShape_eq(first, second):
    return _cntk_py.NDShape_eq(first, second)
NDShape_eq = _cntk_py.NDShape_eq

class NDArrayView(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NDArrayView, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NDArrayView, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _cntk_py.delete_NDArrayView
    __del__ = lambda self: None

    def device(self):
        return _cntk_py.NDArrayView_device(self)

    def get_data_type(self):
        return _cntk_py.NDArrayView_get_data_type(self)

    def get_storage_format(self):
        return _cntk_py.NDArrayView_get_storage_format(self)

    def shape(self):
        return _cntk_py.NDArrayView_shape(self)

    def is_sparse(self):
        return _cntk_py.NDArrayView_is_sparse(self)

    def is_read_only(self):
        return _cntk_py.NDArrayView_is_read_only(self)

    def set_value(self, *args):
        return _cntk_py.NDArrayView_set_value(self, *args)

    def deep_clone(self, *args):
        return _cntk_py.NDArrayView_deep_clone(self, *args)

    def alias(self, readOnly=False):
        return _cntk_py.NDArrayView_alias(self, readOnly)

    def copy_from(self, source):
        return _cntk_py.NDArrayView_copy_from(self, source)

    def __init__(self, *args):
        this = _cntk_py.new_NDArrayView(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def to_numpy(self):
        return _cntk_py.NDArrayView_to_numpy(self)
    if _newclass:
        random_uniform_float = staticmethod(_cntk_py.NDArrayView_random_uniform_float)
    else:
        random_uniform_float = _cntk_py.NDArrayView_random_uniform_float
    if _newclass:
        random_uniform_double = staticmethod(_cntk_py.NDArrayView_random_uniform_double)
    else:
        random_uniform_double = _cntk_py.NDArrayView_random_uniform_double
NDArrayView_swigregister = _cntk_py.NDArrayView_swigregister
NDArrayView_swigregister(NDArrayView)

def NDArrayViewFloat(*args):
    val = _cntk_py.new_NDArrayViewFloat(*args)
    return val

def NDArrayViewDouble(*args):
    val = _cntk_py.new_NDArrayViewDouble(*args)
    return val

def NDArrayView_random_uniform_float(*args):
    return _cntk_py.NDArrayView_random_uniform_float(*args)
NDArrayView_random_uniform_float = _cntk_py.NDArrayView_random_uniform_float

def NDArrayView_random_uniform_double(*args):
    return _cntk_py.NDArrayView_random_uniform_double(*args)
NDArrayView_random_uniform_double = _cntk_py.NDArrayView_random_uniform_double

class NDMask(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NDMask, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NDMask, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_NDMask(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_NDMask
    __del__ = lambda self: None

    def mask_section(self, sectionOffset, sectionShape):
        return _cntk_py.NDMask_mask_section(self, sectionOffset, sectionShape)

    def clear(self):
        return _cntk_py.NDMask_clear(self)

    def masked_count(self):
        return _cntk_py.NDMask_masked_count(self)

    def device(self):
        return _cntk_py.NDMask_device(self)

    def shape(self):
        return _cntk_py.NDMask_shape(self)

    def data_buffer(self):
        return _cntk_py.NDMask_data_buffer(self)

    def deep_clone(self):
        return _cntk_py.NDMask_deep_clone(self)

    def alias(self):
        return _cntk_py.NDMask_alias(self)

    def copy_from(self, source):
        return _cntk_py.NDMask_copy_from(self, source)

    def to_numpy(self):
        return _cntk_py.NDMask_to_numpy(self)
NDMask_swigregister = _cntk_py.NDMask_swigregister
NDMask_swigregister(NDMask)

class Value(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Value, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Value, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_Value(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_Value
    __del__ = lambda self: None

    def data(self):
        return _cntk_py.Value_data(self)

    def mask(self):
        return _cntk_py.Value_mask(self)

    def deep_clone(self, readOnly=False):
        return _cntk_py.Value_deep_clone(self, readOnly)

    def alias(self, readOnly=False):
        return _cntk_py.Value_alias(self, readOnly)

    def copy_from(self, source):
        return _cntk_py.Value_copy_from(self, source)
Value_swigregister = _cntk_py.Value_swigregister
Value_swigregister(Value)

class Axis(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Axis, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Axis, name)
    __repr__ = _swig_repr

    def is_static_axis(self):
        return _cntk_py.Axis_is_static_axis(self)

    def is_ordered(self):
        return _cntk_py.Axis_is_ordered(self)

    def static_axis_index(self, checked=True):
        return _cntk_py.Axis_static_axis_index(self, checked)
    if _newclass:
        default_dynamic_axis = staticmethod(_cntk_py.Axis_default_dynamic_axis)
    else:
        default_dynamic_axis = _cntk_py.Axis_default_dynamic_axis
    if _newclass:
        default_batch_axis = staticmethod(_cntk_py.Axis_default_batch_axis)
    else:
        default_batch_axis = _cntk_py.Axis_default_batch_axis
    if _newclass:
        new_unique_dynamic_axis = staticmethod(_cntk_py.Axis_new_unique_dynamic_axis)
    else:
        new_unique_dynamic_axis = _cntk_py.Axis_new_unique_dynamic_axis

    def name(self):
        return _cntk_py.Axis_name(self)

    def __init__(self, *args):
        this = _cntk_py.new_Axis(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_Axis
    __del__ = lambda self: None
Axis_swigregister = _cntk_py.Axis_swigregister
Axis_swigregister(Axis)
cvar = _cntk_py.cvar
Axis.default_input_variable_dynamic_axes = _cntk_py.cvar.Axis_default_input_variable_dynamic_axes

def Axis_default_dynamic_axis():
    return _cntk_py.Axis_default_dynamic_axis()
Axis_default_dynamic_axis = _cntk_py.Axis_default_dynamic_axis

def Axis_default_batch_axis():
    return _cntk_py.Axis_default_batch_axis()
Axis_default_batch_axis = _cntk_py.Axis_default_batch_axis

def Axis_new_unique_dynamic_axis(axisNamePrefix, isOrderedDynamicAxis=True):
    return _cntk_py.Axis_new_unique_dynamic_axis(axisNamePrefix, isOrderedDynamicAxis)
Axis_new_unique_dynamic_axis = _cntk_py.Axis_new_unique_dynamic_axis

VariableKind_Input = _cntk_py.VariableKind_Input
VariableKind_Output = _cntk_py.VariableKind_Output
VariableKind_Parameter = _cntk_py.VariableKind_Parameter
VariableKind_Constant = _cntk_py.VariableKind_Constant
VariableKind_Placeholder = _cntk_py.VariableKind_Placeholder

def variable_kind_name(variableKind):
    return _cntk_py.variable_kind_name(variableKind)
variable_kind_name = _cntk_py.variable_kind_name

def generate_uid(varKind):
    return _cntk_py.generate_uid(varKind)
generate_uid = _cntk_py.generate_uid

def placeholder_variable(*args):
    return _cntk_py.placeholder_variable(*args)
placeholder_variable = _cntk_py.placeholder_variable

def output_variable(*args):
    return _cntk_py.output_variable(*args)
output_variable = _cntk_py.output_variable
class Variable(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Variable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Variable, name)
    __repr__ = _swig_repr

    def shape(self):
        return _cntk_py.Variable_shape(self)

    def dynamic_axes(self):
        return _cntk_py.Variable_dynamic_axes(self)

    def kind(self):
        return _cntk_py.Variable_kind(self)

    def is_sparse(self):
        return _cntk_py.Variable_is_sparse(self)

    def is_input(self):
        return _cntk_py.Variable_is_input(self)

    def is_output(self):
        return _cntk_py.Variable_is_output(self)

    def is_parameter(self):
        return _cntk_py.Variable_is_parameter(self)

    def is_constant(self):
        return _cntk_py.Variable_is_constant(self)

    def is_placeholder(self):
        return _cntk_py.Variable_is_placeholder(self)

    def name(self):
        return _cntk_py.Variable_name(self)

    def uid(self):
        return _cntk_py.Variable_uid(self)

    def get_data_type(self):
        return _cntk_py.Variable_get_data_type(self)

    def needs_gradient(self):
        return _cntk_py.Variable_needs_gradient(self)

    def __init__(self, *args):
        this = _cntk_py.new_Variable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        return _cntk_py.Variable_clone(self)

    def __hash__(self):
        return _cntk_py.Variable___hash__(self)
    __swig_destroy__ = _cntk_py.delete_Variable
    __del__ = lambda self: None
Variable_swigregister = _cntk_py.Variable_swigregister
Variable_swigregister(Variable)

def Variable_eq(first, second):
    return _cntk_py.Variable_eq(first, second)
Variable_eq = _cntk_py.Variable_eq


def __ne__(*args):
    return _cntk_py.__ne__(*args)
__ne__ = _cntk_py.__ne__

def input_variable(*args):
    return _cntk_py.input_variable(*args)
input_variable = _cntk_py.input_variable
class Parameter(Variable):
    __swig_setmethods__ = {}
    for _s in [Variable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parameter, name, value)
    __swig_getmethods__ = {}
    for _s in [Variable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Parameter, name)
    __repr__ = _swig_repr
    if _newclass:
        uniform = staticmethod(_cntk_py.Parameter_uniform)
    else:
        uniform = _cntk_py.Parameter_uniform
    if _newclass:
        he_uniform = staticmethod(_cntk_py.Parameter_he_uniform)
    else:
        he_uniform = _cntk_py.Parameter_he_uniform
    if _newclass:
        glorot_uniform = staticmethod(_cntk_py.Parameter_glorot_uniform)
    else:
        glorot_uniform = _cntk_py.Parameter_glorot_uniform
    if _newclass:
        xavier = staticmethod(_cntk_py.Parameter_xavier)
    else:
        xavier = _cntk_py.Parameter_xavier
    if _newclass:
        gaussian = staticmethod(_cntk_py.Parameter_gaussian)
    else:
        gaussian = _cntk_py.Parameter_gaussian
    if _newclass:
        he_normal = staticmethod(_cntk_py.Parameter_he_normal)
    else:
        he_normal = _cntk_py.Parameter_he_normal
    if _newclass:
        glorot_normal = staticmethod(_cntk_py.Parameter_glorot_normal)
    else:
        glorot_normal = _cntk_py.Parameter_glorot_normal

    def __init__(self, *args):
        this = _cntk_py.new_Parameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def value(self):
        return _cntk_py.Parameter_value(self)

    def __hash__(self):
        return _cntk_py.Parameter___hash__(self)
    __swig_destroy__ = _cntk_py.delete_Parameter
    __del__ = lambda self: None
Parameter_swigregister = _cntk_py.Parameter_swigregister
Parameter_swigregister(Parameter)

def Parameter_uniform(*args):
    return _cntk_py.Parameter_uniform(*args)
Parameter_uniform = _cntk_py.Parameter_uniform

def Parameter_he_uniform(*args):
    return _cntk_py.Parameter_he_uniform(*args)
Parameter_he_uniform = _cntk_py.Parameter_he_uniform

def Parameter_glorot_uniform(*args):
    return _cntk_py.Parameter_glorot_uniform(*args)
Parameter_glorot_uniform = _cntk_py.Parameter_glorot_uniform

def Parameter_xavier(*args):
    return _cntk_py.Parameter_xavier(*args)
Parameter_xavier = _cntk_py.Parameter_xavier

def Parameter_gaussian(*args):
    return _cntk_py.Parameter_gaussian(*args)
Parameter_gaussian = _cntk_py.Parameter_gaussian

def Parameter_he_normal(*args):
    return _cntk_py.Parameter_he_normal(*args)
Parameter_he_normal = _cntk_py.Parameter_he_normal

def Parameter_glorot_normal(*args):
    return _cntk_py.Parameter_glorot_normal(*args)
Parameter_glorot_normal = _cntk_py.Parameter_glorot_normal

def ParameterFloat(*args):
    val = _cntk_py.new_ParameterFloat(*args)
    return val

def ParameterDouble(*args):
    val = _cntk_py.new_ParameterDouble(*args)
    return val

class Constant(Variable):
    __swig_setmethods__ = {}
    for _s in [Variable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Constant, name, value)
    __swig_getmethods__ = {}
    for _s in [Variable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Constant, name)
    __repr__ = _swig_repr
    if _newclass:
        scalar = staticmethod(_cntk_py.Constant_scalar)
    else:
        scalar = _cntk_py.Constant_scalar

    def __init__(self, *args):
        this = _cntk_py.new_Constant(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def value(self):
        return _cntk_py.Constant_value(self)

    def __hash__(self):
        return _cntk_py.Constant___hash__(self)
    __swig_destroy__ = _cntk_py.delete_Constant
    __del__ = lambda self: None
Constant_swigregister = _cntk_py.Constant_swigregister
Constant_swigregister(Constant)

def Constant_scalar(*args):
    return _cntk_py.Constant_scalar(*args)
Constant_scalar = _cntk_py.Constant_scalar

def ConstantFloat(*args):
    val = _cntk_py.new_ConstantFloat(*args)
    return val

def ConstantDouble(*args):
    val = _cntk_py.new_ConstantDouble(*args)
    return val

class DictionaryValue(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DictionaryValue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DictionaryValue, name)
    __repr__ = _swig_repr
    Type__None = _cntk_py.DictionaryValue_Type__None
    Type_Bool = _cntk_py.DictionaryValue_Type_Bool
    Type_SizeT = _cntk_py.DictionaryValue_Type_SizeT
    Type_Float = _cntk_py.DictionaryValue_Type_Float
    Type_Double = _cntk_py.DictionaryValue_Type_Double
    Type_String = _cntk_py.DictionaryValue_Type_String
    Type_NDShape = _cntk_py.DictionaryValue_Type_NDShape
    Type_Axis = _cntk_py.DictionaryValue_Type_Axis
    Type_Vector = _cntk_py.DictionaryValue_Type_Vector
    Type_Dictionary = _cntk_py.DictionaryValue_Type_Dictionary
    Type_NDArrayView = _cntk_py.DictionaryValue_Type_NDArrayView
    if _newclass:
        type_name = staticmethod(_cntk_py.DictionaryValue_type_name)
    else:
        type_name = _cntk_py.DictionaryValue_type_name

    def __init__(self, *args):
        this = _cntk_py.new_DictionaryValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_DictionaryValue
    __del__ = lambda self: None

    def has_value(self):
        return _cntk_py.DictionaryValue_has_value(self)

    def value_type(self):
        return _cntk_py.DictionaryValue_value_type(self)

    def __eq__(self, other):
        return _cntk_py.DictionaryValue___eq__(self, other)

    def __ne__(self, other):
        return _cntk_py.DictionaryValue___ne__(self, other)
DictionaryValue_swigregister = _cntk_py.DictionaryValue_swigregister
DictionaryValue_swigregister(DictionaryValue)

def DictionaryValue_type_name(type):
    return _cntk_py.DictionaryValue_type_name(type)
DictionaryValue_type_name = _cntk_py.DictionaryValue_type_name

def DictionaryValueFromDict(value):
    val = _cntk_py.new_DictionaryValueFromDict(value)
    return val

class Dictionary(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dictionary, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Dictionary, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _cntk_py.delete_Dictionary
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _cntk_py.new_Dictionary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def contains(self, *args):
        return _cntk_py.Dictionary_contains(self, *args)

    def __eq__(self, other):
        return _cntk_py.Dictionary___eq__(self, other)

    def __ne__(self, other):
        return _cntk_py.Dictionary___ne__(self, other)

    def __getitem__(self, key):
        return _cntk_py.Dictionary___getitem__(self, key)

    def __setitem__(self, key, value):
        return _cntk_py.Dictionary___setitem__(self, key, value)
Dictionary_swigregister = _cntk_py.Dictionary_swigregister
Dictionary_swigregister(Dictionary)

class BackPropState(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BackPropState, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BackPropState, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def function(self):
        return _cntk_py.BackPropState_function(self)
    __swig_destroy__ = _cntk_py.delete_BackPropState
    __del__ = lambda self: None
BackPropState_swigregister = _cntk_py.BackPropState_swigregister
BackPropState_swigregister(BackPropState)

ParameterCloningMethod_Share = _cntk_py.ParameterCloningMethod_Share
ParameterCloningMethod_Clone = _cntk_py.ParameterCloningMethod_Clone
ParameterCloningMethod_Freeze = _cntk_py.ParameterCloningMethod_Freeze
class Function(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Function, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Function, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def forward(self, *args):
        return _cntk_py.Function_forward(self, *args)

    def backward(self, state, rootGradientValues, backPropagatedGradientValuesForInputs):
        return _cntk_py.Function_backward(self, state, rootGradientValues, backPropagatedGradientValuesForInputs)
    __swig_destroy__ = _cntk_py.delete_Function
    __del__ = lambda self: None

    def clone(self, *args):
        return _cntk_py.Function_clone(self, *args)

    def name(self):
        return _cntk_py.Function_name(self)

    def root_function(self):
        return _cntk_py.Function_root_function(self)

    def inputs(self):
        return _cntk_py.Function_inputs(self)

    def output_internal(self):
        return _cntk_py.Function_output_internal(self)

    def outputs(self):
        return _cntk_py.Function_outputs(self)

    def arguments(self):
        return _cntk_py.Function_arguments(self)

    def parameters(self):
        return _cntk_py.Function_parameters(self)

    def constants(self):
        return _cntk_py.Function_constants(self)

    def placeholders(self):
        return _cntk_py.Function_placeholders(self)

    def attributes(self):
        return _cntk_py.Function_attributes(self)

    def replace_placeholders_internal(self, placeholderReplacements):
        return _cntk_py.Function_replace_placeholders_internal(self, placeholderReplacements)
Function_swigregister = _cntk_py.Function_swigregister
Function_swigregister(Function)


def negate(*args):
    return _cntk_py.negate(*args)
negate = _cntk_py.negate

def sigmoid(*args):
    return _cntk_py.sigmoid(*args)
sigmoid = _cntk_py.sigmoid

def tanh(*args):
    return _cntk_py.tanh(*args)
tanh = _cntk_py.tanh

def re_lu(*args):
    return _cntk_py.re_lu(*args)
re_lu = _cntk_py.re_lu

def exp(*args):
    return _cntk_py.exp(*args)
exp = _cntk_py.exp

def log(*args):
    return _cntk_py.log(*args)
log = _cntk_py.log

def square(*args):
    return _cntk_py.square(*args)
square = _cntk_py.square

def sqrt(*args):
    return _cntk_py.sqrt(*args)
sqrt = _cntk_py.sqrt

def round(*args):
    return _cntk_py.round(*args)
round = _cntk_py.round

def floor(*args):
    return _cntk_py.floor(*args)
floor = _cntk_py.floor

def ceil(*args):
    return _cntk_py.ceil(*args)
ceil = _cntk_py.ceil

def abs(*args):
    return _cntk_py.abs(*args)
abs = _cntk_py.abs

def reciprocal(*args):
    return _cntk_py.reciprocal(*args)
reciprocal = _cntk_py.reciprocal

def softmax(*args):
    return _cntk_py.softmax(*args)
softmax = _cntk_py.softmax

def hardmax(*args):
    return _cntk_py.hardmax(*args)
hardmax = _cntk_py.hardmax

def transpose_axes(*args):
    return _cntk_py.transpose_axes(*args)
transpose_axes = _cntk_py.transpose_axes

def transpose(*args):
    return _cntk_py.transpose(*args)
transpose = _cntk_py.transpose

def slice(*args):
    return _cntk_py.slice(*args)
slice = _cntk_py.slice

def dropout(*args):
    return _cntk_py.dropout(*args)
dropout = _cntk_py.dropout

def reshape(*args):
    return _cntk_py.reshape(*args)
reshape = _cntk_py.reshape

def plus(*args):
    return _cntk_py.plus(*args)
plus = _cntk_py.plus

def __add__(leftOperand, rightOperand):
    return _cntk_py.__add__(leftOperand, rightOperand)
__add__ = _cntk_py.__add__

def minus(*args):
    return _cntk_py.minus(*args)
minus = _cntk_py.minus

def __sub__(*args):
    return _cntk_py.__sub__(*args)
__sub__ = _cntk_py.__sub__

def element_times(*args):
    return _cntk_py.element_times(*args)
element_times = _cntk_py.element_times

def element_divide(*args):
    return _cntk_py.element_divide(*args)
element_divide = _cntk_py.element_divide

def equal(*args):
    return _cntk_py.equal(*args)
equal = _cntk_py.equal

def not_equal(*args):
    return _cntk_py.not_equal(*args)
not_equal = _cntk_py.not_equal

def less(*args):
    return _cntk_py.less(*args)
less = _cntk_py.less

def less_equal(*args):
    return _cntk_py.less_equal(*args)
less_equal = _cntk_py.less_equal

def greater(*args):
    return _cntk_py.greater(*args)
greater = _cntk_py.greater

def greater_equal(*args):
    return _cntk_py.greater_equal(*args)
greater_equal = _cntk_py.greater_equal

def times(*args):
    return _cntk_py.times(*args)
times = _cntk_py.times

def transpose_times(*args):
    return _cntk_py.transpose_times(*args)
transpose_times = _cntk_py.transpose_times

def squared_error(*args):
    return _cntk_py.squared_error(*args)
squared_error = _cntk_py.squared_error

def cross_entropy_with_softmax(*args):
    return _cntk_py.cross_entropy_with_softmax(*args)
cross_entropy_with_softmax = _cntk_py.cross_entropy_with_softmax

def classification_error(*args):
    return _cntk_py.classification_error(*args)
classification_error = _cntk_py.classification_error

def past_value(*args):
    return _cntk_py.past_value(*args)
past_value = _cntk_py.past_value

def future_value(*args):
    return _cntk_py.future_value(*args)
future_value = _cntk_py.future_value

def reduce_sum(*args):
    return _cntk_py.reduce_sum(*args)
reduce_sum = _cntk_py.reduce_sum

def reduce_log_sum(*args):
    return _cntk_py.reduce_log_sum(*args)
reduce_log_sum = _cntk_py.reduce_log_sum

def reduce_mean(*args):
    return _cntk_py.reduce_mean(*args)
reduce_mean = _cntk_py.reduce_mean

def reduce_max(*args):
    return _cntk_py.reduce_max(*args)
reduce_max = _cntk_py.reduce_max

def reduce_min(*args):
    return _cntk_py.reduce_min(*args)
reduce_min = _cntk_py.reduce_min

def per_dim_mean_variance_normalize(*args):
    return _cntk_py.per_dim_mean_variance_normalize(*args)
per_dim_mean_variance_normalize = _cntk_py.per_dim_mean_variance_normalize

def convolution(*args):
    return _cntk_py.convolution(*args)
convolution = _cntk_py.convolution
PoolingType_Max = _cntk_py.PoolingType_Max
PoolingType_Average = _cntk_py.PoolingType_Average

def pooling(*args):
    return _cntk_py.pooling(*args)
pooling = _cntk_py.pooling

def batch_normalization(*args):
    return _cntk_py.batch_normalization(*args)
batch_normalization = _cntk_py.batch_normalization

def clip(*args):
    return _cntk_py.clip(*args)
clip = _cntk_py.clip

def element_select(*args):
    return _cntk_py.element_select(*args)
element_select = _cntk_py.element_select

def splice(*args):
    return _cntk_py.splice(*args)
splice = _cntk_py.splice

def combine(*args):
    return _cntk_py.combine(*args)
combine = _cntk_py.combine

def is_first(*args):
    return _cntk_py.is_first(*args)
is_first = _cntk_py.is_first

def is_last(*args):
    return _cntk_py.is_last(*args)
is_last = _cntk_py.is_last

def first(*args):
    return _cntk_py.first(*args)
first = _cntk_py.first

def last(*args):
    return _cntk_py.last(*args)
last = _cntk_py.last

def where(*args):
    return _cntk_py.where(*args)
where = _cntk_py.where

def gather(*args):
    return _cntk_py.gather(*args)
gather = _cntk_py.gather

def scatter(*args):
    return _cntk_py.scatter(*args)
scatter = _cntk_py.scatter

def broadcast_as(*args):
    return _cntk_py.broadcast_as(*args)
broadcast_as = _cntk_py.broadcast_as

def load_legacy_model(*args):
    return _cntk_py.load_legacy_model(*args)
load_legacy_model = _cntk_py.load_legacy_model

def save_as_legacy_model(rootFunction, modelFile):
    return _cntk_py.save_as_legacy_model(rootFunction, modelFile)
save_as_legacy_model = _cntk_py.save_as_legacy_model
class Learner(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Learner, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Learner, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def update(self, gradientValues, trainingSampleCount):
        return _cntk_py.Learner_update(self, gradientValues, trainingSampleCount)

    def parameters(self):
        return _cntk_py.Learner_parameters(self)

    def get_checkpoint_state(self):
        return _cntk_py.Learner_get_checkpoint_state(self)

    def restore_from_checkpoint(self, arg2):
        return _cntk_py.Learner_restore_from_checkpoint(self, arg2)
    __swig_destroy__ = _cntk_py.delete_Learner
    __del__ = lambda self: None
Learner_swigregister = _cntk_py.Learner_swigregister
Learner_swigregister(Learner)


def sgd_learner(*args):
    return _cntk_py.sgd_learner(*args)
sgd_learner = _cntk_py.sgd_learner

def momentum_sgd_learner(*args):
    return _cntk_py.momentum_sgd_learner(*args)
momentum_sgd_learner = _cntk_py.momentum_sgd_learner

def nesterov_learner(*args):
    return _cntk_py.nesterov_learner(*args)
nesterov_learner = _cntk_py.nesterov_learner

def fsada_grad_learner(*args):
    return _cntk_py.fsada_grad_learner(*args)
fsada_grad_learner = _cntk_py.fsada_grad_learner

def ada_grad_learner(*args):
    return _cntk_py.ada_grad_learner(*args)
ada_grad_learner = _cntk_py.ada_grad_learner

def rmsprop_learner(*args):
    return _cntk_py.rmsprop_learner(*args)
rmsprop_learner = _cntk_py.rmsprop_learner
class Trainer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Trainer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Trainer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_Trainer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def train_minibatch(self, *args):
        return _cntk_py.Trainer_train_minibatch(self, *args)

    def test_minibatch(self, *args):
        return _cntk_py.Trainer_test_minibatch(self, *args)

    def save_checkpoint(self, modelFilePath):
        return _cntk_py.Trainer_save_checkpoint(self, modelFilePath)

    def restore_from_checkpoint(self, modelFilePath):
        return _cntk_py.Trainer_restore_from_checkpoint(self, modelFilePath)

    def model(self):
        return _cntk_py.Trainer_model(self)

    def loss_function(self):
        return _cntk_py.Trainer_loss_function(self)

    def evaluation_function(self):
        return _cntk_py.Trainer_evaluation_function(self)

    def previous_minibatch_loss_average(self):
        return _cntk_py.Trainer_previous_minibatch_loss_average(self)

    def previous_minibatch_evaluation_average(self):
        return _cntk_py.Trainer_previous_minibatch_evaluation_average(self)

    def previous_minibatch_sample_count(self):
        return _cntk_py.Trainer_previous_minibatch_sample_count(self)

    def parameter_learners(self):
        return _cntk_py.Trainer_parameter_learners(self)
    __swig_destroy__ = _cntk_py.delete_Trainer
    __del__ = lambda self: None
Trainer_swigregister = _cntk_py.Trainer_swigregister
Trainer_swigregister(Trainer)

class StreamInformation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamInformation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StreamInformation, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_name"] = _cntk_py.StreamInformation_m_name_set
    __swig_getmethods__["m_name"] = _cntk_py.StreamInformation_m_name_get
    if _newclass:
        m_name = _swig_property(_cntk_py.StreamInformation_m_name_get, _cntk_py.StreamInformation_m_name_set)
    __swig_setmethods__["m_id"] = _cntk_py.StreamInformation_m_id_set
    __swig_getmethods__["m_id"] = _cntk_py.StreamInformation_m_id_get
    if _newclass:
        m_id = _swig_property(_cntk_py.StreamInformation_m_id_get, _cntk_py.StreamInformation_m_id_set)
    __swig_setmethods__["m_storage_format"] = _cntk_py.StreamInformation_m_storage_format_set
    __swig_getmethods__["m_storage_format"] = _cntk_py.StreamInformation_m_storage_format_get
    if _newclass:
        m_storage_format = _swig_property(_cntk_py.StreamInformation_m_storage_format_get, _cntk_py.StreamInformation_m_storage_format_set)
    __swig_setmethods__["m_element_type"] = _cntk_py.StreamInformation_m_element_type_set
    __swig_getmethods__["m_element_type"] = _cntk_py.StreamInformation_m_element_type_get
    if _newclass:
        m_element_type = _swig_property(_cntk_py.StreamInformation_m_element_type_get, _cntk_py.StreamInformation_m_element_type_set)
    __swig_setmethods__["m_sample_layout"] = _cntk_py.StreamInformation_m_sample_layout_set
    __swig_getmethods__["m_sample_layout"] = _cntk_py.StreamInformation_m_sample_layout_get
    if _newclass:
        m_sample_layout = _swig_property(_cntk_py.StreamInformation_m_sample_layout_get, _cntk_py.StreamInformation_m_sample_layout_set)

    def __hash__(self):
        return _cntk_py.StreamInformation___hash__(self)

    def __init__(self):
        this = _cntk_py.new_StreamInformation()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_StreamInformation
    __del__ = lambda self: None
StreamInformation_swigregister = _cntk_py.StreamInformation_swigregister
StreamInformation_swigregister(StreamInformation)


def __eq__(*args):
    return _cntk_py.__eq__(*args)
__eq__ = _cntk_py.__eq__
class MinibatchData(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinibatchData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MinibatchData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_num_sequences"] = _cntk_py.MinibatchData_m_num_sequences_set
    __swig_getmethods__["m_num_sequences"] = _cntk_py.MinibatchData_m_num_sequences_get
    if _newclass:
        m_num_sequences = _swig_property(_cntk_py.MinibatchData_m_num_sequences_get, _cntk_py.MinibatchData_m_num_sequences_set)
    __swig_setmethods__["m_num_samples"] = _cntk_py.MinibatchData_m_num_samples_set
    __swig_getmethods__["m_num_samples"] = _cntk_py.MinibatchData_m_num_samples_get
    if _newclass:
        m_num_samples = _swig_property(_cntk_py.MinibatchData_m_num_samples_get, _cntk_py.MinibatchData_m_num_samples_set)
    __swig_setmethods__["m_data"] = _cntk_py.MinibatchData_m_data_set
    __swig_getmethods__["m_data"] = _cntk_py.MinibatchData_m_data_get
    if _newclass:
        m_data = _swig_property(_cntk_py.MinibatchData_m_data_get, _cntk_py.MinibatchData_m_data_set)

    def __init__(self):
        this = _cntk_py.new_MinibatchData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_MinibatchData
    __del__ = lambda self: None
MinibatchData_swigregister = _cntk_py.MinibatchData_swigregister
MinibatchData_swigregister(MinibatchData)

class MinibatchSource(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinibatchSource, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MinibatchSource, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def stream_infos(self):
        return _cntk_py.MinibatchSource_stream_infos(self)
    __swig_destroy__ = _cntk_py.delete_MinibatchSource
    __del__ = lambda self: None

    def stream_info(self, *args):
        return _cntk_py.MinibatchSource_stream_info(self, *args)

    def get_next_minibatch(self, *args):
        return _cntk_py.MinibatchSource_get_next_minibatch(self, *args)
MinibatchSource_swigregister = _cntk_py.MinibatchSource_swigregister
MinibatchSource_swigregister(MinibatchSource)


def create_composite_minibatch_source(configuration):
    return _cntk_py.create_composite_minibatch_source(configuration)
create_composite_minibatch_source = _cntk_py.create_composite_minibatch_source
class StreamConfiguration(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamConfiguration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StreamConfiguration, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_StreamConfiguration(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["m_stream_name"] = _cntk_py.StreamConfiguration_m_stream_name_set
    __swig_getmethods__["m_stream_name"] = _cntk_py.StreamConfiguration_m_stream_name_get
    if _newclass:
        m_stream_name = _swig_property(_cntk_py.StreamConfiguration_m_stream_name_get, _cntk_py.StreamConfiguration_m_stream_name_set)
    __swig_setmethods__["m_dim"] = _cntk_py.StreamConfiguration_m_dim_set
    __swig_getmethods__["m_dim"] = _cntk_py.StreamConfiguration_m_dim_get
    if _newclass:
        m_dim = _swig_property(_cntk_py.StreamConfiguration_m_dim_get, _cntk_py.StreamConfiguration_m_dim_set)
    __swig_setmethods__["m_is_sparse"] = _cntk_py.StreamConfiguration_m_is_sparse_set
    __swig_getmethods__["m_is_sparse"] = _cntk_py.StreamConfiguration_m_is_sparse_get
    if _newclass:
        m_is_sparse = _swig_property(_cntk_py.StreamConfiguration_m_is_sparse_get, _cntk_py.StreamConfiguration_m_is_sparse_set)
    __swig_setmethods__["m_stream_alias"] = _cntk_py.StreamConfiguration_m_stream_alias_set
    __swig_getmethods__["m_stream_alias"] = _cntk_py.StreamConfiguration_m_stream_alias_get
    if _newclass:
        m_stream_alias = _swig_property(_cntk_py.StreamConfiguration_m_stream_alias_get, _cntk_py.StreamConfiguration_m_stream_alias_set)
    __swig_destroy__ = _cntk_py.delete_StreamConfiguration
    __del__ = lambda self: None
StreamConfiguration_swigregister = _cntk_py.StreamConfiguration_swigregister
StreamConfiguration_swigregister(StreamConfiguration)


def text_format_minibatch_source(*args):
    return _cntk_py.text_format_minibatch_source(*args)
text_format_minibatch_source = _cntk_py.text_format_minibatch_source

def compute_input_per_dim_means_and_inv_std_devs(*args):
    return _cntk_py.compute_input_per_dim_means_and_inv_std_devs(*args)
compute_input_per_dim_means_and_inv_std_devs = _cntk_py.compute_input_per_dim_means_and_inv_std_devs
class learning_rates_per_sample(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, learning_rates_per_sample, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, learning_rates_per_sample, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_learning_rates_per_sample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_learning_rates_per_sample
    __del__ = lambda self: None
learning_rates_per_sample_swigregister = _cntk_py.learning_rates_per_sample_swigregister
learning_rates_per_sample_swigregister(learning_rates_per_sample)

class momentums_per_sample(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, momentums_per_sample, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, momentums_per_sample, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _cntk_py.new_momentums_per_sample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_momentums_per_sample
    __del__ = lambda self: None
momentums_per_sample_swigregister = _cntk_py.momentums_per_sample_swigregister
momentums_per_sample_swigregister(momentums_per_sample)

class Callback(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Callback, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Callback, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _cntk_py.delete_Callback
    __del__ = lambda self: None

    def forward(self):
        return _cntk_py.Callback_forward(self)

    def backward(self):
        return _cntk_py.Callback_backward(self)

    def __init__(self):
        if self.__class__ == Callback:
            _self = None
        else:
            _self = self
        this = _cntk_py.new_Callback(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _cntk_py.disown_Callback(self)
        return weakref_proxy(self)
Callback_swigregister = _cntk_py.Callback_swigregister
Callback_swigregister(Callback)

class FunctionInCNTK(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FunctionInCNTK, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FunctionInCNTK, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _cntk_py.new_FunctionInCNTK()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _cntk_py.delete_FunctionInCNTK
    __del__ = lambda self: None

    def del_callback(self):
        return _cntk_py.FunctionInCNTK_del_callback(self)

    def set_callback(self, cb):
        return _cntk_py.FunctionInCNTK_set_callback(self, cb)

    def forward(self):
        return _cntk_py.FunctionInCNTK_forward(self)

    def backward(self):
        return _cntk_py.FunctionInCNTK_backward(self)
FunctionInCNTK_swigregister = _cntk_py.FunctionInCNTK_swigregister
FunctionInCNTK_swigregister(FunctionInCNTK)


Variable.__eq__ = lambda a,b: Variable_eq(a,b)


Constant.__eq__ = lambda a,b: Variable_eq(a,b)


Parameter.__eq__ = lambda a,b: Variable_eq(a,b)


NDShape.__eq__ = lambda a,b: NDShape_eq(a,b)


StreamInformation.__eq__ = lambda a,b: a.m_name==b.m_name and a.m_id==b.m_id and a.m_storage_format==b.m_storage_format and a.m_element_type==b.m_element_type and a.m_sample_layout.dimensions()==b.m_sample_layout.dimensions()


# in case of multiple outputs return the function, not the variable
def get_output_and_keep_reference(self):
    variable = self.output_internal()    
    variable.owner = self
    return variable
Function.output = lambda self:get_output_and_keep_reference(self)
Function.replace_placeholders = lambda self, ph_map: self.replace_placeholders_internal(ph_map)

from .tensor import _add_tensor_ops, _add_eval
for klass in [Function, Variable]:
    _add_tensor_ops(klass)

_add_eval(Function)

# This file is compatible with both classic and new-style classes.


