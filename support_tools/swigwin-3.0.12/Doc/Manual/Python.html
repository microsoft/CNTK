<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>SWIG and Python</title>
<link rel="stylesheet" type="text/css" href="style.css">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>

<body bgcolor="#ffffff">
<H1><a name="Python">36 SWIG and Python</a></H1>
<!-- INDEX -->
<div class="sectiontoc">
<ul>
<li><a href="#Python_nn2">Overview</a>
<li><a href="#Python_nn3">Preliminaries</a>
<ul>
<li><a href="#Python_nn4">Running SWIG</a>
<li><a href="#Python_nn6">Using distutils</a>
<li><a href="#Python_nn7">Hand compiling a dynamic module</a>
<li><a href="#Python_nn8">Static linking</a>
<li><a href="#Python_nn9">Using your module</a>
<li><a href="#Python_nn10">Compilation of C++ extensions</a>
<li><a href="#Python_nn11">Compiling for 64-bit platforms</a>
<li><a href="#Python_nn12">Building Python Extensions under Windows</a>
</ul>
<li><a href="#Python_nn13">A tour of basic C/C++ wrapping</a>
<ul>
<li><a href="#Python_nn14">Modules</a>
<li><a href="#Python_nn15">Functions</a>
<li><a href="#Python_nn16">Global variables</a>
<li><a href="#Python_nn17">Constants and enums</a>
<li><a href="#Python_nn18">Pointers</a>
<li><a href="#Python_nn19">Structures</a>
<li><a href="#Python_nn20">C++ classes</a>
<li><a href="#Python_nn21">C++ inheritance</a>
<li><a href="#Python_nn22">Pointers, references, values, and arrays</a>
<li><a href="#Python_nn23">C++ overloaded functions</a>
<li><a href="#Python_nn24">C++ operators</a>
<li><a href="#Python_nn25">C++ namespaces</a>
<li><a href="#Python_nn26">C++ templates</a>
<li><a href="#Python_nn27">C++ Smart Pointers</a>
<ul>
<li><a href="#Python_smart_pointers_shared_ptr">The shared_ptr Smart Pointer</a>
<li><a href="#Python_smart_pointers_generic">Generic Smart Pointers</a>
</ul>
<li><a href="#Python_nn27a">C++ reference counted objects</a>
</ul>
<li><a href="#Python_nn28">Further details on the Python class interface</a>
<ul>
<li><a href="#Python_nn29">Proxy classes</a>
<li><a href="#Python_builtin_types">Built-in Types</a>
<ul>
<li><a href="#Python_builtin_limitations">Limitations</a>
<li><a href="#Python_builtin_overloads">Operator overloads and slots -- use them!</a>
</ul>
<li><a href="#Python_nn30">Memory management</a>
<li><a href="#Python_nn31">Python 2.2 and classic classes</a>
</ul>
<li><a href="#Python_directors">Cross language polymorphism</a>
<ul>
<li><a href="#Python_nn33">Enabling directors</a>
<li><a href="#Python_nn34">Director classes</a>
<li><a href="#Python_nn35">Ownership and object destruction</a>
<li><a href="#Python_nn36">Exception unrolling</a>
<li><a href="#Python_nn37">Overhead and code bloat</a>
<li><a href="#Python_nn38">Typemaps</a>
<li><a href="#Python_nn39">Miscellaneous</a>
</ul>
<li><a href="#Python_nn40">Common customization features</a>
<ul>
<li><a href="#Python_nn41">C/C++ helper functions</a>
<li><a href="#Python_nn42">Adding additional Python code</a>
<li><a href="#Python_nn43">Class extension with %extend</a>
<li><a href="#Python_nn44">Exception handling with %exception</a>
</ul>
<li><a href="#Python_nn45">Tips and techniques</a>
<ul>
<li><a href="#Python_nn46">Input and output parameters</a>
<li><a href="#Python_nn47">Simple pointers</a>
<li><a href="#Python_nn48">Unbounded C Arrays</a>
<li><a href="#Python_nn49">String handling</a>
<li><a href="#Python_default_args">Default arguments</a>
</ul>
<li><a href="#Python_nn53">Typemaps</a>
<ul>
<li><a href="#Python_nn54">What is a typemap?</a>
<li><a href="#Python_nn55">Python typemaps</a>
<li><a href="#Python_nn56">Typemap variables</a>
<li><a href="#Python_nn57">Useful Python Functions</a>
</ul>
<li><a href="#Python_nn58">Typemap Examples</a>
<ul>
<li><a href="#Python_nn59">Converting  Python list to a char ** </a>
<li><a href="#Python_nn60">Expanding a Python object into multiple arguments</a>
<li><a href="#Python_nn61">Using typemaps to return arguments</a>
<li><a href="#Python_nn62">Mapping Python tuples into small arrays</a>
<li><a href="#Python_nn63">Mapping sequences to C arrays</a>
<li><a href="#Python_nn64">Pointer handling</a>
</ul>
<li><a href="#Python_nn65">Docstring Features</a>
<ul>
<li><a href="#Python_nn66">Module docstring</a>
<li><a href="#Python_nn67">%feature("autodoc")</a>
<ul>
<li><a href="#Python_nn68">%feature("autodoc", "0")</a>
<li><a href="#Python_nn69">%feature("autodoc", "1")</a>
<li><a href="#Python_autodoc2">%feature("autodoc", "2")</a>
<li><a href="#Python_autodoc3">%feature("autodoc", "3")</a>
<li><a href="#Python_nn70">%feature("autodoc", "docstring")</a>
</ul>
<li><a href="#Python_nn71">%feature("docstring")</a>
</ul>
<li><a href="#Python_nn72">Python Packages</a>
<ul>
<li><a href="#Python_modulepackage">Setting the Python package</a>
<li><a href="#Python_absrelimports">Absolute and relative imports</a>
<li><a href="#Python_absimport">Enforcing absolute import semantics</a>
<li><a href="#Python_importfrominit">Importing from __init__.py</a>
<li><a href="#Python_implicit_namespace_packages">Implicit Namespace Packages</a>
<li><a href="#Python_package_search">Searching for the wrapper module</a>
<ul>
<li><a href="#Python_package_search_both_package_modules">Both modules in the same package</a>
<li><a href="#Python_package_search_wrapper_split">Split modules</a>
<li><a href="#Python_package_search_both_global_modules">Both modules are global</a>
<li><a href="#Python_package_search_static">Statically linked C modules</a>
</ul>
</ul>
<li><a href="#Python_python3support">Python 3 Support</a>
<ul>
<li><a href="#Python_nn74">Function annotation</a>
<li><a href="#Python_nn75">Buffer interface</a>
<li><a href="#Python_nn76">Abstract base classes</a>
<li><a href="#Python_nn77">Byte string output conversion</a>
<li><a href="#Python_2_unicode">Python 2 Unicode</a>
</ul>
</ul>
</div>
<!-- INDEX -->



<p>
<b>Caution: This chapter is under repair!</b>
</p>

<p>
This chapter describes SWIG's support of Python.  SWIG is compatible
with most recent Python versions including Python 3.0 and Python 2.6,
as well as older versions dating back to Python 2.0.  For the best results,
consider using Python 2.3 or newer.
</p>

<p>
This chapter covers most SWIG features, but certain low-level details
are covered in less depth than in earlier chapters.  At the
very least, make sure you read the "<a href="SWIG.html#SWIG">SWIG
Basics</a>" chapter.
</p>

<H2><a name="Python_nn2">36.1 Overview</a></H2>


<p>
To build Python extension modules, SWIG uses a layered approach in which
parts of the extension module are defined in C and other parts are 
defined in Python.  The C layer contains low-level wrappers whereas Python code
is used to define high-level features.
</p>

<p>
This layered approach recognizes the fact that certain aspects of
extension building are better accomplished in each language (instead
of trying to do everything in C or C++). Furthermore, by generating code in both
languages, you get a lot more flexibility since you can enhance the extension
module with support code in either language.
</p>

<p>
In describing the Python interface, this chapter starts by covering the
basics of configuration, compiling, and installing Python modules.
Next, the Python interface to common C and C++ programming features is
described.  Advanced customization features such as typemaps are then
described followed by a discussion of low-level implementation
details.
</p>

<H2><a name="Python_nn3">36.2 Preliminaries</a></H2>


<H3><a name="Python_nn4">36.2.1 Running SWIG</a></H3>


<p>
Suppose that you defined a SWIG module such as the following:
</p>

<div class="code">
<pre>
/* File: example.i */
%module example

%{
#define SWIG_FILE_WITH_INIT
#include "example.h"
%}

int fact(int n);
</pre>
</div>

<p>
The <tt>#define SWIG_FILE_WITH_INIT</tt> line inserts a macro that specifies that the
resulting C file should be built as a python extension, inserting the module
<tt>init</tt> code. This <tt>.i</tt> file wraps the following simple C file:
</p>

<div class="code">
<pre>
/* File: example.c */

#include "example.h"

int fact(int n) {
    if (n &lt; 0){ /* This should probably return an error, but this is simpler */
        return 0;
    }
    if (n == 0) {
        return 1;
    }
    else {
        /* testing for overflow would be a good idea here */
        return n * fact(n-1);
    }
}

</pre>
</div>

<p>
With the header file:
</p>

<div class="code">
<pre>
/* File: example.h */

int fact(int n);
</pre>
</div>

<p>
To build a Python module, run SWIG using the <tt>-python</tt> option:
</p>

<div class="shell"><pre>
$ swig -python example.i
</pre></div>

<p>
If building a C++ extension, add the <tt>-c++</tt> option:
</p>

<div class="shell"><pre>
$ swig -c++ -python example.i
</pre></div>

<p>
This creates two different files; a C/C++ source file <tt>example_wrap.c</tt> or
<tt>example_wrap.cxx</tt> and a Python source file <tt>example.py</tt>.   The generated C
source file contains the low-level wrappers that need to be compiled and linked with the
rest of your C/C++ application to create an extension module. The Python source file
contains high-level support code. This is the file that you will import to use the module.
</p>

<p>
The name of the wrapper file is derived from the name of the input file.  For example, if the
input file is <tt>example.i</tt>, the name of the wrapper file is <tt>example_wrap.c</tt>.
To change this, you can use the <tt>-o</tt> option.   The name of the Python file is derived
from the module name specified with <tt>%module</tt>.  If the module name is <tt>example</tt>,
then a file <tt>example.py</tt> is created.
</p>

<p>
The following sections have further practical examples and details on
how you might go about compiling and using the generated files.
</p>

<H3><a name="Python_nn6">36.2.2 Using distutils</a></H3>


<p>
The preferred approach to building an extension module for python is to compile it with
distutils, which comes with all recent versions of python
(<a href="https://docs.python.org/library/distutils.html">Distutils Docs</a>).
</p>

<p>
Distutils takes care of making sure that your extension is built with all the correct
flags, headers, etc. for the version of Python it is run with. Distutils will compile your
extension into a shared object file or DLL (<tt>.so</tt> on Linux, <tt>.pyd</tt> on
Windows, etc). In addition, distutils can handle installing your package into
site-packages, if that is desired. A configuration file (conventionally called: <tt>setup.py</tt>)
describes the extension (and related python modules). The distutils will
then generate all the right compiler directives to build it for you.
</p>

<p>
Here is a sample <tt>setup.py</tt> file for the above example:
</p>

<div class="code">
<pre>
#!/usr/bin/env python

"""
setup.py file for SWIG example
"""

from distutils.core import setup, Extension


example_module = Extension('_example',
                           sources=['example_wrap.c', 'example.c'],
                           )

setup (name = 'example',
       version = '0.1',
       author      = "SWIG Docs",
       description = """Simple swig example from docs""",
       ext_modules = [example_module],
       py_modules = ["example"],
       )
</pre>
</div>

<p>
In this example, the line: <tt>example_module = Extension(....)</tt> creates an Extension
module object, defining the name as <tt>_example</tt>, and using the source code files:
<tt>example_wrap.c</tt>, generated by swig, and <tt>example.c</tt>, your original c
source. The swig (and other python extension modules) tradition is for the compiled
extension to have the name of the python portion, prefixed by an underscore. If the name
of your python module is "<tt>example.py</tt>", then the name of the corresponding object file
will be"<tt>_example.so</tt>"
</p>

<p>
The <tt>setup</tt> call then sets up distutils to build your package, defining
some meta data, and passing in your extension module object.
Once this is saved as <tt>setup.py</tt>, you can build your extension with these commands:
</p>

<div class="shell"><pre>
$ swig -python example.i
$ python setup.py build_ext --inplace
</pre></div>

<p>
And a .so, or .pyd or... will be created for you. It will build a version that matches the
python that you run the command with. Taking apart the command line:
</p>

<ul>
<li> <tt>python</tt> -- the version of python you want to build for
<li> <tt>setup.py</tt> -- the name of your setup script (it can be called anything, but
     setup.py is the tradition)
<li> <tt>build_ext</tt> -- telling distutils to build extensions
<li> <tt>--inplace</tt> -- this tells distutils to put the extension lib in the current dir.
     Otherwise, it will put it inside a build hierarchy, and you'd have to move it to use it.
</ul>

<p>
The distutils have many other features, consult the python distutils docs for details.
</p>

<p>
This same approach works on all platforms if the appropriate compiler is installed. (it
can even build extensions to the standard Windows Python using MingGW)
</p>

<H3><a name="Python_nn7">36.2.3 Hand compiling a dynamic module</a></H3>


<p>
While the preferred approach to building an extension module is to use the distutils, some
people like to integrate building extensions with a larger build system, and thus may wish
to compile their modules without the distutils. To do this, you need to compile your
program using commands like this (shown for Linux):
</p>

<div class="shell"><pre>
$ swig -python example.i
$ gcc -O2 -fPIC -c example.c
$ gcc -O2 -fPIC -c example_wrap.c -I/usr/local/include/python2.5
$ gcc -shared example.o example_wrap.o -o _example.so
</pre></div>

<p>
The exact commands for doing this vary from platform to platform. 
However, SWIG tries to guess the right options when it is installed.  Therefore, 
you may want to start with one of the examples in the <tt>SWIG/Examples/python</tt> 
directory.   If that doesn't work, you will need to read the man-pages for
your compiler and linker to get the right set of options.  You might also
check the <a href="https://github.com/swig/swig/wiki">SWIG Wiki</a> for
additional information.
</p>

<p>
When linking the module, <b>the name of the output file has to match the name
of the module prefixed by an underscore</b>.  If the name of your module is "<tt>example</tt>", then the
name of the corresponding object file should be
"<tt>_example.so</tt>" or "<tt>_examplemodule.so</tt>".
The name of the module is specified using the <tt>%module</tt> directive or the 
<tt>-module</tt> command line option.
</p>

<p>
<b>Compatibility Note:</b> In SWIG-1.3.13 and earlier releases, module
names did not include the leading underscore.  This is because modules
were normally created as C-only extensions without the extra Python
support file (instead, creating Python code was supported as an optional
feature).  This has been changed in SWIG-1.3.14 and is consistent with
other Python extension modules.  For example, the <tt>socket</tt>
module actually consists of two files; <tt>socket.py</tt> and
<tt>_socket.so</tt>.  Many other built-in Python modules follow a similar convention.
</p>


<H3><a name="Python_nn8">36.2.4 Static linking</a></H3>


<p>
An alternative approach to dynamic linking is to rebuild the Python
interpreter with your extension module added to it.  In the past,
this approach was sometimes necessary due to limitations in dynamic loading
support on certain machines.  However, the situation has improved greatly
over the last few years and you should not consider this approach 
unless there is really no other option.
</p>

<p>
The usual procedure for adding a new module to Python involves finding
the Python source, adding an entry to the <tt>Modules/Setup</tt> file,
and rebuilding the interpreter using the Python Makefile.  However,
newer Python versions have changed the build process.  You may need to edit
the 'setup.py' file in the Python distribution instead.
</p>

<p>
In earlier versions of SWIG, the <tt>embed.i</tt> library file could be used to
rebuild the interpreter.  For example:
</p>

<div class="code"><pre>
%module example

%inline %{
extern int fact(int);
extern int mod(int, int);
extern double My_variable;
%}

%include "embed.i"       // Include code for a static version of Python

</pre></div>

<p>
The <tt>embed.i</tt> library file includes supporting code that
contains everything needed to rebuild Python. To rebuild the interpreter,
you simply do something like this:
</p>

<div class="shell"><pre>
$ swig -python -lembed.i example.i
$ gcc example.c example_wrap.c \
        -Xlinker -export-dynamic \
        -DHAVE_CONFIG_H -I/usr/include/python2.7 \
        -I/usr/lib/python2.7/config-x86_64-linux-gnu \
        -I/usr/lib/python2.7/config \
        -L/usr/lib/python2.7/config -lpython2.7 -lm -ldl \
        -o mypython
</pre></div>
<p>
You will need to supply the same libraries that were used to build Python the first
time.  This may include system libraries such as <tt>-lsocket</tt>, <tt>-lnsl</tt>,
and <tt>-lpthread</tt>.  Assuming this actually works, the new version of Python
should be identical to the default version except that your extension module will be
a built-in part of the interpreter.
</p>

<p>
<b>Comment:</b> In practice, you should probably try to avoid static
linking if possible. Some programmers may be inclined
to use static linking in the interest of getting better performance.
However, the performance gained by static linking tends to be rather
minimal in most situations (and quite frankly not worth the extra
hassle in the opinion of this author). 
</p>

<p>
<b>Compatibility note:</b> The <tt>embed.i</tt> library file is
deprecated and has not been actively maintained for many years.  Even though it
appears to "work" with Python 2.7, no future support is guaranteed.
If using static linking, you might want to rely on a different approach
(perhaps using distutils).
</p>

<H3><a name="Python_nn9">36.2.5 Using your module</a></H3>


<p>
To use your module, simply use the Python <tt>import</tt> statement. If
all goes well, you will be able to run this:
</p>

<div class="targetlang"><pre>
$ python
&gt;&gt;&gt; import example
&gt;&gt;&gt; example.fact(4)
24
&gt;&gt;&gt;
</pre></div>

<p>
A common error received by first-time users is the following:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; import example
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "example.py", line 2, in ?
    import _example
ImportError: No module named _example
</pre>
</div>

<p>
If you get this message, it means that you either forgot to compile the wrapper
code into an extension module or you didn't give the extension module the right
name.  Make sure that you compiled the wrappers into a module called <tt>_example.so</tt>.  And
don't forget the leading underscore (_).
</p>

<p>
Another possible error is the following:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; import example
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ImportError: dynamic module does not define init function (init_example)
&gt;&gt;&gt;                                                               
</pre>
</div>

<p>
This error is almost always caused when a bad name is given to the shared object file. 
For example, if you created a file <tt>example.so</tt> instead of <tt>_example.so</tt> you would 
get this error.  Alternatively, this error could arise if the name of the module is
inconsistent with the module name supplied with the <tt>%module</tt> directive.
Double-check the interface to make sure the module name and the shared object
filename match.  Another possible cause of this error is forgetting to link the SWIG-generated
wrapper code with the rest of your application when creating the extension module.
</p>

<p>
Another common error is something similar to the following:
</p>

<div class="targetlang">
<pre>
Traceback (most recent call last):
  File "example.py", line 3, in ?
    import example
ImportError: ./_example.so: undefined symbol: fact
</pre>
</div>

<p>
This error usually indicates that you forgot to include some object
files or libraries in the linking of the shared library file.  Make
sure you compile both the SWIG wrapper file and your original program
into a shared library file.  Make sure you pass all of the required libraries
to the linker.  
</p>

<p>
Sometimes unresolved symbols occur because a wrapper has been created
for a function that doesn't actually exist in a library.  This usually
occurs when a header file includes a declaration for a function that
was never actually implemented or it was removed from a library
without updating the header file.  To fix this, you can either edit
the SWIG input file to remove the offending declaration or you can use
the <tt>%ignore</tt> directive to ignore the declaration.
</p>

<p>
Finally, suppose that your extension module is linked with another library like this:
</p>

<div class="shell">
<pre>
$ gcc -shared example.o example_wrap.o -L/home/beazley/projects/lib <b>-lfoo</b> \
      -o _example.so
</pre>
</div>

<p>
If the <tt>foo</tt> library is compiled as a shared library, you might encounter the following
problem when you try to use your module:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; import example
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ImportError: libfoo.so: cannot open shared object file: No such file or directory
&gt;&gt;&gt;                 
</pre>
</div>

<p>
This error is generated because the dynamic linker can't locate the
<tt>libfoo.so</tt> library.  When shared libraries are loaded, the
system normally only checks a few standard locations such as
<tt>/usr/lib</tt> and <tt>/usr/local/lib</tt>.   To fix this problem,
there are several things you can do.  First, you can recompile your extension
module with extra path information. For example, on Linux you can do this:
</p>

<div class="shell">
<pre>
$ gcc -shared example.o example_wrap.o -L/home/beazley/projects/lib -lfoo \
      <b>-Xlinker -rpath /home/beazley/projects/lib </b> \
      -o _example.so
</pre>
</div>

<p>
Alternatively, you can set the <tt>LD_LIBRARY_PATH</tt> environment variable to
include the directory with your shared libraries. 
If setting <tt>LD_LIBRARY_PATH</tt>, be aware that setting this variable can introduce
a noticeable performance impact on all other applications that you run.
To set it only for Python, you might want to do this instead:
</p>

<div class="shell">
<pre>
$ env LD_LIBRARY_PATH=/home/beazley/projects/lib python
</pre>
</div>

<p>
Finally, you can use a command such as <tt>ldconfig</tt> (Linux) or
<tt>crle</tt> (Solaris) to add additional search paths to the default
system configuration (this requires root access and you will need to
read the man pages).
</p>

<H3><a name="Python_nn10">36.2.6 Compilation of C++ extensions</a></H3>


<p>
Compilation of C++ extensions has traditionally been a tricky problem.
Since the Python interpreter is written in C, you need to take steps to
make sure C++ is properly initialized and that modules are compiled
correctly. This should be a non-issue if you're using distutils, as
it takes care of all that for you. The following is included for
historical reasons, and in case you need to compile on your own.
</p>

<p>
On most machines, C++ extension modules should be linked using the C++
compiler.  For example:
</p>

<div class="shell"><pre>
$ swig -c++ -python example.i
$ g++ -O2 -fPIC -c example.cxx
$ g++ -O2 -fPIC -c example_wrap.cxx -I/usr/local/include/python2.5
$ g++ -shared example.o example_wrap.o -o _example.so
</pre></div>

<p>
The -fPIC option tells GCC to generate position-independent code (PIC)
which is required for most architectures (it's not vital on x86, but
still a good idea as it allows code pages from the library to be shared between
processes).  Other compilers may need a different option specified instead of
-fPIC.
</p>

<p>
In addition to this, you may need to include additional library
files to make it work.  For example, if you are using the Sun C++ compiler on
Solaris, you often need to add an extra library <tt>-lCrun</tt> like this:
</p>

<div class="shell"><pre>
$ swig -c++ -python example.i
$ CC -c example.cxx
$ CC -c example_wrap.cxx -I/usr/local/include/python2.5
$ CC -G example.o example_wrap.o -L/opt/SUNWspro/lib -o _example.so -lCrun
</pre></div>

<p>
Of course, the extra libraries to use are completely non-portable---you will 
probably need to do some experimentation.
</p>

<p>
Sometimes people have suggested that it is necessary to relink the
Python interpreter using the C++ compiler to make C++ extension modules work.
In the experience of this author, this has never actually appeared to be
necessary.   Relinking the interpreter with C++ really only includes the 
special run-time libraries described above---as long as you link your extension 
modules with these libraries, it should not be necessary to rebuild Python.
</p>

<p>
If you aren't entirely sure about the linking of a C++ extension, you
might look at an existing C++ program.  On many Unix machines, the
<tt>ldd</tt> command will list library dependencies.  This should give
you some clues about what you might have to include when you link your
extension module. For example:
</p>

<div class="shell">
<pre>
$ ldd swig
        libstdc++-libc6.1-1.so.2 =&gt; /usr/lib/libstdc++-libc6.1-1.so.2 (0x40019000)
        libm.so.6 =&gt; /lib/libm.so.6 (0x4005b000)
        libc.so.6 =&gt; /lib/libc.so.6 (0x40077000)
        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)
</pre>
</div>

<p>
As a final complication, a major weakness of C++ is that it does not
define any sort of standard for binary linking of libraries.  This
means that C++ code compiled by different compilers will not link
together properly as libraries nor is the memory layout of classes and
data structures implemented in any kind of portable manner.  In a
monolithic C++ program, this problem may be unnoticed.  However, in Python, it
is possible for different extension modules to be compiled with
different C++ compilers.  As long as these modules are self-contained,
this probably won't matter.  However, if these modules start sharing data,
you will need to take steps to avoid segmentation faults and other
erratic program behavior.   If working with lots of software components, you
might want to investigate using a more formal standard such as COM.
</p>

<H3><a name="Python_nn11">36.2.7 Compiling for 64-bit platforms</a></H3>


<p>
On platforms that support 64-bit applications (Solaris, Irix, etc.),
special care is required when building extension modules.  On these
machines, 64-bit applications are compiled and linked using a different
set of compiler/linker options.  In addition, it is not generally possible to mix 
32-bit and 64-bit code together in the same application.
</p>

<p>
To utilize 64-bits, the Python executable will need to be recompiled
as a 64-bit application.  In addition, all libraries, wrapper code,
and every other part of your application will need to be compiled for
64-bits.  If you plan to use other third-party extension modules, they
will also have to be recompiled as 64-bit extensions.
</p>

<p>
If you are wrapping commercial software for which you have no source
code, you will be forced to use the same linking standard as used by
that software.  This may prevent the use of 64-bit extensions.  It may
also introduce problems on platforms that support more than one
linking standard (e.g., -o32 and -n32 on Irix).
</p>

<p> On the Linux x86_64 platform (Opteron or EM64T), besides of the
required compiler option -fPIC discussed above, you will need to be
careful about the libraries you link with or the library path you
use. In general, a Linux distribution will have two set of libraries,
one for native x86_64 programs (under /usr/lib64), and another for 32
bits compatibility (under /usr/lib). Also, the compiler options -m32
and -m64 allow you to choose the desired binary format for your python
extension.
</p>

<H3><a name="Python_nn12">36.2.8 Building Python Extensions under Windows</a></H3>


<p>
Building a SWIG extension to Python under Windows is roughly similar to
the process used with Unix. Using the distutils, it is essentially
identical. If you have the same version of the MS compiler that Python
was built with (the python2.4 and python2.5 distributed by python.org
are built with Visual Studio 2003), the standard <tt>python setup.py
build</tt> should just work.
</p>

<p>
As of python2.5, the distutils support building extensions with MingGW out
of the box. Following the instruction here:
<a href="http://boodebr.org/main/python/build-windows-extensions">Building
Python extensions for Windows with only free tools</a> should get you started.
</p>

<p>
If you need to build it on your own, the following notes are provided:
</p>

<p>
You will need to create a DLL that can be loaded into the interpreter. 
This section briefly describes the use of SWIG with Microsoft Visual
C++.   As a starting point, many of SWIG's examples include project
files (.dsp files) for Visual C++ 6. These can be opened by more 
recent versions of Visual Studio.
You might want to take a quick look at these examples in addition to
reading this section.
</p>

<p>
In Developer Studio, SWIG should be invoked as a custom build option.
This is usually done as follows:
</p>

<ul>
<li>Open up a new workspace and use the AppWizard to select a DLL
project.

<li>Add both the SWIG interface file (the .i file), any supporting C
files, and the name of the wrapper file that will be created by SWIG
(ie. <tt>example_wrap.c</tt>).  Note : If using C++, choose a
different suffix for the wrapper file such as
<tt>example_wrap.cxx</tt>. Don't worry if the wrapper file doesn't
exist yet--Developer Studio keeps a reference to it.

<li>Select the SWIG interface file and go to the settings menu.  Under
settings, select the "Custom Build" option.

<li>Enter "SWIG" in the description field.

<li>Enter "<tt>swig -python -o $(ProjDir)\$(InputName)_wrap.c $(InputPath)</tt>" in the "Build command(s) field"

<li>Enter "<tt>$(ProjDir)\$(InputName)_wrap.c</tt>" in the "Output files(s) field".

<li>Next, select the settings for the entire project and go to
"C++:Preprocessor". Add the include directories for your Python
installation under "Additional include directories".

<li>Define the symbol  __WIN32__ under preprocessor options.  

<li>Finally, select the settings for the entire project and go to
"Link Options".  Add the Python library file to your link libraries.
For example "python21.lib".  Also, set the name of the output file to
match the name of your Python module, ie. _example.pyd - Note that _example.dll also worked with Python-2.4 and earlier.

<li>Build your project.
</ul>

<p>
If all went well, SWIG will be automatically invoked whenever
you build your project.  Any changes made to the interface file will
result in SWIG being automatically executed to produce a new version of
the wrapper file. 
</p>

<p>
To run your new Python extension, simply run Python
and use the <tt>import</tt> command as normal. For example :
</p>

<div class="targetlang"><pre>
$ python
&gt;&gt;&gt; import example
&gt;&gt;&gt; print example.fact(4)
24
&gt;&gt;&gt;
</pre></div>

<p>
If you get an <tt>ImportError</tt> exception when importing the module, you may
have forgotten to include additional library files when you built your module.
If you get an access violation or some kind of general protection fault 
immediately upon import, you have a more serious problem.   This 
is often caused by linking your extension module against the wrong 
set of Win32 debug or thread libraries.  You will have to fiddle around with
the build options of project to try and track this down.
</p>

<p>
A 'Debug' build of the wrappers requires a debug build of the Python interpreter.
This normally requires building the Python interpreter from source, which is not a
job for the feint-hearted. Alternatively you can use the 'Release' build of the
Python interpreter with a 'Debug' build of your wrappers by defining the <tt>SWIG_PYTHON_INTERPRETER_NO_DEBUG</tt>
symbol under the preprocessor options. Or you can ensure this macro is defined at the beginning
of the wrapper code using the following in your interface file, where <tt>_MSC_VER</tt> ensures it is
only used by the Visual Studio compiler:
</p>

<div class="code"><pre>
%begin %{
#ifdef _MSC_VER
#define SWIG_PYTHON_INTERPRETER_NO_DEBUG
#endif
%}
</pre></div>

<p>
Some users have reported success in building extension modules using Cygwin
and other compilers.  However, the problem of building usable DLLs with these
compilers tends to be rather problematic.  For the latest information,
you may want to consult the <a href="https://github.com/swig/swig/wiki">
SWIG Wiki</a>.
</p>


<H2><a name="Python_nn13">36.3 A tour of basic C/C++ wrapping</a></H2>


<p>
By default, SWIG tries to build a very natural Python interface
to your C/C++ code.  Functions are wrapped as functions, classes are wrapped as classes, and so forth.
This section briefly covers the essential aspects of this wrapping.
</p>

<H3><a name="Python_nn14">36.3.1 Modules</a></H3>


<p>
The SWIG <tt>%module</tt> directive specifies the name of the Python
module. If you specify `<tt>%module example</tt>', then everything is
wrapped into a Python '<tt>example</tt>' module.  Underneath the covers,
this module consists of a Python source file <tt>example.py</tt> and a low-level
extension module <tt>_example.so</tt>. When choosing a
module name, make sure you don't use the same name as a built-in
Python command or standard module name.  
</p>

<H3><a name="Python_nn15">36.3.2 Functions</a></H3>


<p>
Global functions are wrapped as new Python built-in functions.  For example,
</p>

<div class="code"><pre>
%module example
int fact(int n);
</pre></div>

<p>
creates a built-in function <tt>example.fact(n)</tt> that works exactly
like you think it does:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; import example
&gt;&gt;&gt; print example.fact(4)
24
&gt;&gt;&gt;
</pre></div>

<H3><a name="Python_nn16">36.3.3 Global variables</a></H3>


<p>
C/C++ global variables are fully supported by SWIG.  However, the underlying
mechanism is somewhat different than you might expect due to the way that
Python assignment works.  When you type the following in Python
</p>

<div class="targetlang"><pre>
a = 3.4
</pre></div>

<p>
"a" becomes a name for an object containing the value 3.4. If you later type
</p>

<div class="targetlang"><pre>
b = a
</pre></div>

<p>
then "a" and "b" are both names for the object containing the value
3.4. Thus, there is only one object containing 3.4 and "a"
and "b" are both names that refer to it. This is quite
different than C where a variable name refers to a memory location in which
a value is stored (and assignment copies data into that location). 
Because of this, there is no direct way to map variable 
assignment in C to variable assignment in Python.
</p>

<p>
To provide access to C global variables, SWIG creates a special
object called `<tt>cvar</tt>' that is added to each SWIG generated
module. Global variables are then accessed as attributes of this object.
For example, consider this interface
</p>

<div class="code"><pre>
// SWIG interface file with global variables
%module example
...
%inline %{
extern int My_variable;
extern double density;
%}
...
</pre></div>
<p>
Now look at the Python interface:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; import example
&gt;&gt;&gt; # Print out value of a C global variable
&gt;&gt;&gt; print example.cvar.My_variable
4
&gt;&gt;&gt; # Set the value of a C global variable
&gt;&gt;&gt; example.cvar.density = 0.8442
&gt;&gt;&gt; # Use in a math operation
&gt;&gt;&gt; example.cvar.density = example.cvar.density*1.10
</pre></div>

<p>
If you make an error in variable assignment, you will receive an
error message.  For example:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; example.cvar.density = "Hello"
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: C variable 'density (double )'
&gt;&gt;&gt; 
</pre></div>

<p>
If a variable is declared as <tt>const</tt>, it is wrapped as a
read-only variable.  Attempts to modify its value will result in an
error.
</p>

<p>
To make ordinary variables read-only, you can use the <tt>%immutable</tt> directive. For example:
</p>

<div class="code">
<pre>
%{
extern char *path;
%}
%immutable;
extern char *path;
%mutable;
</pre>
</div>

<p>
The <tt>%immutable</tt> directive stays in effect until it is explicitly disabled or cleared using
<tt>%mutable</tt>.
See the <a href="SWIG.html#SWIG_readonly_variables">Creating read-only variables</a> section for further details.
</p>

<p>
If you just want to make a specific variable immutable, supply a declaration name.  For example:
</p>

<div class="code">
<pre>
%{
extern char *path;
%}
%immutable path;
...
extern char *path;      // Read-only (due to %immutable)
</pre>
</div>

<p>
If you would like to access variables using a name other than "<tt>cvar</tt>", it can be
changed using the <tt>-globals</tt> option :
</p>

<div class="shell"><pre>
$ swig -python -globals myvar example.i
</pre></div>

<p>
Some care is in order when importing multiple SWIG modules.
If you use the "<tt>from &lt;file&gt; import *</tt>" style of
importing, you will get a name clash on the variable `<tt>cvar</tt>'
and you will only be able to access global variables from the last
module loaded. To prevent this, you might consider renaming
<tt>cvar</tt> or making it private to the module by giving it a name
that starts with a leading underscore. SWIG does not create <tt>cvar</tt>
if there are no global variables in a module.
</p>

<H3><a name="Python_nn17">36.3.4 Constants and enums</a></H3>


<p>
C/C++ constants are installed as Python objects containing the
appropriate value.  To create a constant, use <tt>#define</tt>, <tt>enum</tt>, or the
<tt>%constant</tt> directive.  For example:
</p>

<div class="code">
<pre>
#define PI 3.14159
#define VERSION "1.0"

enum Beverage { ALE, LAGER, STOUT, PILSNER };

%constant int FOO = 42;
%constant const char *path = "/usr/local";
</pre>
</div>

<p>
For enums, make sure that the definition of the enumeration actually appears in a header
file or in the wrapper file somehow---if you just stick an enum in a SWIG interface without
also telling the C compiler about it, the wrapper code won't compile.
</p>

<p>
Note:  declarations declared as <tt>const</tt> are wrapped as read-only variables and
will be accessed using the <tt>cvar</tt> object described in the previous section.  They
are not wrapped as constants.   For further discussion about this, see the <a href="SWIG.html#SWIG">SWIG Basics</a> chapter.
</p>

<p>
Constants are not guaranteed to remain constant in Python---the name
of the constant could be accidentally reassigned to refer to some
other object.  Unfortunately, there is no easy way for SWIG to
generate code that prevents this.  You will just have to be careful.
</p>

<H3><a name="Python_nn18">36.3.5 Pointers</a></H3>


<p>
C/C++ pointers are fully supported by SWIG.  Furthermore, SWIG has no
problem working with incomplete type information.  Here is a rather
simple interface:
</p>

<div class="code">
<pre>
%module example

FILE *fopen(const char *filename, const char *mode);
int fputs(const char *, FILE *);
int fclose(FILE *);
</pre>
</div>

<p>
When wrapped, you will be able to use the functions in a natural way from Python. For example:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; import example
&gt;&gt;&gt; f = example.fopen("junk", "w")
&gt;&gt;&gt; example.fputs("Hello World\n", f)
&gt;&gt;&gt; example.fclose(f)
</pre>
</div>

<p>
If this makes you uneasy, rest assured that there is no
deep magic involved.  Underneath the covers, pointers to C/C++ objects are
simply represented as opaque values using an especial python container object:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; print f
&lt;Swig Object of type 'FILE *' at 0xb7d6f470&gt;
</pre></div>

<p>
This pointer value can be freely passed around to different C functions that
expect to receive an object of type <tt>FILE *</tt>.  The only thing you can't do is 
dereference the pointer from Python. Of course, that isn't much of a concern in this example.
</p>

<p>
In older versions of SWIG (1.3.22 or older), pointers were represented
using a plain string object. If you have an old package that still
requires that representation, or you just feel nostalgic, you can
always retrieve it by casting the pointer object to a string:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; print str(f)
_c0671108_p_FILE
</pre></div>

<p>
Also, if you need to pass the raw pointer value to some external
python library, you can do it by casting the pointer object to an
integer:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; print int(f)
135833352
</pre></div>

<p>
However, the inverse operation is not possible, i.e., you can't build
a SWIG pointer object from a raw integer value.
</p>

<p>
Note also that the '0' or NULL pointer is always represented by
<tt>None</tt>, no matter what type swig is addressing. In the
previous example, you can call:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; example.fclose(None)
</pre>
</div>

<p>
and that will be equivalent to the following, but not really useful, C
code:
</p>

<div class="code">
<pre>
FILE *f = NULL;
fclose(f);
</pre>
</div>

<p>
As much as you might be inclined to modify a pointer value directly
from Python, don't.  The hexadecimal encoding is not necessarily the
same as the logical memory address of the underlying object.  Instead
it is the raw byte encoding of the pointer value.  The encoding will
vary depending on the native byte-ordering of the platform (i.e.,
big-endian vs. little-endian).  Similarly, don't try to manually cast
a pointer to a new type by simply replacing the type-string.  This may
not work like you expect, it is particularly dangerous when casting
C++ objects.  If you need to cast a pointer or change its value,
consider writing some helper functions instead.  For example:
</p>

<div class="code">
<pre>
%inline %{
/* C-style cast */
Bar *FooToBar(Foo *f) {
  return (Bar *) f;
}

/* C++-style cast */
Foo *BarToFoo(Bar *b) {
  return dynamic_cast&lt;Foo*&gt;(b);
}

Foo *IncrFoo(Foo *f, int i) {
    return f+i;
}
%}
</pre>
</div>

<p>
Also, if working with C++, you should always try
to use the new C++ style casts.  For example, in the above code, the
C-style cast may return a bogus result whereas as the C++-style cast will return
<tt>None</tt> if the conversion can't be performed.
</p>

<H3><a name="Python_nn19">36.3.6 Structures</a></H3>


<p>
If you wrap a C structure, it is wrapped by a Python class.  This provides
a very natural interface.  For example,
</p>

<div class="code"><pre>
struct Vector {
  double x, y, z;
};

</pre></div>

<p>
is used as follows:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; v = example.Vector()
&gt;&gt;&gt; v.x = 3.5
&gt;&gt;&gt; v.y = 7.2
&gt;&gt;&gt; print v.x, v.y, v.z
7.8 -4.5 0.0
&gt;&gt;&gt; 
</pre></div>

<p>
Similar access is provided for unions and the data members of C++ classes.
</p>

<p>
If you print out the value of <tt>v</tt> in the above example, you will see
something like this:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; print v
&lt;C Vector instance at _18e31408_p_Vector&gt;
</pre>
</div>

<p>
This object is actually a Python instance that has been wrapped around a pointer to the low-level
C structure.  This instance doesn't actually do anything--it just serves as a proxy.
The pointer to the C object can be found in the <tt>.this</tt>
attribute.  For example:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; print v.this
_18e31408_p_Vector
&gt;&gt;&gt;
</pre>
</div>

<p>
Further details about the Python proxy class are covered a little later.
</p>

<p>
<tt>const</tt> members of a structure are read-only. Data members
can also be forced to be read-only using the <tt>%immutable</tt> directive. For example:
</p>

<div class="code">
<pre>
struct Foo {
  ...
  %immutable;
  int x;        /* Read-only members */
  char *name;
  %mutable;
  ...
};
</pre>
</div>

<p>
When <tt>char *</tt> members of a structure are wrapped, the contents are assumed to be
dynamically allocated using <tt>malloc</tt> or <tt>new</tt> (depending on whether or not
SWIG is run with the -c++ option).   When the structure member is set, the old contents will be 
released and a new value created.   If this is not the behavior you want, you will have to use
a typemap (described later).
</p>

<p>
If a structure contains arrays, access to those arrays is managed through pointers.  For
example, consider this:
</p>

<div class="code">
<pre>
struct Bar {
    int  x[16];
};
</pre>
</div>

<p>
If accessed in Python, you will see behavior like this:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; b = example.Bar()
&gt;&gt;&gt; print b.x
_801861a4_p_int
&gt;&gt;&gt; 
</pre>
</div>

<p>
This pointer can be passed around to functions that expect to receive
an <tt>int *</tt> (just like C).   You can also set the value of an array member using
another pointer.  For example:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; c = example.Bar()
&gt;&gt;&gt; c.x = b.x             # Copy contents of b.x to c.x
</pre>
</div>

<p>
For array assignment, SWIG copies the entire contents of the array starting with the data pointed
to by <tt>b.x</tt>.   In this example, 16 integers would be copied.  Like C, SWIG makes
no assumptions about bounds checking---if you pass a bad pointer, you may get a segmentation
fault or access violation.
</p>

<p>
When a member of a structure is itself a structure, it is handled as a
pointer.  For example, suppose you have two structures like this:
</p>

<div class="code">
<pre>
struct Foo {
  int a;
};

struct Bar {
  Foo f;
};
</pre>
</div>

<p>
Now, suppose that you access the <tt>f</tt> attribute of <tt>Bar</tt> like this:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; b = Bar()
&gt;&gt;&gt; x = b.f
</pre>
</div>

<p>
In this case, <tt>x</tt> is a pointer that points to the <tt>Foo</tt> that is inside <tt>b</tt>.
This is the same value as generated by this C code:
</p>

<div class="code">
<pre>
Bar b;
Foo *x = &amp;b-&gt;f;       /* Points inside b */
</pre>
</div>

<p>
Because the pointer points inside the structure, you can modify the contents and 
everything works just like you would expect. For example:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; b = Bar()
&gt;&gt;&gt; b.f.a = 3               # Modify attribute of structure member
&gt;&gt;&gt; x = b.f                   
&gt;&gt;&gt; x.a = 3                 # Modifies the same structure
</pre>
</div>

<H3><a name="Python_nn20">36.3.7 C++ classes</a></H3>


<p>
C++ classes are wrapped by Python classes as well. For example, if you have this class,
</p>

<div class="code"><pre>
class List {
public:
  List();
  ~List();
  int  search(char *item);
  void insert(char *item);
  void remove(char *item);
  char *get(int n);
  int  length;
};
</pre></div>

<p>
you can use it in Python like this:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; l = example.List()
&gt;&gt;&gt; l.insert("Ale")
&gt;&gt;&gt; l.insert("Stout")
&gt;&gt;&gt; l.insert("Lager")
&gt;&gt;&gt; l.get(1)
'Stout'
&gt;&gt;&gt; print l.length
3
&gt;&gt;&gt;
</pre></div>

<p>
Class data members are accessed in the same manner as C structures.  
</p>

<p>
Static class members present a special problem for Python.  Prior to Python-2.2, 
Python classes had no support for static methods and no version of Python
supports static member variables in a manner that SWIG can utilize.  Therefore, 
SWIG generates wrappers that try to work around some of these issues.  To illustrate,
suppose you have a class like this:
</p>

<div class="code">
<pre>
class Spam {
public:
  static void foo();
  static int bar;
};
</pre>
</div>

<p>
In Python, the static member can be access in three different ways:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; example.Spam_foo()    # Spam::foo()
&gt;&gt;&gt; s = example.Spam()
&gt;&gt;&gt; s.foo()               # Spam::foo() via an instance
&gt;&gt;&gt; example.Spam.foo()    # Spam::foo(). Python-2.2 only
</pre>
</div>

<p>
The first two methods of access are supported in all versions of Python.  The
last technique is only available in Python-2.2 and later versions.
</p>

<p>
Static member variables are currently accessed as global variables.  This means,
they are accessed through <tt>cvar</tt> like this:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; print example.cvar.Spam_bar
7
</pre>
</div>

<H3><a name="Python_nn21">36.3.8 C++ inheritance</a></H3>


<p>
SWIG is fully aware of issues related to C++ inheritance.  Therefore, if you have
classes like this
</p>

<div class="code">
<pre>
class Foo {
...
};

class Bar : public Foo {
...
};
</pre>
</div>

<p>
those classes are wrapped into a hierarchy of Python classes that reflect the same inheritance
structure.   All of the usual Python utility functions work normally:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; b = Bar()
&gt;&gt;&gt; instance(b, Foo)
1
&gt;&gt;&gt; issubclass(Bar, Foo)
1
&gt;&gt;&gt; issubclass(Foo, Bar)
0
</pre>
</div>

<p>
Furthermore, if you have functions like this
</p>

<div class="code">
<pre>
void spam(Foo *f);
</pre>
</div>

<p>
then the function <tt>spam()</tt> accepts <tt>Foo *</tt> or a pointer to any class derived from <tt>Foo</tt>.
</p>

<p>
It is safe to use multiple inheritance with SWIG.
</p>

<H3><a name="Python_nn22">36.3.9 Pointers, references, values, and arrays</a></H3>


<p>
In C++, there are many different ways a function might receive
and manipulate objects.  For example:
</p>

<div class="code">
<pre>
void spam1(Foo *x);      // Pass by pointer
void spam2(Foo &amp;x);      // Pass by reference
void spam3(const Foo &amp;x);// Pass by const reference
void spam4(Foo x);       // Pass by value
void spam5(Foo x[]);     // Array of objects
</pre>
</div>

<p>
In Python, there is no detailed distinction like this--specifically,
there are only "objects".  There are no pointers, references, arrays,
and so forth.  Because of this, SWIG unifies all of these types
together in the wrapper code.  For instance, if you actually had the
above functions, it is perfectly legal to do this:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; f = Foo()           # Create a Foo
&gt;&gt;&gt; spam1(f)            # Ok. Pointer
&gt;&gt;&gt; spam2(f)            # Ok. Reference
&gt;&gt;&gt; spam3(f)            # Ok. Const reference
&gt;&gt;&gt; spam4(f)            # Ok. Value.
&gt;&gt;&gt; spam5(f)            # Ok. Array (1 element)
</pre>
</div>

<p>
Similar behavior occurs for return values.  For example, if you had
functions like this,
</p>

<div class="code">
<pre>
Foo *spam6();
Foo &amp;spam7();
Foo  spam8();
const Foo &amp;spam9();
</pre>
</div>

<p>
then all three functions will return a pointer to some <tt>Foo</tt> object.
Since the third function (spam8) returns a value, newly allocated memory is used 
to hold the result and a pointer is returned (Python will release this memory 
when the return value is garbage collected). The fourth case (spam9)
which returns a const reference, in most of the cases will be 
treated as a returning value, and it will follow the same
allocation/deallocation process.
</p>

<H3><a name="Python_nn23">36.3.10 C++ overloaded functions</a></H3>


<p>
C++ overloaded functions, methods, and constructors are mostly supported by SWIG.  For example,
if you have two functions like this:
</p>

<div class="code">
<pre>
void foo(int);
void foo(char *c);
</pre>
</div>

<p>
You can use them in Python in a straightforward manner:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; foo(3)           # foo(int)
&gt;&gt;&gt; foo("Hello")     # foo(char *c)
</pre>
</div>

<p>
Similarly, if you have a class like this,
</p>

<div class="code">
<pre>
class Foo {
public:
    Foo();
    Foo(const Foo &amp;);
    ...
};
</pre>
</div>

<p>
you can write Python code like this:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; f = Foo()          # Create a Foo
&gt;&gt;&gt; g = Foo(f)         # Copy f
</pre>
</div>

<p>
Overloading support is not quite as flexible as in C++. Sometimes there are methods that SWIG
can't disambiguate. For example:
</p>

<div class="code">
<pre>
void spam(int);
void spam(short);
</pre>
</div>

<p>
or
</p>

<div class="code">
<pre>
void foo(Bar *b);
void foo(Bar &amp;b);
</pre>
</div>

<p>
If declarations such as these appear, you will get a warning message like this:
</p>

<div class="shell">
<pre>
example.i:12: Warning 509: Overloaded method spam(short) effectively ignored,
example.i:11: Warning 509: as it is shadowed by spam(int).
</pre>
</div>

<p>
To fix this, you either need to ignore or rename one of the methods.  For example:
</p>

<div class="code">
<pre>
%rename(spam_short) spam(short);
...
void spam(int);    
void spam(short);   // Accessed as spam_short
</pre>
</div>

<p>
or
</p>

<div class="code">
<pre>
%ignore spam(short);
...
void spam(int);    
void spam(short);   // Ignored
</pre>
</div>

<p>
SWIG resolves overloaded functions and methods using a disambiguation scheme that ranks and sorts
declarations according to a set of type-precedence rules.    The order in which declarations appear
in the input does not matter except in situations where ambiguity arises--in this case, the
first declaration takes precedence.
</p>

<p>
Please refer to the "SWIG and C++" chapter for more information about overloading. 
</p>

<H3><a name="Python_nn24">36.3.11 C++ operators</a></H3>


<p>
Certain C++ overloaded operators can be handled automatically by SWIG.  For example,
consider a class like this:
</p>

<div class="code">
<pre>
class Complex {
private:
  double rpart, ipart;
public:
  Complex(double r = 0, double i = 0) : rpart(r), ipart(i) { }
  Complex(const Complex &amp;c) : rpart(c.rpart), ipart(c.ipart) { }
  Complex &amp;operator=(const Complex &amp;c);

  Complex operator+=(const Complex &amp;c) const;
  Complex operator+(const Complex &amp;c) const;
  Complex operator-(const Complex &amp;c) const;
  Complex operator*(const Complex &amp;c) const;
  Complex operator-() const;
  
  double re() const { return rpart; }
  double im() const { return ipart; }
};
</pre>
</div>

<p>
When wrapped, it works like you expect:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; c = Complex(3, 4)
&gt;&gt;&gt; d = Complex(7, 8)
&gt;&gt;&gt; e = c + d
&gt;&gt;&gt; e.re()
10.0
&gt;&gt;&gt; e.im()
12.0
&gt;&gt;&gt; c += d
&gt;&gt;&gt; c.re()
10.0
&gt;&gt;&gt; c.im()
12.0

</pre>
</div>

<p>
One restriction with operator overloading support is that SWIG is not
able to fully handle operators that aren't defined as part of the class.
For example, if you had code like this
</p>

<div class="code">
<pre>
class Complex {
...
friend Complex operator+(double, const Complex &amp;c);
...
};
</pre>
</div>

<p>
then SWIG ignores it and issues a warning.   You can still wrap the operator,
but you may have to encapsulate it in a special function.  For example:
</p>

<div class="code">
<pre>
%rename(Complex_add_dc) operator+(double, const Complex &amp;);
</pre>
</div>

<p>
There are ways to make this operator appear as part of the class using the <tt>%extend</tt> directive.
Keep reading.
</p>

<p>
Also, be aware that certain operators don't map cleanly to Python.  For instance,
overloaded assignment operators don't map to Python semantics and will be ignored.
</p>

<H3><a name="Python_nn25">36.3.12 C++ namespaces</a></H3>


<p>
SWIG is aware of C++ namespaces, but namespace names do not appear in
the module nor do namespaces result in a module that is broken up into
submodules or packages.  For example, if you have a file like this,
</p>

<div class="code">
<pre>
%module example

namespace foo {
  int fact(int n);
  struct Vector {
    double x, y, z;
  };
};
</pre>
</div>

<p>
it works in Python as follows:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; import example
&gt;&gt;&gt; example.fact(3)
6
&gt;&gt;&gt; v = example.Vector()
&gt;&gt;&gt; v.x = 3.4
&gt;&gt;&gt; print v.y
0.0
&gt;&gt;&gt;
</pre>
</div>

<p>
If your program has more than one namespace, name conflicts (if any) can be resolved using <tt>%rename</tt>
For example:
</p>

<div class="code">
<pre>
%rename(Bar_spam) Bar::spam;

namespace Foo {
    int spam();
}

namespace Bar {
    int spam();
}
</pre>
</div>

<p>
If you have more than one namespace and your want to keep their
symbols separate, consider wrapping them as separate SWIG modules.
For example, make the module name the same as the namespace and create
extension modules for each namespace separately.  If your program
utilizes thousands of small deeply nested namespaces each with
identical symbol names, well, then you get what you deserve.
</p>

<H3><a name="Python_nn26">36.3.13 C++ templates</a></H3>


<p>
C++ templates don't present a huge problem for SWIG.  However, in order
to create wrappers, you have to tell SWIG to create wrappers for a particular
template instantiation.  To do this, you use the <tt>%template</tt> directive.
For example:
</p>

<div class="code">
<pre>
%module example
%{
#include "pair.h"
%}

template&lt;class T1, class T2&gt;
struct pair {
  typedef T1 first_type;
  typedef T2 second_type;
  T1 first;
  T2 second;
  pair();
  pair(const T1&amp;, const T2&amp;);
 ~pair();
};

%template(pairii) pair&lt;int, int&gt;;
</pre>
</div>

<p>
In Python:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; import example
&gt;&gt;&gt; p = example.pairii(3, 4)
&gt;&gt;&gt; p.first
3
&gt;&gt;&gt; p.second
4
</pre>
</div>

<p>
Obviously, there is more to template wrapping than shown in this example.
More details can be found in the <a href="SWIGPlus.html#SWIGPlus">SWIG and C++</a> chapter.  
Some more complicated
examples will appear later.
</p>

<H3><a name="Python_nn27">36.3.14 C++ Smart Pointers</a></H3>


<H4><a name="Python_smart_pointers_shared_ptr">36.3.14.1 The shared_ptr Smart Pointer</a></H4>


<p>
The C++11 standard provides <tt>std::shared_ptr</tt> which was derived from the Boost
implementation, <tt>boost::shared_ptr</tt>.
Both of these are available for Python in the SWIG library and usage is outlined
in the <a href="Library.html#Library_std_shared_ptr">shared_ptr smart pointer</a> library section.
</p>


<H4><a name="Python_smart_pointers_generic">36.3.14.2 Generic Smart Pointers</a></H4>


<p>
In certain C++ programs, it is common to use classes that have been wrapped by
so-called "smart pointers."   Generally, this involves the use of a template class
that implements <tt>operator-&gt;()</tt> like this:
</p>

<div class="code">
<pre>
template&lt;class T&gt; class SmartPtr {
  ...
  T *operator-&gt;();
  ...
}
</pre>
</div>

<p>
Then, if you have a class like this,
</p>

<div class="code">
<pre>
class Foo {
public:
  int x;
  int bar();
};
</pre>
</div>

<p>
A smart pointer would be used in C++ as follows:
</p>

<div class="code">
<pre>
SmartPtr&lt;Foo&gt; p = CreateFoo();   // Created somehow (not shown)
...
p-&gt;x = 3;                        // Foo::x
int y = p-&gt;bar();                // Foo::bar
</pre>
</div>

<p>
To wrap this in Python, simply tell SWIG about the <tt>SmartPtr</tt> class and the low-level
<tt>Foo</tt> object.  Make sure you instantiate <tt>SmartPtr</tt> using <tt>%template</tt> if necessary.
For example:
</p>

<div class="code">
<pre>
%module example
...
%template(SmartPtrFoo) SmartPtr&lt;Foo&gt;;
...
</pre>
</div>

<p>
Now, in Python, everything should just "work":
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; p = example.CreateFoo()          # Create a smart-pointer somehow
&gt;&gt;&gt; p.x = 3                          # Foo::x
&gt;&gt;&gt; p.bar()                          # Foo::bar
</pre>
</div>

<p>
If you ever need to access the underlying pointer returned by <tt>operator-&gt;()</tt> itself,
simply use the <tt>__deref__()</tt> method.  For example:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; f = p.__deref__()     # Returns underlying Foo *
</pre>
</div>

<H3><a name="Python_nn27a">36.3.15 C++ reference counted objects</a></H3>


<p>
The <a href="SWIGPlus.html#SWIGPlus_ref_unref">C++ reference counted objects</a> section contains
Python examples of memory management using referencing counting.
</p>


<H2><a name="Python_nn28">36.4 Further details on the Python class interface</a></H2>


<p>
In the previous section, a high-level view of Python wrapping was
presented.  A key component of this wrapping is that structures and
classes are wrapped by Python proxy classes.  This provides a very
natural Python interface and allows SWIG to support a number of
advanced features such as operator overloading.   However, a number
of low-level details were omitted.  This section provides a brief overview
of how the proxy classes work.
</p>

<p><b>New in SWIG version 2.0.4:</b>
The use of Python proxy classes has performance implications that may be
unacceptable for a high-performance library.  The new <tt>-builtin</tt>
option instructs SWIG to forego the use of proxy classes, and instead
create wrapped types as new built-in Python types.  When this option is used,
the following section ("Proxy classes") does not apply.  Details on the use of
the <tt>-builtin</tt> option are in the <a href="#Python_builtin_types">Built-in Types</a>
section.
</p>

<H3><a name="Python_nn29">36.4.1 Proxy classes</a></H3>


<p>
In the <a href="SWIG.html#SWIG">"SWIG basics"</a> and <a href="SWIGPlus.html#SWIGPlus">"SWIG and C++"</a> chapters,
details of low-level structure and class wrapping are described.  To summarize those chapters, if you
have a class like this
</p>

<div class="code">
<pre>
class Foo {
public:
    int x;
    int spam(int);
    ...
</pre>
</div>

<p>
then SWIG transforms it into a set of low-level procedural wrappers. For example:
</p>

<div class="code">
<pre>
Foo *new_Foo() {
    return new Foo();
}
void delete_Foo(Foo *f) {
    delete f;
}
int Foo_x_get(Foo *f) {
    return f-&gt;x;
}
void Foo_x_set(Foo *f, int value) {
    f-&gt;x = value;
}
int Foo_spam(Foo *f, int arg1) {
    return f-&gt;spam(arg1);
}
</pre>
</div>

<p>
These wrappers can be found in the low-level extension module (e.g., <tt>_example</tt>).
</p>

<p>
Using these wrappers, SWIG generates a high-level Python proxy class (also known as a shadow class) like this (shown 
for Python 2.2):
</p>

<div class="targetlang">
<pre>
import _example

class Foo(object):
    def __init__(self):
        self.this = _example.new_Foo()
        self.thisown = 1
    def __del__(self):
        if self.thisown:
            _example.delete_Foo(self.this)
    def spam(self, arg1):
        return _example.Foo_spam(self.this, arg1)
    x = property(_example.Foo_x_get, _example.Foo_x_set)
</pre>
</div>

<p>
This class merely holds a pointer to the underlying C++ object (<tt>.this</tt>) and dispatches methods and 
member variable access to that object using the low-level accessor functions.   From a user's point of
view, it makes the class work normally:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; f = example.Foo()
&gt;&gt;&gt; f.x = 3
&gt;&gt;&gt; y = f.spam(5)
</pre>
</div>

<p>
The fact that the class has been wrapped by a real Python class offers certain advantages.  For instance,
you can attach new Python methods to the class and you can even inherit from it (something not supported
by Python built-in types until Python 2.2).
</p>

<H3><a name="Python_builtin_types">36.4.2 Built-in Types</a></H3>


<p>
The <tt>-builtin</tt> option provides a significant performance improvement
in the wrapped code.  To understand the difference between proxy classes
and built-in types, let's take a look at what a wrapped object looks like
under both circumstances.
</p>

<p>When proxy classes are used, each wrapped object in python is an instance
of a pure python class.  As a reminder, here is what the <tt>__init__</tt> method looks
like in a proxy class:
</p>

<div class="targetlang">
<pre>
class Foo(object):
    def __init__(self):
        self.this = _example.new_Foo()
        self.thisown = 1
</pre>
</div>

<p>When a <tt>Foo</tt> instance is created, the call to <tt>_example.new_Foo()</tt>
creates a new C++ <tt>Foo</tt> instance; wraps that C++ instance inside an instance of 
a python built-in type called <tt>SwigPyObject</tt>; and stores the <tt>SwigPyObject</tt>
instance in the 'this' field of the python Foo object.  Did you get all that?  So, the
python <tt>Foo</tt> object is composed of three parts:</p>

<ul>
<li> The python <tt>Foo</tt> instance, which contains...</li>
<li> ... an instance of <tt>struct SwigPyObject</tt>, which contains...</li>
<li> ... a C++ <tt>Foo</tt> instance</li>
</ul>

<p>When <tt>-builtin</tt> is used, the pure python layer is stripped off.  Each
wrapped class is turned into a new python built-in type which inherits from
<tt>SwigPyObject</tt>, and <tt>SwigPyObject</tt> instances are returned directly
from the wrapped methods.  For more information about python built-in extensions,
please refer to the python documentation:</p>

<p><a href="http://docs.python.org/extending/newtypes.html">http://docs.python.org/extending/newtypes.html</a></p>

<H4><a name="Python_builtin_limitations">36.4.2.1 Limitations</a></H4>


<p>Use of the <tt>-builtin</tt> option implies a couple of limitations:
<ul>
  <li><p>python version support:</p>
  <ul>
    <li>Versions 2.5 and up are fully supported</li>
    <li>Versions 2.3 and 2.4 are mostly supported; there are problems with director classes and/or sub-classing a wrapped type in python.</li>
    <li>Versions older than 2.3 are not supported.</li>
  </ul>
  </li>
  <li><p>Some legacy syntax is no longer supported; in particular:</p>
  <ul>
    <li>The functional interface is no longer exposed.  For example, you may no longer call <tt>Whizzo.new_CrunchyFrog()</tt>.  Instead, you must use <tt>Whizzo.CrunchyFrog()</tt>.</li>
    <li>Static member variables are no longer accessed through the 'cvar' field (e.g., <tt>Dances.cvar.FishSlap</tt>).
    They are instead accessed in the idiomatic way (<tt>Dances.FishSlap</tt>).</li>
  </ul>
  </li>
  <li><p>Wrapped types may not be raised as python exceptions.  Here's why: the python internals expect that all sub-classes of Exception will have this struct layout:</p>

<div class="code">
<pre>
typedef struct {
    PyObject_HEAD
    PyObject *dict;
    PyObject *args;
    PyObject *message;
} PyBaseExceptionObject;
</pre>
</div>

<p>But swig-generated wrappers expect that all swig-wrapped classes will have this struct layout:</p>

<div class="code">
<pre>
typedef struct {
    PyObject_HEAD
    void *ptr;
    swig_type_info *ty;
    int own;
    PyObject *next;
    PyObject *dict;
} SwigPyObject;
</pre>
</div>

<p>There are workarounds for this.  For example, if you wrap this class:

<div class="code">
<pre>
class MyException {
public:
    MyException (const char *msg_);
    ~MyException ();

    const char *what () const;

private:
    char *msg;
};
</pre>
</div>

<p>... you can define this python class, which may be raised as an exception:</p>

<div class="targetlang">
<pre>
class MyPyException(Exception):
    def __init__(self, msg, *args):
        Exception.__init__(self, *args)
        self.myexc = MyException(msg)
    def what(self):
        return self.myexc.what()
</pre>
</div>
</li>
<li><p>Reverse binary operators (e.g., <tt>__radd__</tt>) are not supported.</p>
<p>To illustrate this point, if you have a wrapped class called <tt>MyString</tt>,
and you want to use instances of <tt>MyString</tt> interchangeably with native python
strings, you can define an <tt>'operator+ (const char*)'</tt> method :</p>

<div class="code">
<pre>
class MyString {
public:
    MyString (const char *init);
    MyString operator+ (const char *other) const;
    ...
};
</pre>
</div>

<p>
SWIG will automatically create an operator overload in python that will allow this:
</p>

<div class="targetlang">
<pre>
from MyModule import MyString

mystr = MyString("No one expects")
episode = mystr + " the Spanish Inquisition"
</pre>
</div>

<p>
This works because the first operand (<tt>mystr</tt>) defines a way
to add a native string to itself.  However, the following will <b>not</b> work:
</p>

<div class="targetlang">
<pre>
from MyModule import MyString

mystr = MyString("Parrot")
episode = "Dead " + mystr
</pre>
</div>

<p>
The above code fails, because the first operand -- a native python string --
doesn't know how to add an instance of <tt>MyString</tt> to itself.
</p>
</li>

<li><p>If you have multiple SWIG modules that share type information (<a href="Modules.html#Modules_nn2">more info</a>),
the <tt>-builtin</tt> option requires a bit of extra discipline to ensure that base classes are initialized before derived classes.  Specifically:</p>
<ul>
<li><p>There must be an unambiguous dependency graph for the modules.</p></li>
<li><p>Module dependencies must be explicitly stated with <tt>%import</tt> statements in the SWIG interface file.</p>
</ul>

<p>As an example, suppose module <tt>A</tt> has this interface in <tt>A.i</tt> :</p>

<div class="code"><pre>
%module "A";

class Base {
...
};
</pre></div>

<p>If you want to wrap another module containing a class that inherits from <tt>A</tt>, this is how it would look :</p>

<div class="code"><pre>
%module "B";

%import "A.i"

class Derived : public Base {
...
};
</pre></div>

<p>The <tt>import "A.i"</tt> statement is required, because module <tt>B</tt> depends on module <tt>A</tt>.</p>

<p>As long as you obey these requirements, your python code may import the modules in any order :</p>

<div class="targetlang"><pre>
import B
import A

assert(issubclass(B.Derived, A.Base))
</pre></div>
</li>
</ul>

<H4><a name="Python_builtin_overloads">36.4.2.2 Operator overloads and slots -- use them!</a></H4>


<p>The entire justification for the <tt>-builtin</tt> option is improved
performance.  To that end, the best way to squeeze maximum performance out
of your wrappers is to <b>use operator overloads.</b>
Named method dispatch is slow in python, even when compared to other scripting languages.
However, python built-in types have a large number of "slots",
analogous to C++ operator overloads, which allow you to short-circuit named method dispatch
for certain common operations.
</p>

<p>By default, SWIG will translate most C++ arithmetic operator overloads into python
slot entries.  For example, suppose you have this class:

<div class="code">
<pre>
class Twit {
public:
    Twit operator+ (const Twit&amp; twit) const;

    // Forward to operator+
    Twit add (const Twit&amp; twit) const
    { return *this + twit; }
};
</pre>
</div>

<p>SWIG will automatically register <tt>operator+</tt> as a python slot operator for addition.  You may write python code like this:</p>

<div class="targetlang">
<pre>
from MyModule import Twit

nigel = Twit()
emily = Twit()
percival = nigel + emily
percival = nigel.add(emily)
</pre>
</div>

<p>The last two lines of the python code are equivalent,
but <b>the line that uses the '+' operator is much faster</b>.
</p>

<p>In-place operators (e.g., <tt>operator+=</tt>) and comparison operators
(<tt>operator==, operator&lt;</tt>, etc.) are also converted to python
slot operators.  For a complete list of C++ operators that are
automatically converted to python slot operators, refer to the file
<tt>python/pyopers.swig</tt> in the SWIG library.
</p>


<p>
Read about all of the available python slots here:
<a href="http://docs.python.org/c-api/typeobj.html">http://docs.python.org/c-api/typeobj.html</a></p>

<p>
There are two ways to define a python slot function: dispatch to a
statically defined function; or dispatch to a method defined on the
operand.
</p>

<p>
To dispatch to a statically defined function, use %feature("python:&lt;slot&gt;"),
where &lt;slot&gt; is the name of a field in a <tt>PyTypeObject, PyNumberMethods,
PyMappingMethods, PySequenceMethods</tt> or <tt>PyBufferProcs</tt>.
You may override (almost) all of these slots.
</p>


<p>
Let's consider an example setting the <tt>tp_hash</tt> slot for the <tt>MyClass</tt> type.
This is akin to providing a <tt>__hash__</tt> method (for non-builtin types) to make a type hashable.
The hashable type can then for example be added to a Python <tt>dict</tt>.
</p>

<div class="code">
<pre>
%feature("python:tp_hash") MyClass "myHashFunc";

class MyClass {
public:
  long field1;
  long field2;
  ...
};

%{
#if PY_VERSION_HEX &gt;= 0x03020000
  static Py_hash_t myHashFunc(PyObject *pyobj)
#else
  static long myHashFunc(PyObject *pyobj)
#endif
  {
    MyClass *cobj;
    // Convert pyobj to cobj
    return (cobj-&gt;field1 * (cobj-&gt;field2 &lt;&lt; 7));
  }
%}
</pre>
</div>

<p>
If you examine the generated code, the supplied hash function will now be 
the function callback in the tp_hash slot for the builtin type for <tt>MyClass</tt>:
</p>

<div class="code">
<pre>
static PyHeapTypeObject SwigPyBuiltin__MyClass_type = {
    ...
    (hashfunc) myHashFunc,       /* tp_hash */
    ...
</pre>
</div>

<p>
NOTE: It is the responsibility of the programmer (that's you!) to ensure
that a statically defined slot function has the correct signature, the <tt>hashfunc</tt>
typedef in this case.
</p>

<p>
If, instead, you want to dispatch to an instance method, you can
use %feature("python:slot").  For example:
</p>

<div class="code">
<pre>
%feature("python:slot", "tp_hash", functype="hashfunc") MyClass::myHashFunc;

#if PY_VERSION_HEX &lt; 0x03020000
  #define Py_hash_t long
#endif

class MyClass {
  public:
    Py_hash_t myHashFunc() const;
    ...
};
</pre>
</div>

<p>
NOTE: Some python slots use a method signature which does not
match the signature of SWIG-wrapped methods.  For those slots,
SWIG will automatically generate a "closure" function to re-marshal
the arguments before dispatching to the wrapped method.  Setting
the "functype" attribute of the feature enables SWIG to generate
the chosen closure function.
</p>

<p>
There is further information on <tt>%feature("python:slot")</tt>
in the file <tt>python/pyopers.swig</tt> in the SWIG library.
</p>


<H3><a name="Python_nn30">36.4.3 Memory management</a></H3>


<p>NOTE: Although this section refers to proxy objects, everything here also applies
when the <tt>-builtin</tt> option is used.</p>

<p>
Associated with proxy object, is an ownership flag <tt>.thisown</tt>   The value of this
flag determines who is responsible for deleting the underlying C++ object.   If set to 1,
the Python interpreter will destroy the C++ object when the proxy class is 
garbage collected.   If set to 0 (or if the attribute is missing), then the destruction
of the proxy class has no effect on the C++ object.
</p>

<p>
When an object is created by a constructor or returned by value, Python automatically takes
ownership of the result.  For example:
</p>

<div class="code">
<pre>
class Foo {
public:
    Foo();
    Foo bar();
};
</pre>
</div>

<p>
In Python:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.thisown
1
&gt;&gt;&gt; g = f.bar()
&gt;&gt;&gt; g.thisown
1
</pre>
</div>

<p>
On the other hand, when pointers are returned to Python, there is often no way to know where
they came from.  Therefore, the ownership is set to zero.  For example:
</p>

<div class="code">
<pre>
class Foo {
public:
    ...
    Foo *spam();
    ...
};
</pre>
</div>

<br>

<div class="targetlang">
<pre>
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; s = f.spam()
&gt;&gt;&gt; print s.thisown
0
&gt;&gt;&gt;
</pre>
</div>

<p>
This behavior is especially important for classes that act as
containers.  For example, if a method returns a pointer to an object
that is contained inside another object, you definitely don't want
Python to assume ownership and destroy it!
</p>

<p>
A good way to indicate that ownership should be set for a returned pointer
is to use the <a href="Library.html#Library_nn11">%newobject directive</a>.
</p>

<p>
Related to containers, ownership issues can arise whenever an object is assigned to a member
or global variable.  For example, consider this interface:
</p>

<div class="code">
<pre>
%module example

struct Foo {
    int  value;
    Foo  *next;
};

Foo *head = 0;
</pre>
</div>

<p>
When wrapped in Python, careful observation will reveal that ownership changes whenever an object
is assigned to a global variable.  For example:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; f = example.Foo()
&gt;&gt;&gt; f.thisown
1
&gt;&gt;&gt; example.cvar.head = f           
&gt;&gt;&gt; f.thisown
0
&gt;&gt;&gt;
</pre>
</div>

<p>
In this case, C is now holding a reference to the object---you probably don't want Python to destroy it.
Similarly, this occurs for members.  For example:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; f = example.Foo()
&gt;&gt;&gt; g = example.Foo()
&gt;&gt;&gt; f.thisown
1
&gt;&gt;&gt; g.thisown
1
&gt;&gt;&gt; f.next = g
&gt;&gt;&gt; g.thisown
0
&gt;&gt;&gt;
</pre>
</div>

<p>
For the most part, memory management issues remain hidden.  However,
there are occasionally situations where you might have to manually
change the ownership of an object.  For instance, consider code like this:
</p>

<div class="code">
<pre>
class Node {
  Object *value;
public:
  void set_value(Object *v) { value = v; }
  ...
};
</pre>
</div>

<p>
Now, consider the following Python code:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; v = Object()           # Create an object
&gt;&gt;&gt; n = Node()             # Create a node
&gt;&gt;&gt; n.set_value(v)         # Set value
&gt;&gt;&gt; v.thisown
1
&gt;&gt;&gt; del v
</pre>
</div>

<p>
In this case, the object <tt>n</tt> is holding a reference to
<tt>v</tt> internally.  However, SWIG has no way to know that this
has occurred.  Therefore, Python still thinks that it has ownership of the
object.  Should the proxy object be destroyed, then the C++ destructor
will be invoked and <tt>n</tt> will be holding a stale-pointer.  If
you're lucky, you will only get a segmentation fault.
</p>

<p>
To work around this, it is always possible to flip the ownership flag. For example,
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; v.thisown = 0
</pre>
</div>

<p>
It is also possible to deal with situations like this using
typemaps--an advanced topic discussed later.
</p>

<H3><a name="Python_nn31">36.4.4 Python 2.2 and classic classes</a></H3>


<p>
SWIG makes every attempt to preserve backwards compatibility with
older versions of Python to the extent that it is possible.  However,
in Python-2.2, an entirely new type of class system was introduced.
This new-style class system offers many enhancements including static
member functions, properties (managed attributes), and class methods.
Details about all of these changes can be found on <a
href="https://www.python.org">www.python.org</a> and is not repeated here.
</p>

<p>
To address differences between Python versions, SWIG currently emits
dual-mode proxy class wrappers.  In Python-2.2 and newer releases,
these wrappers encapsulate C++ objects in new-style classes that take
advantage of new features (static methods and properties).  However,
if these very same wrappers are imported into an older version of Python, 
old-style classes are used instead.
</p>

<p>
This dual-nature of the wrapper code means that you can create extension
modules with SWIG and those modules will work with all versions of Python
ranging from Python-2.0 to the very latest release.  Moreover, the wrappers take
advantage of Python-2.2 features when available.
</p>

<p>
For the most part, the interface presented to users is the same regardless
of what version of Python is used.  The only incompatibility lies in the handling
of static member functions.  In Python-2.2, they can be accessed via the
class itself.  In Python-2.1 and earlier, they have to be accessed as a global
function or through an instance (see the earlier section).
</p>

<H2><a name="Python_directors">36.5 Cross language polymorphism</a></H2>


<p>
Proxy classes provide a more natural, object-oriented way to access
extension classes. As described above, each proxy instance has an
associated C++ instance, and method calls to the proxy are passed to the
C++ instance transparently via C wrapper functions.
</p>

<p>
This arrangement is asymmetric in the sense that no corresponding
mechanism exists to pass method calls down the inheritance chain from
C++ to Python. In particular, if a C++ class has been extended in Python
(by extending the proxy class), these extensions will not be visible
from C++ code. Virtual method calls from C++ are thus not able access
the lowest implementation in the inheritance chain.
</p>

<p>
Changes have been made to SWIG 1.3.18 to address this problem and
make the relationship between C++ classes and proxy classes more
symmetric. To achieve this goal, new classes called directors are
introduced at the bottom of the C++ inheritance chain. The job of the
directors is to route method calls correctly, either to C++
implementations higher in the inheritance chain or to Python
implementations lower in the inheritance chain. The upshot is that C++
classes can be extended in Python and from C++ these extensions look
exactly like native C++ classes. Neither C++ code nor Python code needs
to know where a particular method is implemented: the combination of
proxy classes, director classes, and C wrapper functions takes care of
all the cross-language method routing transparently.
</p>

<H3><a name="Python_nn33">36.5.1 Enabling directors</a></H3>


<p>
The director feature is disabled by default.  To use directors you
must make two changes to the interface file.  First, add the "directors"
option to the %module directive, like this:
</p>

<div class="code">
<pre>
%module(directors="1") modulename
</pre>
</div>

<p>
Without this option no director code will be generated.  Second, you
must use the %feature("director") directive to tell SWIG which classes 
and methods should get directors.  The %feature directive can be applied 
globally, to specific classes, and to specific methods, like this:
</p>

<div class="code">
<pre>
// generate directors for all classes that have virtual methods
%feature("director");         

// generate directors for all virtual methods in class Foo
%feature("director") Foo;      
</pre>
</div>

<p>
You can use the %feature("nodirector") directive to turn off
directors for specific classes or methods.  So for example,
</p>

<div class="code">
<pre>
%feature("director") Foo;
%feature("nodirector") Foo::bar;
</pre>
</div>

<p>
will generate directors for all virtual methods of class Foo except
bar().  
</p>

<p>
Directors can also be generated implicitly through inheritance. 
In the following, class Bar will get a director class that handles
the methods one() and two() (but not three()):
</p>

<div class="code">
<pre>
%feature("director") Foo;
class Foo {
public:
    Foo(int foo);
    virtual ~Foo();
    virtual void one();
    virtual void two();
};

class Bar: public Foo {
public:
    virtual void three();
};
</pre>
</div>

<p>
then at the python side you can define
</p>

<div class="targetlang">
<pre>
import mymodule

class MyFoo(mymodule.Foo):
    def __init__(self, foo):
        mymodule.Foo.__init__(self, foo)
#       super().__init__(foo) # Alternative construction for Python3

    def one(self):
        print "one from python"
</pre>
</div>


<H3><a name="Python_nn34">36.5.2 Director classes</a></H3>


 


<p>
For each class that has directors enabled, SWIG generates a new class
that derives from both the class in question and a special
<tt>Swig::Director</tt> class. These new classes, referred to as director
classes, can be loosely thought of as the C++ equivalent of the Python
proxy classes. The director classes store a pointer to their underlying
Python object and handle various issues related to object ownership.
Indeed, this is quite similar to the "this" and "thisown" members of the
Python proxy classes.
</p>

<p>
For simplicity let's ignore the <tt>Swig::Director</tt> class and refer to the
original C++ class as the director's base class. By default, a director
class extends all virtual methods in the inheritance chain of its base
class (see the preceding section for how to modify this behavior).
Thus all virtual method calls, whether they originate in C++ or in
Python via proxy classes, eventually end up in at the implementation in
the director class. The job of the director methods is to route these
method calls to the appropriate place in the inheritance chain. By
"appropriate place" we mean the method that would have been called if
the C++ base class and its extensions in Python were seamlessly
integrated. That seamless integration is exactly what the director
classes provide, transparently skipping over all the messy extension API
glue that binds the two languages together.
</p>

<p>
In reality, the "appropriate place" is one of only two possibilities:
C++ or Python. Once this decision is made, the rest is fairly easy. If
the correct implementation is in C++, then the lowest implementation of
the method in the C++ inheritance chain is called explicitly. If the
correct implementation is in Python, the Python API is used to call the
method of the underlying Python object (after which the usual virtual
method resolution in Python automatically finds the right
implementation).
</p>

<p>
Now how does the director decide which language should handle the method call?
The basic rule is to handle the method in Python, unless there's a good
reason not to. The reason for this is simple: Python has the most
"extended" implementation of the method. This assertion is guaranteed,
since at a minimum the Python proxy class implements the method. If the
method in question has been extended by a class derived from the proxy
class, that extended implementation will execute exactly as it should.
If not, the proxy class will route the method call into a C wrapper
function, expecting that the method will be resolved in C++. The wrapper
will call the virtual method of the C++ instance, and since the director
extends this the call will end up right back in the director method. Now
comes the "good reason not to" part. If the director method were to blindly
call the Python method again, it would get stuck in an infinite loop. We avoid this
situation by adding special code to the C wrapper function that tells
the director method to not do this. The C wrapper function compares the
pointer to the Python object that called the wrapper function to the
pointer stored by the director. If these are the same, then the C
wrapper function tells the director to resolve the method by calling up
the C++ inheritance chain, preventing an infinite loop.
</p>

<p>
One more point needs to be made about the relationship between director
classes and proxy classes. When a proxy class instance is created in
Python, SWIG creates an instance of the original C++ class and assigns
it to <tt>.this</tt>. This is exactly what happens without directors and
is true even if directors are enabled for the particular class in
question. When a class <i>derived</i> from a proxy class is created,
however, SWIG then creates an instance of the corresponding C++ director
class. The reason for this difference is that user-defined subclasses
may override or extend methods of the original class, so the director
class is needed to route calls to these methods correctly. For
unmodified proxy classes, all methods are ultimately implemented in C++
so there is no need for the extra overhead involved with routing the
calls through Python.
</p>

<H3><a name="Python_nn35">36.5.3 Ownership and object destruction</a></H3>


<p>
Memory management issues are slightly more complicated with directors
than for proxy classes alone. Python instances hold a pointer to the
associated C++ director object, and the director in turn holds a pointer
back to the Python object. By default, proxy classes own their C++
director object and take care of deleting it when they are garbage
collected.
</p>

<p>
This relationship can be reversed by calling the special
<tt>__disown__()</tt> method of the proxy class. After calling this
method, the <tt>.thisown</tt> flag is set to zero, and the director
class increments the reference count of the Python object. When the
director class is deleted it decrements the reference count. Assuming no
outstanding references to the Python object remain, the Python object
will be destroyed at the same time. This is a good thing, since
directors and proxies refer to each other and so must be created and
destroyed together. Destroying one without destroying the other will
likely cause your program to segfault.
</p>

<p>
To help ensure that no references to the Python object remain after
calling <tt>__disown__()</tt>, this method returns a weak reference to
the Python object. Weak references are only available in Python versions
2.1 and higher, so for older versions you must explicitly delete all
references. Here is an example:
</p>

<div class="code">
<pre>
class Foo {
public:
    ...
};
class FooContainer {
public:
    void addFoo(Foo *);
    ...
};
</pre>
</div>

<br>

<div class="targetlang">
<pre>
&gt;&gt;&gt; c = FooContainer()
&gt;&gt;&gt; a = Foo().__disown__()
&gt;&gt;&gt; c.addFoo(a)
&gt;&gt;&gt; b = Foo()
&gt;&gt;&gt; b = b.__disown__()
&gt;&gt;&gt; c.addFoo(b)
&gt;&gt;&gt; c.addFoo(Foo().__disown__())
</pre>
</div>

<p>
In this example, we are assuming that FooContainer will take care of
deleting all the Foo pointers it contains at some point.  Note that no hard
references to the Foo objects remain in Python.
</p>

<H3><a name="Python_nn36">36.5.4 Exception unrolling</a></H3>


<p>
With directors routing method calls to Python, and proxies routing them
to C++, the handling of exceptions is an important concern. By default, the
directors ignore exceptions that occur during method calls that are
resolved in Python. To handle such exceptions correctly, it is necessary
to temporarily translate them into C++ exceptions. This can be done with
the %feature("director:except") directive. The following code should
suffice in most cases:
</p>

<div class="code">
<pre>
%feature("director:except") {
    if ($error != NULL) {
        throw Swig::DirectorMethodException();
    }
}
</pre>
</div>

<p>
This code will check the Python error state after each method call from
a director into Python, and throw a C++ exception if an error occurred.
This exception can be caught in C++ to implement an error handler.
Currently no information about the Python error is stored in the
Swig::DirectorMethodException object, but this will likely change in
the future.
</p>

<p>
It may be the case that a method call originates in Python, travels up
to C++ through a proxy class, and then back into Python via a director
method. If an exception occurs in Python at this point, it would be nice
for that exception to find its way back to the original caller. This can
be done by combining a normal %exception directive with the
<tt>director:except</tt> handler shown above. Here is an example of a
suitable exception handler:
</p>

<div class="code">
<pre>
%exception {
    try { $action }
    catch (Swig::DirectorException &amp;e) { SWIG_fail; }
}
</pre>
</div>

<p>
The class Swig::DirectorException used in this example is actually a
base class of Swig::DirectorMethodException, so it will trap this
exception. Because the Python error state is still set when
Swig::DirectorMethodException is thrown, Python will register the
exception as soon as the C wrapper function returns.
</p>

<H3><a name="Python_nn37">36.5.5 Overhead and code bloat</a></H3>


<p>
Enabling directors for a class will generate a new director method for
every virtual method in the class' inheritance chain. This alone can
generate a lot of code bloat for large hierarchies. Method arguments
that require complex conversions to and from target language types can
result in large director methods. For this reason it is recommended that
you selectively enable directors only for specific classes that are
likely to be extended in Python and used in C++.
</p>

<p>
Compared to classes that do not use directors, the call routing in the
director methods does add some overhead. In particular, at least one
dynamic cast and one extra function call occurs per method call from
Python. Relative to the speed of Python execution this is probably
completely negligible. For worst case routing, a method call that
ultimately resolves in C++ may take one extra detour through Python in
order to ensure that the method does not have an extended Python
implementation. This could result in a noticeable overhead in some cases.
</p>

<p>
Although directors make it natural to mix native C++ objects with Python
objects (as director objects) via a common base class pointer, one
should be aware of the obvious fact that method calls to Python objects
will be much slower than calls to C++ objects. This situation can be
optimized by selectively enabling director methods (using the %feature
directive) for only those methods that are likely to be extended in
Python.
</p>

<H3><a name="Python_nn38">36.5.6 Typemaps</a></H3>


<p>
Typemaps for input and output of most of the basic types from director
classes have been written. These are roughly the reverse of the usual
input and output typemaps used by the wrapper code. The typemap
operation names are 'directorin', 'directorout', and 'directorargout'.
The director code does not currently use any of the other kinds of typemaps.
It is not clear at this point which kinds are appropriate and
need to be supported.
</p>


<H3><a name="Python_nn39">36.5.7 Miscellaneous</a></H3>


<p>
Director typemaps for STL classes are in place, and hence you should
be able to use std::vector, std::string, etc., as you would any other type.
</p>

<p>
<b>Note:</b> The director typemaps for return types based in const
references, such as 

<div class="code">
<pre>
class Foo {
&hellip;
    virtual const int&amp; bar();
&hellip;
};
</pre>
</div>

<p>
will work only for simple call scenarios. Usually the resulting code
is neither thread or reentrant safe. Hence, the user is advised to
avoid returning const references in director methods. For example,
the user could modify the method interface to use lvalue return
types, wherever possible, for example
</p>

<div class="code">
<pre>
class Foo {
&hellip;
    virtual int bar();
&hellip;
};
</pre>
</div>

<p>
If that is not possible, the user should avoid enabling the
director feature for reentrant, recursive or threaded member
methods that return const references.
</p>


<H2><a name="Python_nn40">36.6 Common customization features</a></H2>


<p>
The last section presented the absolute basics of C/C++ wrapping. If
you do nothing but feed SWIG a header file, you will get an interface
that mimics the behavior described.  However, sometimes this isn't
enough to produce a nice module.  Certain types of functionality might
be missing or the interface to certain functions might be awkward.
This section describes some common SWIG features that are used to
improve your the interface to an extension module.
</p>

<H3><a name="Python_nn41">36.6.1 C/C++ helper functions</a></H3>


<p>
Sometimes when you create a module, it is missing certain bits of functionality. For
example, if you had a function like this
</p>

<div class="code">
<pre>
void set_transform(Image *im, double m[4][4]);
</pre>
</div>

<p>
it would be accessible from Python, but there may be no easy way to call it.
For example, you might get errors like this:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; a = [
...   [1, 0, 0, 0],
...   [0, 1, 0, 0],
...   [0, 0, 1, 0],
...   [0, 0, 0, 1]]
&gt;&gt;&gt; set_transform(im, a)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: Type error. Expected _p_a_4__double
</pre>
</div>

<p>
The problem here is that there is no easy way to construct and manipulate a suitable
<tt>double [4][4]</tt> value to use.   To fix this, you can write some extra C helper
functions.  Just use the <tt>%inline</tt> directive. For example:
</p>

<div class="code">
<pre>
%inline %{
/* Note: double[4][4] is equivalent to a pointer to an array double (*)[4] */
double (*new_mat44())[4] {
  return (double (*)[4]) malloc(16*sizeof(double));
}
void free_mat44(double (*x)[4]) {
  free(x);
}
void mat44_set(double x[4][4], int i, int j, double v) {
  x[i][j] = v;
}
double mat44_get(double x[4][4], int i, int j) {
  return x[i][j];
}
%}
</pre>
</div>

<p>
From Python, you could then write code like this:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; a = new_mat44()
&gt;&gt;&gt; mat44_set(a, 0, 0, 1.0)
&gt;&gt;&gt; mat44_set(a, 1, 1, 1.0)
&gt;&gt;&gt; mat44_set(a, 2, 2, 1.0)
...
&gt;&gt;&gt; set_transform(im, a)
&gt;&gt;&gt;
</pre>
</div>

<p>
Admittedly, this is not the most elegant looking approach.  However, it works and it wasn't too
hard to implement.  It is possible to clean this up using Python code, typemaps, and other
customization features as covered in later sections.
</p>

<H3><a name="Python_nn42">36.6.2 Adding additional Python code</a></H3>


<p>
If writing support code in C isn't enough, it is also possible to write code in
Python.  This code gets inserted in to the <tt>.py</tt> file created by SWIG.   One
use of Python code might be to supply a high-level interface to certain functions.
For example:
</p>

<div class="code">
<pre>
void set_transform(Image *im, double x[4][4]);

...
/* Rewrite the high level interface to set_transform */
%pythoncode %{
def set_transform(im, x):
    a = new_mat44()
    for i in range(4):
        for j in range(4):
            mat44_set(a, i, j, x[i][j])
    _example.set_transform(im, a)
    free_mat44(a)
%}
</pre>
</div>

<p>
In this example, <tt>set_transform()</tt> provides a high-level Python interface built on top of
low-level helper functions.  For example, this code now seems to work:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; a = [
...   [1, 0, 0, 0],
...   [0, 1, 0, 0],
...   [0, 0, 1, 0],
...   [0, 0, 0, 1]]
&gt;&gt;&gt; set_transform(im, a)
&gt;&gt;&gt;
</pre>
</div>

<p>
Admittedly, this whole scheme for wrapping the two-dimension array
argument is rather ad-hoc. Besides, shouldn't a Python list or a
Numeric Python array just work normally?  We'll get to those examples
soon enough.  For now, think of this example as an illustration of
what can be done without having to rely on any of the more advanced
customization features.
</p>

<p>
There is also <tt>%pythonbegin</tt> which is another directive very similar to <tt>%pythoncode</tt>,
but generates the given Python code at the beginning of the <tt>.py</tt> file.
This directive works in the same way as <tt>%pythoncode</tt>, except the code is copied
just after the SWIG banner (comment) at the top of the file, before any real code.
This provides an opportunity to add your own description in a comment near the top of the file as well
as Python imports that have to appear at the top of the file, such as "<tt>from __future__ import</tt>"
statements.
</p>

<p>
The following shows example usage for Python 2.6 to use <tt>print</tt> as it can in Python 3, that is, as a function instead of a statement:
</p>

<div class="code">
<pre>
%pythonbegin %{
# This module provides wrappers to the Whizz Bang library
%}

%pythonbegin %{
from __future__ import print_function
print("Loading", "Whizz", "Bang", sep=' ... ')
%}
</pre>
</div>

<p>
which can be seen when viewing the first few lines of the generated <tt>.py</tt> file:
</p>

<div class="code">
<pre>
# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

# This module provides wrappers to the Whizz Bang library

from __future__ import print_function
print("Loading", "Whizz", "Bang", sep=' ... ')

</pre>
</div>

<p>When using <tt>%pythoncode</tt> and <tt>%pythonbegin</tt> you generally
want to make sure that the block is delimited by <tt>%{</tt> and <tt>%}</tt>.
If you delimit it with <tt>{</tt> and <tt>}</tt> then any lines with a
leading <tt>#</tt> will be handled by SWIG as preprocessor directives, when
you probably meant them as Python comments.  Prior to SWIG 3.0.3, invalid
preprocessor directives were silently ignored, so generally using the wrong
delimiters resulted in such comments not appearing in the generated output
(though a comment starting with a valid preprocessor directive could cause
problems, for example: <tt># error handling</tt>).  SWIG 3.0.3 and later report
an error for invalid preprocessor directives, so you may have to update
existing interface files to delimit blocks of Python code correctly.</p>

<p>As an alternative to providing a block containing Python code, you can
include python code from a file.  The code is inserted exactly as in the
file, so this avoids any issues with the SWIG preprocessor.  It's a good
approach if you have a non-trivial chunk of Python code to insert.  To
use this feature you specify a filename in double quotes, for example:</p>

<div class="code">
<pre>
%pythoncode "somecode.py"
</pre>
</div>

<p>Sometimes you may want to replace or modify the wrapper function
that SWIG creates in the proxy <tt>.py</tt> file.  The Python module
in SWIG provides some features that enable you to do this.  First, to
entirely replace a proxy function you can use
<tt>%feature("shadow")</tt>.  For example:</p>

<div class="code">
<pre>
%module example

// Rewrite bar() python code

%feature("shadow") Foo::bar(int) %{
def bar(*args):
    #do something before
    $action
    #do something after
%}
    
class Foo {
public:
    int bar(int x);
};
</pre>
</div>

<p> where <tt>$action</tt> will be replaced by the call to
the C/C++ proper method. 
</p>

<p>
Often the proxy function created by SWIG is fine, but you simply want
to add code to it without touching the rest of the generated function
body.  For these cases SWIG provides the <tt>pythonprepend</tt> and
<tt>pythonappend</tt> features which do exactly as their names suggest.  The
<tt>pythonprepend</tt> feature will insert its value at the beginning of the
proxy function, and <tt>pythonappend</tt> will insert code at the end of the
proxy, just before the return statement.
</p>


<div class="code">
<pre>
%module example

// Add python code to bar() 

%feature("pythonprepend") Foo::bar(int) %{
    #do something before C++ call
%}

%feature("pythonappend") Foo::bar(int) %{
    #do something after C++ call
%}

    
class Foo {
public:
    int bar(int x);
};
</pre>
</div>

<p>
Notes: Usually the <tt>pythonappend</tt> and <tt>pythonprepend</tt>
features are safer to use than the <tt>shadow</tt> feature. Also, from
SWIG version 1.3.28 you can use the directive forms
<tt>%pythonappend</tt>  and <tt>%pythonprepend</tt> as follows:</p>


<div class="code">
<pre>
%module example

// Add python code to bar() 

%pythonprepend Foo::bar(int) %{
    #do something before C++ call
%}

%pythonappend Foo::bar(int) %{
    #do something after C++ call
%}

    
class Foo {
public:
    int bar(int x);
};
</pre>
</div>

<p>
Note that when the underlying C++ method is overloaded, there is only one proxy Python method
for multiple C++ methods. In this case, only one of parsed methods is examined
for the feature. You are better off specifying the feature without the argument list to ensure it will get used,
as it will then get attached to all the overloaded C++ methods. For example:
</p>

<div class="code">
<pre>
%module example

// Add python code to bar()

%pythonprepend Foo::bar %{
    #do something before C++ call
%}

%pythonappend Foo::bar %{
    #do something after C++ call
%}


class Foo {
public:
    int bar(int x);
    int bar();
};
</pre>
</div>

<p>
The same applies for overloaded constructors.
</p>


<H3><a name="Python_nn43">36.6.3 Class extension with %extend</a></H3>


<p>
One of the more interesting features of SWIG is that it can extend
structures and classes with new methods--at least in the Python interface.
Here is a simple example:
</p>

<div class="code">
<pre>
%module example
%{
#include "someheader.h"
%}

struct Vector {
  double x, y, z;
};

%extend Vector {
  char *__str__() {
    static char tmp[1024];
    sprintf(tmp, "Vector(%g, %g, %g)", $self-&gt;x, $self-&gt;y, $self-&gt;z);
    return tmp;
  }
  Vector(double x, double y, double z) {
    Vector *v = (Vector *) malloc(sizeof(Vector));
    v-&gt;x = x;
    v-&gt;y = y;
    v-&gt;z = z;
    return v;
  }
};
</pre>
</div>

<p>
Now, in Python
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; v = example.Vector(2, 3, 4)
&gt;&gt;&gt; print v
Vector(2, 3, 4)
&gt;&gt;&gt;
</pre>
</div>

<p>
<tt>%extend</tt> can be used for many more tasks than this.  
For example, if you wanted to overload a Python operator, you might do this:
</p>

<div class="code">
<pre>
%extend Vector {
  Vector __add__(Vector *other) {
    Vector v;
    v.x = $self-&gt;x + other-&gt;x;
    v.y = $self-&gt;y + other-&gt;y;
    v.z = $self-&gt;z + other-&gt;z;
    return v;
  }
};
</pre>
</div>

<p>
Use it like this:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; import example
&gt;&gt;&gt; v = example.Vector(2, 3, 4)
&gt;&gt;&gt; w = example.Vector(10, 11, 12)
&gt;&gt;&gt; print v+w
Vector(12, 14, 16)
&gt;&gt;&gt; 
</pre>
</div>

<p>
<tt>%extend</tt> works with both C and C++ code.  It does not modify the underlying object
in any way---the extensions only show up in the Python interface.
</p>

<H3><a name="Python_nn44">36.6.4 Exception handling with %exception</a></H3>


<p>
If a C or C++ function throws an error, you may want to convert that error into a Python
exception. To do this, you can use the <tt>%exception</tt> directive.  <tt>%exception</tt>
simply lets you rewrite part of the generated wrapper code to include an error check.
</p>

<p>
In C, a function often indicates an error by returning a status code (a negative number
or a NULL pointer perhaps).  Here is a simple example of how you might handle that:
</p>

<div class="code">
<pre>
%exception malloc {
  $action
  if (!result) {
    PyErr_SetString(PyExc_MemoryError, "Not enough memory");
    SWIG_fail;
  }
}
void *malloc(size_t nbytes);
</pre>
</div>

<p>
In Python,
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; a = example.malloc(2000000000)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
MemoryError: Not enough memory
&gt;&gt;&gt;
</pre>
</div>

<p>
If a library provides some kind of general error handling framework, you can also use
that.  For example:
</p>

<div class="code">
<pre>
%exception {
  $action
  if (err_occurred()) {
    PyErr_SetString(PyExc_RuntimeError, err_message());
    SWIG_fail;
  }
}
</pre>
</div>

<p>
No declaration name is given to <tt>%exception</tt>, it is applied to all wrapper functions.
</p>

<p>
C++ exceptions are also easy to handle.  For example, you can write code like this:
</p>

<div class="code">
<pre>
%exception getitem {
  try {
    $action
  } catch (std::out_of_range &amp;e) {
    PyErr_SetString(PyExc_IndexError, const_cast&lt;char*&gt;(e.what()));
    SWIG_fail;
  }
}

class Base {
public:
  Foo *getitem(int index);      // Exception handled added
  ...
};
</pre>
</div>

<p>
When raising a Python exception from C, use the <tt>PyErr_SetString()</tt>
function as shown above followed by <tt>SWIG_fail</tt>.
The following exception types can be used as the first argument.
</p>

<div class="code">
<pre>
PyExc_ArithmeticError
PyExc_AssertionError
PyExc_AttributeError
PyExc_EnvironmentError
PyExc_EOFError
PyExc_Exception
PyExc_FloatingPointError
PyExc_ImportError
PyExc_IndexError
PyExc_IOError
PyExc_KeyError
PyExc_KeyboardInterrupt
PyExc_LookupError
PyExc_MemoryError
PyExc_NameError
PyExc_NotImplementedError
PyExc_OSError
PyExc_OverflowError
PyExc_RuntimeError
PyExc_StandardError
PyExc_SyntaxError
PyExc_SystemError
PyExc_TypeError
PyExc_UnicodeError
PyExc_ValueError
PyExc_ZeroDivisionError
</pre>
</div>

<p>
<tt>SWIG_fail</tt> is a C macro which when called within the context of SWIG wrapper function,
will jump to the error handler code. This will call any cleanup code (freeing any temp variables)
and then return from the wrapper function so that the Python interpreter can raise the Python exception.
This macro should always be called after setting a Python error in code snippets, such as typemaps and <tt>%exception</tt>, that are ultimately generated into the wrapper function.
</p>

<p>
The language-independent <tt>exception.i</tt> library file can also be used
to raise exceptions.  See the <a href="Library.html#Library">SWIG Library</a> chapter.
</p>

<H2><a name="Python_nn45">36.7 Tips and techniques</a></H2>


<p>
Although SWIG is largely automatic, there are certain types of wrapping problems that
require additional user input.    Examples include dealing with output parameters,
strings, binary data, and arrays.   This chapter discusses the common techniques for
solving these problems.
</p>

<H3><a name="Python_nn46">36.7.1 Input and output parameters</a></H3>


<p>
A common problem in some C programs is handling parameters passed as simple pointers.  For
example:
</p>

<div class="code">
<pre>
void add(int x, int y, int *result) {
  *result = x + y;
}
</pre>
</div>

<p>
or perhaps
</p>

<div class="code">
<pre>
int sub(int *x, int *y) {
  return *x-*y;
}
</pre>
</div>

<p>
The easiest way to handle these situations is to use the <tt>typemaps.i</tt> file.  For example:
</p>

<div class="code">
<pre>
%module example
%include "typemaps.i"

void add(int, int, int *OUTPUT);
int  sub(int *INPUT, int *INPUT);
</pre>
</div>

<p>
In Python, this allows you to pass simple values.  For example:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; a = add(3, 4)
&gt;&gt;&gt; print a
7
&gt;&gt;&gt; b = sub(7, 4)
&gt;&gt;&gt; print b
3
&gt;&gt;&gt;
</pre>
</div>

<p>
Notice how the <tt>INPUT</tt> parameters allow integer values to be passed instead of pointers
and how the <tt>OUTPUT</tt> parameter creates a return result.
</p>

<p>
If you don't want to use the names <tt>INPUT</tt> or <tt>OUTPUT</tt>, use the <tt>%apply</tt>
directive.  For example:
</p>

<div class="code">
<pre>
%module example
%include "typemaps.i"

%apply int *OUTPUT { int *result };
%apply int *INPUT  { int *x, int *y};

void add(int x, int y, int *result);
int  sub(int *x, int *y);
</pre>
</div>

<p>
If a function mutates one of its parameters like this,
</p>

<div class="code">
<pre>
void negate(int *x) {
  *x = -(*x);
}
</pre>
</div>

<p>
you can use <tt>INOUT</tt> like this:
</p>

<div class="code">
<pre>
%include "typemaps.i"
...
void negate(int *INOUT);
</pre>
</div>

<p>
In Python, a mutated parameter shows up as a return value.  For example:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; a = negate(3)
&gt;&gt;&gt; print a
-3
&gt;&gt;&gt;
</pre>
</div>

<p>
Note: Since most primitive Python objects are immutable, it is not possible to
perform in-place modification of a Python object passed as a parameter.
</p>

<p>
The most common use of these special typemap rules is to handle functions that
return more than one value.   For example, sometimes a function returns a result
as well as a special error code:
</p>

<div class="code">
<pre>
/* send message, return number of bytes sent, along with success code */
int send_message(char *text, int len, int *success);
</pre>
</div>

<p>
To wrap such a function, simply use the <tt>OUTPUT</tt> rule above. For example:
</p>

<div class="code">
<pre>
%module example
%include "typemaps.i"
%apply int *OUTPUT { int *success };
...
int send_message(char *text, int *success);
</pre>
</div>

<p>
When used in Python, the function will return multiple values.  
</p>

<div class="targetlang">
<pre>
bytes, success = send_message("Hello World")
if not success:
    print "Whoa!"
else:
    print "Sent", bytes
</pre>
</div>

<p>
Another common use of multiple return values are in query functions.  For example:
</p>

<div class="code">
<pre>
void get_dimensions(Matrix *m, int *rows, int *columns);
</pre>
</div>

<p>
To wrap this, you might use the following:
</p>

<div class="code">
<pre>
%module example
%include "typemaps.i"
%apply int *OUTPUT { int *rows, int *columns };
...
void get_dimensions(Matrix *m, int *rows, *columns);
</pre>
</div>

<p>
Now, in Python:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; r, c = get_dimensions(m)
</pre>
</div>

<p>
Be aware that the primary purpose of the <tt>typemaps.i</tt> file is to support primitive datatypes.
Writing a function like this
</p>

<div class="code">
<pre>
void foo(Bar *OUTPUT);
</pre>
</div>

<p>
may not have the intended effect since <tt>typemaps.i</tt> does not define an OUTPUT rule for <tt>Bar</tt>.
</p>

<H3><a name="Python_nn47">36.7.2 Simple pointers</a></H3>


<p>
If you must work with simple pointers such as <tt>int *</tt> or <tt>double *</tt> and you don't want to use
<tt>typemaps.i</tt>, consider using the <tt>cpointer.i</tt> library file.    For example:
</p>

<div class="code">
<pre>
%module example
%include "cpointer.i"

%inline %{
extern void add(int x, int y, int *result);
%}

%pointer_functions(int, intp);
</pre>
</div>

<p>
The <tt>%pointer_functions(type, name)</tt> macro generates five helper functions that can be used to create,
destroy, copy, assign, and dereference a pointer.  In this case, the functions are as follows:
</p>

<div class="code">
<pre>
int  *new_intp();
int  *copy_intp(int *x);
void  delete_intp(int *x);
void  intp_assign(int *x, int value);
int   intp_value(int *x);
</pre>
</div>

<p>
In Python, you would use the functions like this:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; result = new_intp()
&gt;&gt;&gt; print result
_108fea8_p_int
&gt;&gt;&gt; add(3, 4, result)
&gt;&gt;&gt; print intp_value(result)
7
&gt;&gt;&gt;
</pre>
</div>

<p>
If you replace <tt>%pointer_functions()</tt> by <tt>%pointer_class(type, name)</tt>, the interface is more class-like.
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; result = intp()
&gt;&gt;&gt; add(3, 4, result)
&gt;&gt;&gt; print result.value()
7
</pre>
</div>

<p>
See the <a href="Library.html#Library">SWIG Library</a> chapter for further details.
</p>

<H3><a name="Python_nn48">36.7.3 Unbounded C Arrays</a></H3>


<p>
Sometimes a C function expects an array to be passed as a pointer.  For example,
</p>

<div class="code">
<pre>
int sumitems(int *first, int nitems) {
    int i, sum = 0;
    for (i = 0; i &lt; nitems; i++) {
        sum += first[i];
    }
    return sum;
}
</pre>
</div>

<p>
To wrap this into Python, you need to pass an array pointer as the first argument. 
A simple way to do this is to use the <tt>carrays.i</tt> library file.  For example:
</p>

<div class="code">
<pre>
%include "carrays.i"
%array_class(int, intArray);
</pre>
</div>

<p>
The <tt>%array_class(type, name)</tt> macro creates wrappers for an unbounded array object that
can be passed around as a simple pointer like <tt>int *</tt> or <tt>double *</tt>.
For instance, you will be able to do this in Python:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; a = intArray(10000000)         # Array of 10-million integers
&gt;&gt;&gt; for i in xrange(10000):        # Set some values
...     a[i] = i
&gt;&gt;&gt; sumitems(a, 10000)
49995000
&gt;&gt;&gt;
</pre>
</div>

<p>
The array "object" created by <tt>%array_class()</tt> does not
encapsulate pointers inside a special array object.  In fact, there is
no bounds checking or safety of any kind (just like in C).  Because of
this, the arrays created by this library are extremely low-level
indeed.  You can't iterate over them nor can you even query their
length.  In fact, any valid memory address can be accessed if you want
(negative indices, indices beyond the end of the array, etc.).
Needless to say, this approach is not going to suit all applications.
On the other hand, this low-level approach is extremely efficient and
well suited for applications in which you need to create buffers,
package binary data, etc.
</p>

<H3><a name="Python_nn49">36.7.4 String handling</a></H3>


<p>
If a C function has an argument of <tt>char *</tt>, then a Python string
can be passed as input.  For example:
</p>

<div class="code">
<pre>
// C
void foo(char *s);
</pre>
</div>

<div class="targetlang">
<pre>
# Python
&gt;&gt;&gt; foo("Hello")
</pre>
</div>

<p>
When a Python string is passed as a parameter, the C function receives a pointer to the raw
data contained in the string.  Since Python strings are immutable, it is illegal
for your program to change the value.  In fact, doing so will probably crash the Python
interpreter.
</p>

<p>
If your program modifies the input parameter or uses it to return data, consider
using the <tt>cstring.i</tt> library file described in the <a href="Library.html#Library">SWIG Library</a> chapter.
</p>

<p>
When functions return a <tt>char *</tt>, it is assumed to be a NULL-terminated string. 
Data is copied into a new Python string and returned.
</p>

<p>
If your program needs to work with binary data, you can use a typemap
to expand a Python string into a pointer/length argument pair.   As luck would have it, 
just such a typemap is already defined. Just do this:
</p>

<div class="code">
<pre>
%apply (char *STRING, int LENGTH) { (char *data, int size) };
...
int parity(char *data, int size, int initial);
</pre>
</div>

<p>
Now in Python:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; parity("e\x09ffss\x00\x00\x01\nx", 0)
</pre>
</div>

<p>
If you need to return binary data, you might use the
<tt>cstring.i</tt> library file.  The <tt>cdata.i</tt> library can
also be used to extra binary data from arbitrary pointers.
</p>


<H3><a name="Python_default_args">36.7.5 Default arguments</a></H3>


<p>
C++ default argument code generation is documented in the main
<a href="SWIGPlus.html#SWIGPlus_default_args">Default arguments</a> section.
There is also an optional Python specific feature that can be used called the <tt>python:cdefaultargs</tt> 
<a href="Customization.html#Customization_feature_flags">feature flag</a>.
By default, SWIG attempts to convert C++ default argument values
into Python values and generates code into the Python layer containing these values.
For example:
</p>

<div class="code">
<pre>
struct CDA {
  int fff(int a = 1, bool b = false);
};
</pre>
</div>

<p>
From Python this can be called as follows:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; CDA().fff()        # C++ layer receives a=1 and b=false
&gt;&gt;&gt; CDA().fff(2)       # C++ layer receives a=2 and b=false
&gt;&gt;&gt; CDA().fff(3, True) # C++ layer receives a=3 and b=true
</pre>
</div>

<p>
The default code generation in the Python layer is:
</p>

<div class="targetlang">
<pre>
class CDA(object):
    ...
    def fff(self, a=1, b=False):
        return _default_args.CDA_fff(self, a, b)
</pre>
</div>

<p>
Adding the feature:
</p>
  
<div class="code">
<pre>
%feature("python:cdefaultargs") CDA::fff;
struct CDA {
  int fff(int a = 1, bool b = false);
</pre>
</div>

<p>
results in identical behaviour when called from Python, however, it results in different code generation:
</p>

<div class="targetlang">
<pre>
class CDA(object):
    ...
    def fff(self, *args):
        return _default_args.CDA_fff(self, *args)
</pre>
</div>

<p>
The default arguments are obtained in the C++ wrapper layer instead of the Python layer.
Some code generation modes are quite different, eg <tt>-builtin</tt> and <tt>-fastproxy</tt>,
and are unaffected by <tt>python:cdefaultargs</tt> as the default values are always obtained from the C++ layer.
</p>

<p>
Note that not all default arguments can be converted into a Python equivalent.
When SWIG does not convert them, it will generate code to obtain them from the C++ layer as if
<tt>python:cdefaultargs</tt> was specified.
This will happen if just one argument cannot be converted into a Python equivalent.
This occurs typically when the argument is not fully numeric, such as <tt>int(1)</tt>:
</p>

<div class="code">
<pre>
struct CDA {
  int fff(int a = int(1), bool b = false);
};
</pre>
</div>

<p>
<b>Compatibility Note:</b> SWIG-3.0.6 introduced the <tt>python:cdefaultargs</tt> feature.
Versions of SWIG prior to this varied in their ability to convert C++ default values into
equivalent Python default argument values.
</p>

<H2><a name="Python_nn53">36.8 Typemaps</a></H2>


<p>
This section describes how you can modify SWIG's default wrapping behavior
for various C/C++ datatypes using the <tt>%typemap</tt> directive.   This
is an advanced topic that assumes familiarity with the Python C API as well
as the material in the "<a href="Typemaps.html#Typemaps">Typemaps</a>" chapter.
</p>

<p>
Before proceeding, it should be stressed that typemaps are not a required 
part of using SWIG---the default wrapping behavior is enough in most cases.
Typemaps are only used if you want to change some aspect of the primitive
C-Python interface or if you want to elevate your guru status.
</p>

<H3><a name="Python_nn54">36.8.1 What is a typemap?</a></H3>


<p>
A typemap is nothing more than a code generation rule that is attached to 
a specific C datatype.   For example, to convert integers from Python to C,
you might define a typemap like this:
</p>

<div class="code"><pre>
%module example

%typemap(in) int {
  $1 = (int) PyLong_AsLong($input);
  printf("Received an integer : %d\n", $1);
}
%inline %{
extern int fact(int n);
%}
</pre></div>

<p>
Typemaps are always associated with some specific aspect of code generation.
In this case, the "in" method refers to the conversion of input arguments
to C/C++.  The datatype <tt>int</tt> is the datatype to which the typemap
will be applied.  The supplied C code is used to convert values.  In this
code a number of special variable prefaced by a <tt>$</tt> are used.  The
<tt>$1</tt> variable is placeholder for a local variable of type <tt>int</tt>.
The <tt>$input</tt> variable is the input object of type <tt>PyObject *</tt>.
</p>

<p>
When this example is compiled into a Python module, it operates as follows:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; from example import *
&gt;&gt;&gt; fact(6)
Received an integer : 6
720
</pre></div>

<p>
In this example, the typemap is applied to all occurrences of the <tt>int</tt> datatype.
You can refine this by supplying an optional parameter name.  For example:
</p>

<div class="code"><pre>
%module example

%typemap(in) int nonnegative {
  $1 = (int) PyLong_AsLong($input);
  if ($1 &lt; 0) {
    PyErr_SetString(PyExc_ValueError, "Expected a nonnegative value.");
    SWIG_fail;
  }
}
%inline %{
extern int fact(int nonnegative);
%}
</pre></div>

<p>
In this case, the typemap code is only attached to arguments that exactly match <tt>int nonnegative</tt>.
</p>

<p>
The application of a typemap to specific datatypes and argument names involves
more than simple text-matching--typemaps are fully integrated into the
SWIG C++ type-system.   When you define a typemap for <tt>int</tt>, that typemap
applies to <tt>int</tt> and qualified variations such as <tt>const int</tt>.  In addition,
the typemap system follows <tt>typedef</tt> declarations.  For example:
</p>

<div class="code">
<pre>
%typemap(in) int n {
  $1 = (int) PyLong_AsLong($input);
  printf("n = %d\n", $1);
}
%inline %{
typedef int Integer;
extern int fact(Integer n);    // Above typemap is applied
%}
</pre>
</div>

<p>
Typemaps can also be defined for groups of consecutive arguments.  For example:
</p>

<div class="code">
<pre>
%typemap(in) (char *str, int len) {
  $1 = PyString_AsString($input);
  $2 = PyString_Size($input);
};

int count(char c, char *str, int len);
</pre>
</div>

<p>
When a multi-argument typemap is defined, the arguments are always handled as a single
Python object.  This allows the function to be used like this (notice how the length
parameter is omitted):
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; example.count('e', 'Hello World')
1
&gt;&gt;&gt;
</pre>
</div>

<H3><a name="Python_nn55">36.8.2 Python typemaps</a></H3>


<p>
The previous section illustrated an "in" typemap for converting Python objects to C.
A variety of different typemap methods are defined by the Python module.  For example,
to convert a C integer back into a Python object, you might define an "out" typemap
like this:
</p>

<div class="code">
<pre>
%typemap(out) int {
    $result = PyInt_FromLong((long) $1);
}
</pre>
</div>

<p>
A detailed list of available methods can be found in the "<a
href="Typemaps.html#Typemaps">Typemaps</a>" chapter.  
</p>

<p>
However, the best source of typemap information (and examples) is
probably the Python module itself.  In fact, all of SWIG's default
type handling is defined by typemaps.  You can view these typemaps by
looking at the files in the SWIG library. Just take into account that
in the latest versions of swig (1.3.22+), the library files are not
very pristine clear for the casual reader, as they used to be. The
extensive use of macros and other ugly techniques in the latest
version produce a very powerful and consistent python typemap library,
but at the cost of simplicity and pedagogic value.
</p>

<p>
To learn how to write a simple or your first typemap, you better take
a look at the SWIG library version 1.3.20 or so.
</p>


<H3><a name="Python_nn56">36.8.3 Typemap variables</a></H3>


<p>
Within typemap code, a number of special variables prefaced with a <tt>$</tt> may appear.
A full list of variables can be found in the "<a href="Typemaps.html#Typemaps">Typemaps</a>" chapter.
This is a list of the most common variables:
</p>

<p>
<tt>$1</tt>
</p>

<div class="indent">
A C local variable corresponding to the actual type specified in the
<tt>%typemap</tt> directive.  For input values, this is a C local variable
that's supposed to hold an argument value.  For output values, this is
the raw result that's supposed to be returned to Python.
</div>

<p>
<tt>$input</tt>
</p>

<div class="indent">
 A <tt>PyObject *</tt> holding a raw Python object with an argument or variable value.
</div>

<p>
<tt>$result</tt>
</p>

<div class="indent">
A <tt>PyObject *</tt> that holds the result to be returned to Python.
</div>

<p>
<tt>$1_name</tt>
</p>

<div class="indent">
The parameter name that was matched. 
</div>

<p>
<tt>$1_type</tt>
</p>

<div class="indent">
The actual C datatype matched by the typemap.
</div>

<p>
<tt>$1_ltype</tt>
</p>

<div class="indent">
An assignable version of the datatype matched by the typemap (a type that can appear on the left-hand-side of
a C assignment operation).  This type is stripped of qualifiers and may be an altered version of <tt>$1_type</tt>.
All arguments and local variables in wrapper functions are declared using this type so that their values can be
properly assigned.
</div>

<p>
<tt>$symname</tt>
</p>

<div class="indent">
The Python name of the wrapper function being created.
</div>

<H3><a name="Python_nn57">36.8.4 Useful Python Functions</a></H3>


<p>
When you write a typemap, you usually have to work directly with Python objects.
The following functions may prove to be useful.
</p>

<p>
<b>Python Integer Functions</b>
</p>

<div class="code">
<pre>
PyObject *PyInt_FromLong(long l);
long      PyInt_AsLong(PyObject *);
int       PyInt_Check(PyObject *);
</pre>
</div>

<p>
<b>Python Floating Point Functions</b>
</p>

<div class="code">
<pre>
PyObject *PyFloat_FromDouble(double);
double    PyFloat_AsDouble(PyObject *);
int       PyFloat_Check(PyObject *);
</pre>
</div>

<p>
<b>Python String Functions</b>
</p>

<div class="code">
<pre>
PyObject *PyString_FromString(char *);
PyObject *PyString_FromStringAndSize(char *, lint len);
int       PyString_Size(PyObject *);
char     *PyString_AsString(PyObject *);
int       PyString_Check(PyObject *);
</pre>
</div>

<p>
<b>Python List Functions</b>
</p>

<div class="code">
<pre>
PyObject *PyList_New(int size);
int       PyList_Size(PyObject *list);
PyObject *PyList_GetItem(PyObject *list, int i);
int       PyList_SetItem(PyObject *list, int i, PyObject *item);
int       PyList_Insert(PyObject *list, int i, PyObject *item);
int       PyList_Append(PyObject *list, PyObject *item);
PyObject *PyList_GetSlice(PyObject *list, int i, int j);
int       PyList_SetSlice(PyObject *list, int i, int , PyObject *list2);
int       PyList_Sort(PyObject *list);
int       PyList_Reverse(PyObject *list);
PyObject *PyList_AsTuple(PyObject *list);
int       PyList_Check(PyObject *);
</pre>
</div>

<p>
<b>Python Tuple Functions</b>
</p>

<div class="code">
<pre>
PyObject *PyTuple_New(int size);
int       PyTuple_Size(PyObject *);
PyObject *PyTuple_GetItem(PyObject *, int i);
int       PyTuple_SetItem(PyObject *, int i, PyObject *item);
PyObject *PyTuple_GetSlice(PyObject *t, int i, int j);
int       PyTuple_Check(PyObject *);
</pre>
</div>

<p>
<b>Python Dictionary Functions</b>
</p>

<div class="code">
<pre>
PyObject *PyDict_New();
int       PyDict_Check(PyObject *);
int       PyDict_SetItem(PyObject *p, PyObject *key, PyObject *val);
int       PyDict_SetItemString(PyObject *p, const char *key, PyObject *val);
int       PyDict_DelItem(PyObject *p, PyObject *key);
int       PyDict_DelItemString(PyObject *p, char *key);
PyObject* PyDict_Keys(PyObject *p);
PyObject* PyDict_Values(PyObject *p);
PyObject* PyDict_GetItem(PyObject *p, PyObject *key);
PyObject* PyDict_GetItemString(PyObject *p, const char *key);
int       PyDict_Next(PyObject *p, Py_ssize_t *ppos, PyObject **pkey, PyObject **pvalue);
Py_ssize_t PyDict_Size(PyObject *p);
int       PyDict_Update(PyObject *a, PyObject *b);
int       PyDict_Merge(PyObject *a, PyObject *b, int override);
PyObject* PyDict_Items(PyObject *p);
</pre>
</div>

<p>
<b>Python File Conversion Functions</b>
</p>

<div class="code">
<pre>
PyObject *PyFile_FromFile(FILE *f);
FILE     *PyFile_AsFile(PyObject *);
int       PyFile_Check(PyObject *);
</pre>
</div>

<p>
<b>Abstract Object Interface</b>
</p>

<div class="code">
<pre>
write me
</pre>
</div>

<H2><a name="Python_nn58">36.9 Typemap Examples</a></H2>


<p>
This section includes a few examples of typemaps.  For more examples, you
might look at the files "<tt>python.swg</tt>" and "<tt>typemaps.i</tt>" in
the SWIG library.
</p>

<H3><a name="Python_nn59">36.9.1 Converting  Python list to a char ** </a></H3>


<p>
A common problem in many C programs is the processing of command line
arguments, which are usually passed in an array of NULL terminated
strings.  The following SWIG interface file allows a Python list
object to be used as a <tt>char **</tt> object.
</p>

<div class="code"><pre>
%module argv

// This tells SWIG to treat char ** as a special case
%typemap(in) char ** {
  /* Check if is a list */
  if (PyList_Check($input)) {
    int size = PyList_Size($input);
    int i = 0;
    $1 = (char **) malloc((size+1)*sizeof(char *));
    for (i = 0; i &lt; size; i++) {
      PyObject *o = PyList_GetItem($input, i);
      if (PyString_Check(o)) {
        $1[i] = PyString_AsString(PyList_GetItem($input, i));
      } else {
        free($1);
        PyErr_SetString(PyExc_TypeError, "list must contain strings");
        SWIG_fail;
      }
    }
    $1[i] = 0;
  } else {
    PyErr_SetString(PyExc_TypeError, "not a list");
    SWIG_fail;
  }
}

// This cleans up the char ** array we malloc'd before the function call
%typemap(freearg) char ** {
  free((char *) $1);
}

// Now a test function
%inline %{
int print_args(char **argv) {
  int i = 0;
  while (argv[i]) {
    printf("argv[%d] = %s\n", i, argv[i]);
    i++;
  }
  return i;
}
%}

</pre></div>

<p>
When this module is compiled, the wrapped C function now operates as
follows :
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; from argv import *
&gt;&gt;&gt; print_args(["Dave", "Mike", "Mary", "Jane", "John"])
argv[0] = Dave
argv[1] = Mike
argv[2] = Mary
argv[3] = Jane
argv[4] = John
5
</pre></div>

<p>
In the example, two different typemaps are used.  The "in" typemap is
used to receive an input argument and convert it to a C array.  Since dynamic
memory allocation is used to allocate memory for the array, the
"freearg" typemap is used to later release this memory after the execution of
the C function. 
</p>

<H3><a name="Python_nn60">36.9.2 Expanding a Python object into multiple arguments</a></H3>


<p>
Suppose that you had a collection of C functions with arguments
such as the following:
</p>

<div class="code">
<pre>
int foo(int argc, char **argv);
</pre>
</div>

<p>
In the previous example, a typemap was written to pass a Python list as the <tt>char **argv</tt>.  This
allows the function to be used from Python as follows:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; foo(4, ["foo", "bar", "spam", "1"])
</pre>
</div>

<p>
Although this works, it's a little awkward to specify the argument count.  To fix this, a multi-argument
typemap can be defined.  This is not very difficult--you only have to make slight modifications to the
previous example:
</p>

<div class="code">
<pre>
%typemap(in) (int argc, char **argv) {
  /* Check if is a list */
  if (PyList_Check($input)) {
    int i;
    $1 = PyList_Size($input);
    $2 = (char **) malloc(($1+1)*sizeof(char *));
    for (i = 0; i &lt; $1; i++) {
      PyObject *o = PyList_GetItem($input, i);
      if (PyString_Check(o)) {
        $2[i] = PyString_AsString(PyList_GetItem($input, i));
      } else {
        free($2);
        PyErr_SetString(PyExc_TypeError, "list must contain strings");
        SWIG_fail;
      }
    }
    $2[i] = 0;
  } else {
    PyErr_SetString(PyExc_TypeError, "not a list");
    SWIG_fail;
  }
}

%typemap(freearg) (int argc, char **argv) {
  free((char *) $2);
}
</pre>
</div>

<p>
When writing a multiple-argument typemap, each of the types is referenced by a variable such 
as <tt>$1</tt> or <tt>$2</tt>.   The typemap code simply fills in the appropriate values from
the supplied Python object.
</p>

<p>
With the above typemap in place, you will find it no longer necessary
to supply the argument count.  This is automatically set by the typemap code.  For example:
</p>

<div class="targetlang">
<pre>
&gt;&gt;&gt; foo(["foo", "bar", "spam", "1"])
</pre>
</div>

<p>
If your function is overloaded in C++, for example:
</p>

<div class="code">
<pre>
int foo(int argc, char **argv);
int foo();
</pre>
</div>

<p>
don't forget to also provide a suitable <a href="Typemaps.html#Typemaps_overloading">typecheck typemap for overloading</a>
such as:
</p>

<div class="code">
<pre>
%typecheck(SWIG_TYPECHECK_STRING_ARRAY) (int argc, char **argv) {
  $1 = PyList_Check($input) ? 1 : 0;
}
</pre>
</div>

<p>
If you don't you'll get an error message along the lines of:
</p>

<div class="shell">
<pre>
Traceback (most recent call last):
  File "runme.py", line 3, in &gt;module&lt;
    example.foo(["foo", "bar", "spam", "1"])
NotImplementedError: Wrong number or type of arguments for overloaded function 'foo'.
  Possible C/C++ prototypes are:
    foo(int, char **)
    foo()
</pre>
</div>

<H3><a name="Python_nn61">36.9.3 Using typemaps to return arguments</a></H3>


<p>
A common problem in some C programs is that values may be returned in
arguments rather than in the return value of a function.  For example:
</p>

<div class="code"><pre>
/* Returns a status value and two values in out1 and out2 */
int spam(double a, double b, double *out1, double *out2) {
  ... Do a bunch of stuff ...
  *out1 = result1;
  *out2 = result2;
  return status;
}
</pre></div>

<p>
A typemap can be used to handle this case as follows :
</p>

<div class="code"><pre>
%module outarg

// This tells SWIG to treat an double * argument with name 'OutValue' as
// an output value.  We'll append the value to the current result which 
// is guaranteed to be a List object by SWIG.

%typemap(argout) double *OutValue {
  PyObject *o, *o2, *o3;
  o = PyFloat_FromDouble(*$1);
  if ((!$result) || ($result == Py_None)) {
    $result = o;
  } else {
    if (!PyTuple_Check($result)) {
      PyObject *o2 = $result;
      $result = PyTuple_New(1);
      PyTuple_SetItem($result, 0, o2);
    }
    o3 = PyTuple_New(1);
    PyTuple_SetItem(o3, 0, o);
    o2 = $result;
    $result = PySequence_Concat(o2, o3);
    Py_DECREF(o2);
    Py_DECREF(o3);
  }
}

int spam(double a, double b, double *OutValue, double *OutValue);

</pre></div>

<p>
The typemap works as follows.  First, a check is made to see if any previous result
exists.  If so, it is turned into a tuple and the new output value is concatenated to it.
Otherwise, the result is returned normally.   For the sample function <tt>spam()</tt>, there
are three output values--meaning that the function will return a 3-tuple of the results.
</p>

<p>
As written, the function must accept 4 arguments as input values,
last two being pointers to doubles.  If these arguments are only used to hold output values (and have
no meaningful input value), an additional typemap can be written.  For example:
</p>

<div class="code"><pre>
%typemap(in, numinputs=0) double *OutValue(double temp) {
  $1 = &amp;temp;
}

</pre></div>

<p>
By specifying numinputs=0,  the input value is ignored.  However, since the argument still has to be set to
some meaningful value before calling C, it is set to point to a local variable <tt>temp</tt>.  When the function
stores its output value, it will simply be placed in this local variable.  As a result, the
function can now be used as follows:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; a = spam(4, 5)
&gt;&gt;&gt; print a
(0, 2.45, 5.0)
&gt;&gt;&gt; x, y, z = spam(4, 5)
&gt;&gt;&gt;
</pre></div>

<H3><a name="Python_nn62">36.9.4 Mapping Python tuples into small arrays</a></H3>


<p>
In some applications, it is sometimes desirable to pass small arrays
of numbers as arguments. For example :
</p>

<div class="code"><pre>
extern void set_direction(double a[4]);       // Set direction vector
</pre></div>

<p>
This too, can be handled used typemaps as follows :
</p>

<div class="code"><pre>
// Grab a 4 element array as a Python 4-tuple
%typemap(in) double[4](double temp[4]) {   // temp[4] becomes a local variable
  int i;
  if (PyTuple_Check($input)) {
    if (!PyArg_ParseTuple($input, "dddd", temp, temp+1, temp+2, temp+3)) {
      PyErr_SetString(PyExc_TypeError, "tuple must have 4 elements");
      SWIG_fail;
    }
    $1 = &amp;temp[0];
  } else {
    PyErr_SetString(PyExc_TypeError, "expected a tuple.");
    SWIG_fail;
  }
}

</pre></div>

<p>
This allows our <tt>set_direction</tt> function to be called from
Python as follows :
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; set_direction((0.5, 0.0, 1.0, -0.25))
</pre></div>

<p>
Since our mapping copies the contents of a Python tuple into a C
array, such an approach would not be recommended for huge arrays, but
for small structures, this approach works fine.
</p>

<H3><a name="Python_nn63">36.9.5 Mapping sequences to C arrays</a></H3>


<p>
Suppose that you wanted to generalize the previous example to handle C
arrays of different sizes.  To do this, you might write a typemap as follows:
</p>

<div class="code"><pre>
// Map a Python sequence into any sized C double array
%typemap(in) double[ANY](double temp[$1_dim0]) {
  int i;
  if (!PySequence_Check($input)) {
    PyErr_SetString(PyExc_TypeError, "Expecting a sequence");
    SWIG_fail;
  }
  if (PyObject_Length($input) != $1_dim0) {
    PyErr_SetString(PyExc_ValueError, "Expecting a sequence with $1_dim0 elements");
    SWIG_fail;
  }
  for (i =0; i &lt; $1_dim0; i++) {
    PyObject *o = PySequence_GetItem($input, i);
    if (!PyFloat_Check(o)) {
      Py_XDECREF(o);
      PyErr_SetString(PyExc_ValueError, "Expecting a sequence of floats");
      SWIG_fail;
    }
    temp[i] = PyFloat_AsDouble(o);
    Py_DECREF(o);
  }
  $1 = &amp;temp[0];
}
</pre>
</div>

<p>
In this case, the variable <tt>$1_dim0</tt> is expanded to match the
array dimensions actually used in the C code. This allows the typemap
to be applied to types such as:
</p>

<div class="code">
<pre>
void foo(double x[10]);
void bar(double a[4], double b[8]);
</pre>
</div>

<p>
Since the above typemap code gets inserted into every wrapper function where used, it might make sense
to use a helper function instead.  This will greatly reduce the amount of wrapper code.  For example:
</p>

<div class="code">
<pre>
%{
static int convert_darray(PyObject *input, double *ptr, int size) {
  int i;
  if (!PySequence_Check(input)) {
    PyErr_SetString(PyExc_TypeError, "Expecting a sequence");
    return 0;
  }
  if (PyObject_Length(input) != size) {
    PyErr_SetString(PyExc_ValueError, "Sequence size mismatch");
    return 0;
  }
  for (i =0; i &lt; size; i++) {
    PyObject *o = PySequence_GetItem(input, i);
    if (!PyFloat_Check(o)) {
      Py_XDECREF(o);
      PyErr_SetString(PyExc_ValueError, "Expecting a sequence of floats");
      return 0;
    }
    ptr[i] = PyFloat_AsDouble(o);
    Py_DECREF(o);
  }
  return 1;
}
%}

%typemap(in) double [ANY](double temp[$1_dim0]) {
  if (!convert_darray($input, temp, $1_dim0)) {
    SWIG_fail;
  }
  $1 = &amp;temp[0];
}
</pre>
</div>

<H3><a name="Python_nn64">36.9.6 Pointer handling</a></H3>


<p>
Occasionally, it might be necessary to convert pointer values that have
been stored using the SWIG typed-pointer representation.  Since there are
several ways in which pointers can be represented, the following two
functions are used to safely perform this conversion:
</p>

<p>
<tt>
int SWIG_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags)</tt>
</p>

<div class="indent">
Converts a Python object <tt>obj</tt> to a C pointer.  The result of the conversion is placed
into the pointer located at <tt>ptr</tt>.  <tt>ty</tt> is a SWIG type descriptor structure.
<tt>flags</tt> is used to handle error checking and other aspects of conversion.  It is the
bitwise-or of several flag values including <tt>SWIG_POINTER_EXCEPTION</tt> and
<tt>SWIG_POINTER_DISOWN</tt>.   The first flag makes the function raise an exception on type
error.  The second flag additionally
steals ownership of an object. Returns 0 on success and -1 on error.
</div>

<p>
<tt>
PyObject *SWIG_NewPointerObj(void *ptr, swig_type_info *ty, int own)</tt>
</p>

<div class="indent">
Creates a new Python pointer object.  <tt>ptr</tt> is the pointer to convert, <tt>ty</tt> is the SWIG type descriptor structure that
describes the type, and <tt>own</tt> is a flag that indicates whether or not Python should take ownership of the
pointer.
</div>

<p>
Both of these functions require the use of a special SWIG
type-descriptor structure.  This structure contains information about
the mangled name of the datatype, type-equivalence information, as
well as information about converting pointer values under C++
inheritance.   For a type of <tt>Foo *</tt>, the type descriptor structure
is usually accessed as follows:
</p>

<div class="code">
<pre>
Foo *f;
if (!SWIG_IsOK(SWIG_ConvertPtr($input, (void **) &amp;f, SWIGTYPE_p_Foo, 0))) {
  SWIG_exception_fail(SWIG_TypeError, "in method '$symname', expecting type Foo");
}

PyObject *obj;
obj = SWIG_NewPointerObj(f, SWIGTYPE_p_Foo, 0);
</pre>
</div>

<p>
In a typemap, the type descriptor should always be accessed using the special typemap
variable <tt>$1_descriptor</tt>.  For example:
</p>

<div class="code">
<pre>
%typemap(in) Foo * {
  if (!SWIG_IsOK(SWIG_ConvertPtr($input, (void **) &amp;$1, $1_descriptor, 0))) {
    SWIG_exception_fail(SWIG_TypeError, "in method '$symname', expecting type Foo");
  }
}
</pre>
</div>

<p>
If necessary, the descriptor for any type can be obtained using the <tt>$descriptor()</tt> macro in a typemap.
For example:
</p>

<div class="code">
<pre>
%typemap(in) Foo * {
  if (!SWIG_IsOK(SWIG_ConvertPtr($input, (void **) &amp;$1, $descriptor(Foo *), 0))) {
    SWIG_exception_fail(SWIG_TypeError, "in method '$symname', expecting type Foo");
  }
}
</pre>
</div>

<p>
Although the pointer handling functions are primarily intended for
manipulating low-level pointers, both functions are fully aware of
Python proxy classes.  Specifically,
<tt>SWIG_ConvertPtr()</tt> will retrieve a pointer from any object
that has a <tt>this</tt> attribute.  In addition,
<tt>SWIG_NewPointerObj()</tt> can automatically generate a proxy
class object (if applicable).
</p>



<H2><a name="Python_nn65">36.10 Docstring Features</a></H2>


<p>
Using docstrings in Python code is becoming more and more important
and more tools are coming on the scene that take advantage of them,
everything from full-blown documentation generators to class browsers
and popup call-tips in Python-aware IDEs.  Given the way that SWIG
generates the proxy code by default, your users will normally get
something like <tt>"function_name(*args)"</tt> in the popup calltip of
their IDE which is next to useless when the real function prototype
might be something like this:
</p>

<div class="code">
<pre>
bool function_name(int x, int y, Foo* foo=NULL, Bar* bar=NULL);
</pre>
</div>

<p>
The features described in this section make it easy for you to add
docstrings to your modules, functions and methods that can then be
used by the various tools out there to make the programming experience
of your users much simpler.
</p>


<H3><a name="Python_nn66">36.10.1 Module docstring</a></H3>


<p>
Python allows a docstring at the beginning of the <tt>.py</tt> file
before any other statements, and it is typically used to give a
general description of the entire module.  SWIG supports this by
setting an option of the <tt>%module</tt> directive.  For example:
</p>

<div class="code">
<pre>
%module(docstring="This is the example module's docstring") example
</pre>
</div>

<p>
When you have more than just a line or so then you can retain the easy
readability of the <tt>%module</tt> directive by using a macro.  For
example:
</p>

<div class="code">
<pre>
%define DOCSTRING
"The `XmlResource` class allows program resources defining menus, 
layout of controls on a panel, etc. to be loaded from an XML file."
%enddef

%module(docstring=DOCSTRING) xrc
</pre>
</div>


<H3><a name="Python_nn67">36.10.2 %feature("autodoc")</a></H3>


<p>
As alluded to above SWIG will generate all the function and method
proxy wrappers with just "*args" (or "*args, **kwargs" if the -keyword
option is used) for a parameter list and will then sort out the
individual parameters in the C wrapper code.  This is nice and simple
for the wrapper code, but makes it difficult to be programmer and tool
friendly as anyone looking at the <tt>.py</tt> file will not be able
to find out anything about the parameters that the functions accept.
</p>

<p>But since SWIG does know everything about the function it is
possible to generate a docstring containing the parameter types, names
and default values. Since many of the docstring tools are adopting a
standard of recognizing if the first thing in the docstring is a
function prototype then using that instead of what they found from
introspection, then life is good once more.

<p>SWIG's Python module provides support for the "autodoc" feature,
which when attached to a node in the parse tree will cause a docstring
to be generated that includes the name of the function, parameter
names, default values if any, and return type if any. There are also
four levels for autodoc controlled by the value given to the
feature, <tt>%feature("autodoc", "<i>level</i>")</tt>.
The four values for <i>level</i> are covered in the following sub-sections.

<H4><a name="Python_nn68">36.10.2.1 %feature("autodoc", "0")</a></H4>


<p>
When level "0" is used then the types of the parameters will
<em>not</em> be included in the autodoc string.  For example, given
this function prototype:
</p>

<div class="code">
<pre>
%feature("autodoc", "0");
bool function_name(int x, int y, Foo* foo=NULL, Bar* bar=NULL);
</pre>
</div>

<p>
Then Python code like this will be generated:
</p>

<div class="targetlang">
<pre>
def function_name(*args, **kwargs):
    """function_name(x, y, foo=None, bar=None) -&gt; bool"""
    ...
</pre>
</div>


<H4><a name="Python_nn69">36.10.2.2 %feature("autodoc", "1")</a></H4>


<p>
When level "1" is used then the parameter types <em>will</em> be
used in the autodoc string.  In addition, an attempt is made to
simplify the type name such that it makes more sense to the Python
user.  Pointer, reference and const info is removed if the associated type
is has an associated Python type (<tt>%rename</tt>'s are thus shown correctly).
This works most of the time, otherwise a C/C++ type will be used.
See the next section for the "docstring" feature for tweaking the docstrings to your liking.
Given the example above, then turning on the
parameter types with level "1" will result in Python code like
this:
</p>

<div class="targetlang">
<pre>
def function_name(*args, **kwargs):
    """function_name(int x, int y, Foo foo=None, Bar bar=None) -&gt; bool"""
    ...
</pre>
</div>


<H4><a name="Python_autodoc2">36.10.2.3 %feature("autodoc", "2")</a></H4>


<p>
Level "2" results in the function prototype as per level "0". In addition, a line of
documentation is generated for each parameter using <a href="https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt">numpydoc</a> style.
Using the previous example, the generated code will be:
</p>

<div class="targetlang">
<pre>
def function_name(*args, **kwargs):
    """
    function_name(x, y, foo=None, bar=None) -&gt; bool

    Parameters
    ----------
    x: int
    y: int
    foo: Foo *
    bar: Bar *

    """
    ...
</pre>
</div>

<p>
Note that the documentation for each parameter is sourced from the "doc" typemap which by default shows the
C/C++ type rather than the simplified Python type name described earlier for level "1".
Typemaps can of course change the output for any particular type, for example the <tt>int x</tt> parameter:
</p>

<div class="code">
<pre>
%feature("autodoc", "2");
%typemap("doc") int x "$1_name (C++ type: $1_type) -- Input $1_name dimension"
bool function_name(int x, int y, Foo* foo=NULL, Bar* bar=NULL);
</pre>
</div>

<p>
resulting in
</p>

<div class="targetlang">
<pre>
def function_name(*args, **kwargs):
    """
    function_name(x, y, foo=None, bar=None) -&gt; bool

    Parameters
    ----------
    x (C++ type: int) -- Input x dimension
    y: int
    foo: Foo *
    bar: Bar *

    """
</pre>
</div>

<H4><a name="Python_autodoc3">36.10.2.4 %feature("autodoc", "3")</a></H4>


<p>
Level "3" results in the function prototype as per level "1" but also contains the same additional line of documentation for each parameter as per level "2". Using our earlier example again, the generated code will be:
</p>

<div class="targetlang">
<pre>
def function_name(*args, **kwargs):
    """
    function_name(int x, int y, Foo foo=None, Bar bar=None) -&gt; bool

    Parameters
    ----------
    x: int
    y: int
    foo: Foo *
    bar: Bar *

    """
    ...
</pre>
</div>


<H4><a name="Python_nn70">36.10.2.5 %feature("autodoc", "docstring")</a></H4>


<p>
Finally, there are times when the automatically generated autodoc
string will make no sense for a Python programmer, particularly when a
typemap is involved.  So if you give an explicit value for the autodoc
feature then that string will be used in place of the automatically
generated string.  For example:
</p>

<div class="code">
<pre>
%feature("autodoc", "GetPosition() -&gt; (x, y)") GetPosition;
void GetPosition(int* OUTPUT, int* OUTPUT);
</pre>
</div>


<H3><a name="Python_nn71">36.10.3 %feature("docstring")</a></H3>


<p>
In addition to the autodoc strings described above, you can also
attach any arbitrary descriptive text to a node in the parse tree with
the "docstring" feature.  When the proxy module is generated then any
docstring associated with classes, function or methods are output.
If an item already has an autodoc string then it is combined with the
docstring and they are output together.  If the docstring is all on a
single line then it is output like this::
</p>

<div class="targetlang">
<pre>
"""This is the docstring"""
</pre>
</div>

<p>
Otherwise, to aid readability it is output like this:
</p>

<div class="targetlang">
<pre>
"""
This is a multi-line docstring
with more than one line.
"""
</pre>
</div>

<H2><a name="Python_nn72">36.11 Python Packages</a></H2>


<p>Python has concepts of modules and packages. Modules are separate units of
code and may be grouped together to form a package. Packages may be nested,
that is they may contain subpackages. This leads to tree-like hierarchy, with
packages as intermediate nodes and modules as leaf nodes.</p>

<p>The hierarchy of Python packages/modules follows the hierarchy of
<tt>*.py</tt> files found in a source tree (or, more generally, in the Python path).
Normally, the developer creates new module by placing a <tt>*.py</tt> file
somewhere under Python path; the module is then named after that <tt>*.py</tt>
file. A package is created by placing an <tt>__init__.py</tt> file within a
directory; the package is then named after that directory. For example, the
following source tree:</p>

<div class="diagram">
<pre>
mod1.py
pkg1/__init__.py
pkg1/mod2.py
pkg1/pkg2/__init__.py
pkg1/pkg2/mod3.py
</pre>
</div>

<p>
defines the following Python packages and modules:
</p>

<div class="diagram">
<pre>
pkg1            # package
pkg1.pkg2       # package
mod1            # module
pkg1.mod2       # module
pkg1.pkg2.mod3  # module
</pre>
</div>

<p>
The purpose of an <tt>__init__.py</tt> file is two-fold. First, the existence of
<tt>__init__.py</tt> in a directory informs the Python interpreter that this
directory contains a Python package. Second, the code in <tt>__init__.py</tt> is
loaded/executed automatically when the package is initialized (when it or its
submodule/subpackage gets <tt>import</tt>'ed). By default, SWIG generates
proxy Python code &ndash; one <tt>*.py</tt> file for each <tt>*.i</tt>
interface. The <tt>__init__.py</tt> files, however, are not generated by SWIG.
They should be created by other means. Both files (module <tt>*.py</tt> and
<tt>__init__.py</tt>) should be installed in appropriate destination
directories in order to obtain a desirable package/module hierarchy.
</p>

<p>
Python3 adds another option for packages with
<a href="https://www.python.org/dev/peps/pep-0420/">PEP 0420</a> (implicit
namespace packages).  Implicit namespace packages no longer use
__init__.py files.  SWIG generated Python modules support implicit
namespace packages.  See
<a href="#Python_implicit_namespace_packages">36.11.5 Implicit Namespace
Packages</a> for more information.
</p>

<p>
If you place a SWIG generated module into a Python package then there
are details concerning the way SWIG  
<a href="#Python_package_search">searches for the wrapper module</a>
that you may want to familiarize yourself with.
</p>

<p>The way Python defines its modules and packages impacts SWIG users. Some
users may need to use special features such as the <tt>package</tt> option in the
<tt>%module</tt> directive or import related command line options. These are
explained in the following sections.</p>

<H3><a name="Python_modulepackage">36.11.1 Setting the Python package</a></H3>


<p>
Using the <tt>package</tt> option in the <tt>%module</tt> directive allows you
to specify a Python package that the module will be in when installed.
</p>

<div class="code">
<pre>
%module(package="wx") xrc
</pre>
</div>

<p>
This is useful when the <tt>.i</tt> file is <tt>%import</tt>ed by
another <tt>.i</tt> file.  By default SWIG will assume that the
importer is able to find the importee with just the module name, but
if they live in separate Python packages then this won't work.
However if the importee specifies what its package is with the
<tt>%module</tt> option then the Python code generated for the
importer will use that package name when importing the other module
and in base class declarations, etc..
</p>

<p>SWIG assumes that the <tt>package</tt> option provided to <tt>%module</tt>
together with the <tt>module</tt> name (that is, <tt>wx.xrc</tt> in the above
example) forms a fully qualified (absolute) name of a module (in Python terms).
This is important especially for Python 3, where absolute imports are used by
default. It's up to you to place the generated module files (<tt>.py</tt>,
<tt>.so</tt>) in appropriate subdirectories. For example, if you have an
interface file <tt>foo.i</tt> with:
</p>

<div class="code">
<pre>
%module(package="pkg1.pkg2") foo
</pre>
</div>

<p>
then the resulting directory layout should be
</p>

<div class="diagram">
<pre>
pkg1/
pkg1/__init__.py
pkg1/pkg2/__init__.py
pkg1/pkg2/foo.py        # (generated by SWIG)
pkg1/pkg2/_foo.so       # (shared library built from C/C++ code generated by SWIG)
</pre>
</div>

<H3><a name="Python_absrelimports">36.11.2 Absolute and relative imports</a></H3>


<p>Suppose, we have the following hierarchy of files:</p>

<div class="diagram">
<pre>
pkg1/
pkg1/__init__.py
pkg1/mod2.py
pkg1/pkg2/__init__.py
pkg1/pkg2/mod3.py
</pre>
</div>

<p>Let the contents of <tt>pkg1/pkg2/mod3.py</tt> be</p>
<div class="targetlang">
<pre>
class M3: pass
</pre>
</div>

<p>
We edit <tt>pkg1/mod2.py</tt> and want to import module
<tt>pkg1/pkg2/mod3.py</tt> in order to derive from class <tt>M3</tt>. We can
write appropriate Python code in several ways, for example:
</p>

<ol>
  <li><p>Using "<tt>import &lt;&gt;</tt>" syntax with absolute package name:</p>
    <div class="targetlang">
<pre>
# pkg1/mod2.py
import pkg1.pkg2.mod3
class M2(pkg1.pkg2.mod3.M3): pass
</pre>
    </div>
  </li>

  <li><p>Using "<tt>import &lt;&gt;</tt>" syntax with package name relative to
  <tt>pkg1</tt> (only in Python 2.7 and earlier):</p>
    <div class="targetlang">
<pre>
# pkg1/mod2.py
import pkg2.mod3
class M2(pkg2.mod3.M3): pass
</pre>
    </div>
  </li>

  <li><p>Using "<tt>from &lt;&gt; import &lt;&gt;</tt>" syntax (relative import
  syntax, only in Python 2.5 and later):</p>
    <div class="targetlang">
<pre>
# pkg1/mod2.py
from .pkg2 import mod3
class M2(mod3.M3): pass
</pre>
    </div>
  </li>

  <li><p>Other variants, for example the following construction in order to
  have the <tt>pkg2.mod3.M3</tt> symbol available in <tt>mod2</tt> as
  in point 2 above (but now under Python 3):</p>
    <div class="targetlang">
<pre>
# pkg1/mod2.py
from . import pkg2
from .pkg2 import mod3
class M2(pkg2.mod3.M3): pass
</pre>
    </div>
  </li>

</ol>

<p>Now suppose we have <tt>mod2.i</tt> with</p>

<div class="code">
<pre>
// mod2.i
%module (package="pkg1") mod2
%import "mod3.i"
// ...
</pre>
</div>

<p>and <tt>mod3.i</tt> with</p>

<div class="code">
<pre>
// mod3.i
%module (package="pkg1.pkg2") mod3
// ...
</pre>
</div>

<p>By default, SWIG would generate <tt>mod2.py</tt> proxy file with
<tt>import</tt> directive as in point 1. This can be changed with the
<tt>-relativeimport</tt> command line option. The <tt>-relativeimport</tt> instructs
SWIG to organize imports as in point 2 (for Python < 2.7.0) or as in point 4
for Python 2.7.0 and newer. This is a check done at the time the module is
imported. In short, if you have
<tt>mod2.i</tt> and <tt>mod3.i</tt> as above, then without
<tt>-relativeimport</tt> SWIG will write</p>

<div class="targetlang">
<pre>
import pkg1.pkg2.mod3
</pre>
</div>

<p>to <tt>mod2.py</tt> proxy file, and with <tt>-relativeimport</tt> it will
write</p>

<div class="targetlang">
  <pre>
from sys import version_info
if version_info &gt;= (2, 7, 0):
    from . import pkg2
    import pkg1.pkg2.mod3
else:
    import pkg2.mod3
del version_info
</pre>
</div>

<p>You should avoid using relative imports and use absolute ones whenever
possible. There are some cases, however, when relative imports may be
necessary. The first example is, when some (legacy) Python code refers entities
imported by proxy files generated by SWIG, and it assumes that the proxy file
uses relative imports. Second case is, when one puts import directives in
<tt>__init__.py</tt> to import symbols from submodules or subpackages and the
submodule depends on other submodules (discussed later).</p>

<H3><a name="Python_absimport">36.11.3 Enforcing absolute import semantics</a></H3>


<p>As you may know, there is an incompatibility in import semantics (for the
<tt>import &lt;&gt;</tt> syntax) between Python 2 and 3. In Python 2.4 and
earlier it is not clear whether</p>

<div class="targetlang">
<pre>
import foo
</pre>
</div>
<p>refers to a top-level module or to another module inside the current
package. In Python 3 it always refers to a top-level module
(see <a href="https://www.python.org/dev/peps/pep-0328/">PEP 328</a>).
To instruct Python 2.5 through 2.7 to use new semantics (that is <tt>import
foo</tt> is interpreted as absolute import), one has to put the following
line
</p>

<div class="targetlang">
<pre>
from __future__ import absolute_import
</pre>
</div>

<p>at the very beginning of his proxy <tt>*.py</tt> file. In SWIG, it may be
accomplished with <tt>%pythonbegin</tt> directive as follows:</p>

<div class="code">
<pre>
%pythonbegin %{
from __future__ import absolute_import
%}
</pre>
</div>

<H3><a name="Python_importfrominit">36.11.4 Importing from __init__.py</a></H3>


<p>Imports in <tt>__init__.py</tt> are handy when you want to populate a
package's namespace with names imported from other modules. In SWIG based
projects this approach may also be used to split large pieces of code into
smaller modules, compile them in parallel and then re-assemble everything at
runtime by importing submodules' contents in <tt>__init__.py</tt>, for
example.</p>

<p>Unfortunately import directives in <tt>__init__.py</tt> may cause problems,
especially if they refer to a package's submodules. This is caused by the way
Python initializes packages. If you spot problems with imports from
<tt>__init__.py</tt> try using <tt>-relativeimport</tt> option. Below we
explain in detail one issue, for which the <tt>-relativeimport</tt> workaround
may be helpful.</p>

<p>Consider the following example (Python 3):</p>

<div class="diagram">
<pre>
pkg1/__init__.py        # (empty)
pkg1/pkg2/__init__.py   # (imports something from bar.py)
pkg1/pkg2/foo.py
pkg1/pkg2/bar.py        # (imports foo.py)
</pre>
</div>

<p>If the file contents are:</p>

<ul>
  <li> <p><tt>pkg1/pkg2/__init__.py:</tt></p>
    <div class="targetlang">
<pre>
# pkg1/pkg2/__init__.py
from .bar import Bar
</pre>
    </div>
  </li>

  <li> <p><tt>pkg1/pkg2/foo.py:</tt></p>
    <div class="targetlang">
<pre>
# pkg1/pkg2/foo.py
class Foo: pass
</pre>
    </div>
  </li>

  <li> <p><tt>pkg1/pkg2/bar.py:</tt></p>
    <div class="targetlang">
<pre>
# pkg1/pkg2/bar.py
import pkg1.pkg2.foo
class Bar(pkg1.pkg2.foo.Foo): pass
</pre>
    </div>
  </li>
</ul>

<p>Now if one simply used <tt>import pkg1.pkg2</tt>, it will usually fail:</p>

<div class="diagram">
<pre>
&gt;&gt;&gt; import pkg1.pkg2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "./pkg1/pkg2/__init__.py", line 2, in &lt;module&gt;
    from .bar import Bar
  File "./pkg1/pkg2/bar.py", line 3, in &lt;module&gt;
    class Bar(pkg1.pkg2.foo.Foo): pass
AttributeError: 'module' object has no attribute 'pkg2'
</pre>
</div>

<p>Surprisingly, if we execute the <tt>import pkg1.pkg2</tt> directive for the
second time, it succeeds. The reason seems to be following: when Python spots
the <tt>from .bar import Bar</tt> directive in <tt>pkg1/pkg2/__init__.py</tt>
it starts loading <tt>pkg1/pkg2/bar.py</tt>. This module imports
<tt>pkg1.pkg2.foo</tt> in turn and tries to use <tt>pkg1.pkg2.foo.Foo</tt>, but
the package <tt>pkg1</tt> is not fully initialized yet (the initialization
procedure is actually in progress) and it seems like the effect of the already seen
<tt>import pkg1.pkg2.pkg3.foo</tt> is "delayed" or ignored. Exactly the
same may happen to a proxy module generated by SWIG.</p>

<p>One workaround for this case is to use a relative
import in <tt>pkg1/pkg2/bar.py</tt>. If we change <tt>bar.py</tt> to be:</p>

<div class="targetlang">
<pre>
from .pkg3 import foo
class Bar(foo.Foo): pass
</pre>
</div>

<p>or</p>

<div class="targetlang">
<pre>
from . import pkg3
from .pkg3 import foo
class Bar(pkg3.foo.Foo): pass
</pre>
</div>

<p>then the example works again. With SWIG, you need to enable the
<tt>-relativeimport</tt> option in order to have the above workaround in
effect (note, that the Python 2 case also needs the <tt>-relativeimport</tt>
workaround).</p>

<H3><a name="Python_implicit_namespace_packages">36.11.5 Implicit Namespace Packages</a></H3>


<p> Python 3.3 introduced
<a href="https://www.python.org/dev/peps/pep-0420/">PEP 0420</a> which
implements implicit namespace packages.  In a nutshell, implicit namespace
packages remove the requirement of an __init__.py file and allow packages
to be split across multiple PATH elements.  For example:
</p>

<div class="diagram">
<pre>
/fragment1/pkg1/mod1.py
/fragment2/pkg1/mod2.py
/fragment3/pkg1/mod3.py
</pre>
</div>

<p>If PYTHONPATH is set to "/fragment1:/fragment2:/fragment3", then mod1, mod2
and mod3 will be part of pkg1.  This allows for splitting of packages into
separate pieces.  This can be useful for SWIG generated wrappers in the
following way.
</p>

<p> Suppose you create a SWIG wrapper for a module called robin.  The SWIG
generated code consists of two files robin.py and _robin.so.  You wish to
make these modules part of a subpackage (brave.sir).  With implicit namespace
packages you can place these files in the following configurations:
</p>

<p>Using PYTHONPATH="/some/path"</p>
<div class="diagram">
<pre>
/some/path/brave/sir/robin.py
/some/path/brave/sir/_robin.so
</pre>
</div>

<p>Using PYTHONPATH="/some/path:/some/other/path"

<div class="diagram">
<pre>
/some/path/brave/sir/robin.py
/some/other/path/brave/sir/_robin.so
</pre>
</div>

<p> Finally suppose that your pure python code is stored in a .zip file or
some other way (database, web service connection, etc).  Python can load the
robin.py module using a custom importer.  But the _robin.so module will need
to be located on a file system.  Implicit namespace packages make this
possible.  For example, using PYTHONPATH="/some/path/foo.zip:/some/other/path"

<p> Contents of foo.zip</p>
<div class="diagram">
<pre>
brave/
brave/sir/
brave/sir/robin.py
</pre>
</div>

<p> File system contents</p>
<div class="diagram">
<pre>
/some/other/path/brave/sir/_robin.so
</pre>
</div>

<p>Support for implicit namespace packages was added to python-3.3.  The
zipimporter requires python-3.5.1 or newer to work with subpackages.
</p>

<p>
<b>Compatibility Note:</b> Support for implicit namespace packages was added in SWIG-3.0.9.
</p>


<H3><a name="Python_package_search">36.11.6 Searching for the wrapper module</a></H3>


<p>
When SWIG creates wrappers from an interface file, say foo.i, two Python modules are
created.  There is a pure Python module module (foo.py) and C/C++ code which is
built and linked into a dynamically (or statically) loaded low-level module _foo
(see the <a href="Python.html#Python_nn3">Preliminaries section</a> for details).  So, the interface
file really defines two Python modules.   How these two modules are loaded is
covered next.
</p>

<p>
The pure Python module needs to load the C/C++ module in order to link
to the wrapped C/C++ methods.   To do this it must make some assumptions
about what package the C/C++ module may be located in.  The approach the
pure Python module uses to find the C/C++ module is as follows:
</p>

<ol>
  <li><p>The pure Python module, foo.py, tries to load the C/C++ module, _foo, from the same package foo.py is
      located in.  The package name is determined from the <tt>__name__</tt>
      attribute given to foo.py by the Python loader that imported
      foo.py.  If foo.py is not in a package then _foo is loaded
      as a global module.</p>
  </li>
  <li><p>If the above import of _foo results in an ImportError
      being thrown, then foo.py makes a final attempt to load _foo
    as a global module.</p>
  </li>
</ol>

<p>
The Python code implementing the loading logic described above is quite complex to handle multiple
versions of Python, but it can be replaced with custom code.
This is not recommended unless you understand the full intricacies of importing Python modules.
The custom code can be specified by setting the <tt>moduleimport</tt> option of the <tt>%module</tt> directive with the appropriate import code.  For example:
</p>

<div class="code">
<pre>
%module(moduleimport="import _foo") foo
</pre>
</div>

<p>
The special variable <tt>$module</tt> will also be expanded into the low-level C/C++ module name, <tt>_foo</tt> in the case above.
When you have more than just a line or so then you can retain the easy
readability of the <tt>%module</tt> directive by using a macro.  For
example:
</p>

<div class="code">
<pre>
%define MODULEIMPORT
"
print 'Loading low-level module $module'
import $module
print 'Module has loaded'
"
%enddef

%module(moduleimport=MODULEIMPORT) foo
</pre>
</div>


<p>
Now let's consider an example using the SWIG default loading logic.
Suppose foo.i is compiled into foo.py and _foo.so.  Assuming
/dir is on PYTHONPATH, then the two modules can be installed and used in the
following ways:
</p>


<H4><a name="Python_package_search_both_package_modules">36.11.6.1 Both modules in the same package</a></H4>


<p>Both modules are in one package:</p>
<div class="diagram">
<pre>
/dir/package/foo.py
/dir/package/__init__.py
/dir/package/_foo.so
</pre>
</div>
<p>And imported with</p>
<div class="diagram">
<pre>
from package import foo
</pre>
</div>


<H4><a name="Python_package_search_wrapper_split">36.11.6.2 Split modules</a></H4>


<p>The pure python module is in a package and the C/C++ module is global:</p>
<div class="diagram">
<pre>
/dir/package/foo.py
/dir/package/__init__.py
/dir/_foo.so
</pre>
</div>
<p>And imported with</p>
<div class="diagram">
<pre>
from package import foo
</pre>
</div>


<H4><a name="Python_package_search_both_global_modules">36.11.6.3 Both modules are global</a></H4>


<p>Both modules are global:</p>
<div class="diagram">
<pre>
/dir/foo.py
/dir/_foo.so
</pre>
</div>
<p>And imported with</p>
<div class="diagram">
<pre>
import foo
</pre>
</div>

<p>
If _foo is statically linked into an embedded Python interpreter, then it may or
may not be in a Python package.  This depends in the exact way the module was
loaded statically.  The above search order will still be used for statically
loaded modules.  So, one may place the module either globally or in a package
as desired.
</p>

<H4><a name="Python_package_search_static">36.11.6.4 Statically linked C modules</a></H4>


<p>It is strongly recommended to use dynamically linked modules for the C
portion of your pair of Python modules.
If for some reason you still need
to link the C module of the pair of Python modules generated by SWIG into
your interpreter, then this section provides some details on how this impacts
the pure Python modules ability to locate the other part of the pair.
Please also see the <a href="Python.html#Python_nn8">Static Linking</a> section.
</p>

<p>When Python is extended with C code the Python interpreter needs to be
informed about details of the new C functions that have been linked into
the executable.  The code to do this is created by SWIG and is automatically
called in the correct way when the module is dynamically loaded.  However
when the code is not dynamically loaded (because it is statically linked)
Then the initialization method for the module created by SWIG is not
called automatically and the Python interpreter has no idea that the
new SWIG C module exists.
</p>

<p>Before Python 3, one could simply call the init method created by SWIG
which would have normally been called when the shared object was dynamically
loaded.  The specific name of this method is not given here because statically
linked modules are not encouraged with SWIG
(<a href="Python.html#Python_nn8">Static Linking</a>).  However one can find this
init function in the C file generated by SWIG.
</p>

<p>If you are really keen on static linking there are two ways
to initialize the SWIG generated C module with the init method.  Which way
you use depends on what version of Python your module is being linked with.
Python 2 and Python 3 treat this init function differently.  And the way
they treat it affects how the pure Python module will be able to
locate the C module.
</p>

<p>The details concerning this are covered completly in the documentation
for Python itself.  Links to the relavent sections follow:
</p>

<ul>
  <li><a href="https://docs.python.org/2/extending/extending.html#methodtable">Extending in python2</a></li>
  <li><a href="https://docs.python.org/3.6/extending/extending.html#the-module-s-method-table-and-initialization-function">Extending in python3</a></li>
</ul>

<p>There are two keys things to understand.  The first is that in
Python 2 the init() function returns void.  In Python 3 the init() function
returns a PyObject * which points to the new module.  Secondly, when
you call the init() method manually, you are the Python importer.  So, you
determine which package the C module will be located in.
</p>

<p>So, if you are using Python 3 it is important that you follow what is
described in the Python documentation linked above.  In particular, you can't
simply call the init() function generated by SWIG and cast the PyObject
pointer it returns over the side.  If you do then Python 3 will have no
idea that your C module exists and the pure Python half of your wrapper will
not be able to find it.  You need to register your module with the Python
interpreter as described in the Python docs.
</p>

<p>With Python 2 things are somewhat more simple.  In this case the init function
returns void.  Calling it will register your new C module as a <b>global</b>
module.  The pure Python part of the SWIG wrapper will be able to find it
because it tries both the pure Python module it is part of and the global
module.  If you wish not to have the statically linked module be a global
module then you will either need to refer to the Python documentation on how
to do this (remember you are now the Python importer) or use dynamic linking.
</p>

<H2><a name="Python_python3support">36.12 Python 3 Support</a></H2>


<p>
SWIG is able to support Python 3.0. The wrapper code generated by
SWIG can be compiled with both Python 2.x or 3.0. Further more, by
passing the <tt>-py3</tt> command line option to SWIG, wrapper code
with some Python 3 specific features can be generated (see below
subsections for details of these features). The <tt>-py3</tt> option also
disables some incompatible features for Python 3, such as
<tt>-classic</tt>.

<p>
There is a list of known-to-be-broken features in Python 3:
</p>
<ul>
  <li>No more support for FILE* typemaps, because PyFile_AsFile has been dropped
  in Python 3.</li>
  <li>The <tt>-apply</tt> command line option is removed and generating
  code using apply() is no longer supported.</li>
</ul>

<p>
The following are Python 3.0 new features that are currently supported by
SWIG.
</p>

<H3><a name="Python_nn74">36.12.1 Function annotation</a></H3>


<p>
The <tt>-py3</tt> option will enable function annotation support. When used
SWIG is able to generate proxy method definitions like this:
</p>

<div class="code"><pre>
  def foo(self, bar : "int"=0) -&gt; "void" : ...
</pre></div>

<p>
Also, even if without passing SWIG the <tt>-py3</tt> option, the parameter list
still could be generated:
</p>

<div class="code"><pre>
  def foo(self, bar=0): ...
</pre></div>

<p>
But for overloaded function or method, the parameter list would fallback to
<tt>*args</tt> or <tt>self, *args</tt>, and <tt>**kwargs</tt> may be append
depend on whether you enabled the keyword argument. This fallback is due to
all overloaded functions share the same function in SWIG generated proxy class.
</p>

<p>
For detailed usage of function annotation, see
<a href="https://www.python.org/dev/peps/pep-3107/">PEP 3107</a>.
</p>

<H3><a name="Python_nn75">36.12.2 Buffer interface</a></H3>


<p>
Buffer protocols were revised in Python 3. SWIG also gains a series of
new typemaps to support buffer interfaces. These typemap macros are
defined in <tt>pybuffer.i</tt>, which must be included in order to use them.
By using these typemaps, your wrapped function will be able to
accept any Python object that exposes a suitable buffer interface.
</p>

<p>
For example, the <tt>get_path()</tt> function puts the path string
into the memory pointed to by its argument:
</p>

<div class="code"><pre>
void get_path(char *s);
</pre></div>

<p>
Then you can write a typemap like this: (the following example is
applied to both Python 3.0 and 2.6, since the <tt>bytearray</tt> type
is backported to 2.6.
</p>


<div class="code"><pre>
%include &lt;pybuffer.i&gt;
%pybuffer_mutable_string(char *str);
void get_path(char *s);
</pre></div>

<p>
And then on the Python side the wrapped <tt>get_path</tt> could be used in this
way:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; p = bytearray(10)
&gt;&gt;&gt; get_path(p)
&gt;&gt;&gt; print(p)
bytearray(b'/Foo/Bar/\x00')
</pre></div>

<p>
The macros defined in <tt>pybuffer.i</tt> are similar to those in
<tt>cstring.i</tt>:
</p>

<p>
<b>%pybuffer_mutable_binary(parm, size_parm)</b>
</p>

<div class="indent">

<p>
The macro can be used to generate a typemap which maps a buffer of an
object to a pointer provided by <tt>parm</tt> and a size argument
provided by <tt>size_parm</tt>. For example:
</p>

<div class="code"><pre>
%pybuffer_mutable_binary(char *str, size_t size);
...
int snprintf(char *str, size_t size, const char *format, ...);
</pre></div>

<p>
In Python:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; buf = bytearray(6)
&gt;&gt;&gt; snprintf(buf, "Hello world!")
&gt;&gt;&gt; print(buf)
bytearray(b'Hello\x00')
&gt;&gt;&gt; 
</pre></div>

</div>

<p>
<b>%pybuffer_mutable_string(parm)</b>
</p>

<div class="indent">

<p>
This typemap macro requires the buffer to be a zero terminated string,
and maps the pointer of the buffer to <tt>parm</tt>. For example:
</p>

<div class="code"><pre>
%pybuffer_mutable_string(char *str);
...
size_t make_upper(char *str);
</pre></div>

<p>
In Python:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; buf = bytearray(b'foo\x00')
&gt;&gt;&gt; make_upper(buf)
&gt;&gt;&gt; print(buf)
bytearray(b'FOO\x00')
&gt;&gt;&gt;
</pre></div>

<p>
Both <tt>%pybuffer_mutable_binary</tt> and <tt>%pybuffer_mutable_string</tt>
require the provided buffer to be mutable, eg. they can accept a 
<tt>bytearray</tt> type but can't accept an immutable <tt>byte</tt>
type.
</p>

</div>

<p>
<b>%pybuffer_binary(parm, size_parm)</b>
</p>

<div class="indent">

<p>
This macro maps an object's buffer to a pointer <tt>parm</tt> and a
size <tt>size_parm</tt>. It is similar to
<tt>%pybuffer_mutable_binary</tt>, except the
<tt>%pybuffer_binary</tt> an accept both mutable and immutable
buffers. As a result, the wrapped function should not modify the buffer.
</p>

</div>

<p>
<b>%pybuffer_string(parm)</b>
</p>

<div class="indent">

<p>
This macro maps an object's buffer as a string pointer <tt>parm</tt>.
It is similar to <tt>%pybuffer_mutable_string</tt> but the buffer
could be both mutable and immutable. And your function should not
modify the buffer.
</p>

</div>


<H3><a name="Python_nn76">36.12.3 Abstract base classes</a></H3>


<p>
By including <tt>pyabc.i</tt> and using the <tt>-py3</tt> command
line option when calling SWIG, the proxy classes of the STL containers
will automatically gain an appropriate abstract base class. For
example, the following SWIG interface:
</p>

<div class="code"><pre>
%include &lt;pyabc.i&gt;
%include &lt;std_map.i&gt;
%include &lt;std_list.i&gt;

namespace std {
  %template(Mapii) map&lt;int, int&gt;;
  %template(IntList) list&lt;int&gt;;
}
</pre></div>

<p>
will generate a Python proxy class <tt>Mapii</tt> inheriting from
<tt>collections.MutableMap</tt> and a proxy class <tt>IntList</tt>
inheriting from <tt>collections.MutableSequence</tt>.
</p>

<p>
<tt>pyabc.i</tt> also provides a macro <tt>%pythonabc</tt> that could be
used to define an abstract base class for your own C++ class:
</p>

<div class="code"><pre>
%pythonabc(MySet, collections.MutableSet);
</pre></div>

<p>
For details of abstract base class, please see
<a href="https://www.python.org/dev/peps/pep-3119/">PEP 3119</a>.
</p>

<H3><a name="Python_nn77">36.12.4 Byte string output conversion</a></H3>


<p>
By default, any byte string (<tt>char*</tt> or <tt>std::string</tt>) returned
from C or C++ code is decoded to text as UTF-8. This decoding uses the
<tt>surrogateescape</tt> error handler under Python 3.1 or higher -- this
error handler decodes invalid byte sequences to high surrogate characters
in the range U+DC80 to U+DCFF.

As an example, consider the following SWIG interface, which exposes a byte
string that cannot be completely decoded as UTF-8:
</p>

<div class="code"><pre>
%module example

%include &lt;std_string.i&gt;

%inline %{

const char* non_utf8_c_str(void) {
        return "h\xe9llo w\xc3\xb6rld";
}

%}
</pre></div>

<p>
When this method is called from Python 3, the return value is the following
text string:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; s = example.non_utf8_c_str()
&gt;&gt;&gt; s
'h\udce9llo w&#246;rld'
</pre></div>

<p>
Since the C string contains bytes that cannot be decoded as UTF-8, those raw
bytes are represented as high surrogate characters that can be used to obtain
the original byte sequence:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; b = s.encode('utf-8', errors='surrogateescape')
&gt;&gt;&gt; b
b'h\xe9llo w\xc3\xb6rld'
</pre></div>

<p>
One can then attempt a different encoding, if desired (or simply leave the
byte string as a raw sequence of bytes for use in binary protocols):
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; b.decode('latin-1')
'h&#233;llo w&#195;&#182;rld'
</pre></div>

<p>
Note, however, that text strings containing surrogate characters are rejected
with the default <tt>strict</tt> codec error handler. For example:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; with open('test', 'w') as f:
...     print(s, file=f)
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
UnicodeEncodeError: 'utf-8' codec can't encode character '\udce9' in position 1: surrogates not allowed
</pre></div>

<p>
This requires the user to check most strings returned by SWIG bindings, but
the alternative is for a non-UTF8 byte string to be completely inaccessible
in Python 3 code.
</p>

<p>
For more details about the <tt>surrogateescape</tt> error handler, please see
<a href="https://www.python.org/dev/peps/pep-0383/">PEP 383</a>.
</p>

<p>
In some cases, users may wish to instead handle all byte strings as bytes
objects in Python 3. This can be accomplished by adding
<tt>SWIG_PYTHON_STRICT_BYTE_CHAR</tt> to the generated code:
</p>

<div class="code"><pre>
%module char_to_bytes
%begin %{
#define SWIG_PYTHON_STRICT_BYTE_CHAR
%}

char *charstring(char *s) {
  return s;
}
</pre></div>

<p>
This will modify the behavior so that only Python 3 bytes objects will be
accepted and converted to a C/C++ string, and any string returned from C/C++
will be converted to a bytes object in Python 3:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; from char_to_bytes import *
&gt;&gt;&gt; charstring(b"hi") # Byte string
b'hi'
&gt;&gt;&gt; charstring("hi")  # Unicode string
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: in method 'charstring', argument 1 of type 'char *'
</pre></div>

<p>
Note that in Python 2, defining <tt>SWIG_PYTHON_STRICT_BYTE_CHAR</tt> has no
effect, since strings in Python 2 are equivalent to Python 3 bytes objects.
However, there is a similar capability to force unicode-only handling for
wide characters C/C++ strings (<tt>wchar_t *</tt> or <tt>std::wstring</tt>
types) in Python 2. By default, in Python 2 both strings and unicode strings
are converted to C/C++ wide strings, and returned wide strings are converted
to a Python unicode string. To instead only convert unicode strings to wide
strings, users can add <tt>SWIG_PYTHON_STRICT_UNICODE_WCHAR</tt> to the
generated code:
</p>

<div class="code"><pre>
%module wchar_to_unicode
%begin %{
#define SWIG_PYTHON_STRICT_UNICODE_WCHAR
%}

wchar_t *wcharstring(wchar_t *s) {
  return s;
}
</pre></div>

<p>
This ensures that only unicode strings are accepted by wcharstring in both
Python 2 and Python 3:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; from wchar_to_unicode import *
&gt;&gt;&gt; wcharstring(u"hi") # Unicode string
u'hi'
&gt;&gt;&gt; wcharstring(b"hi") # Byte string
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: in method 'charstring', argument 1 of type 'wchar_t *'
</pre></div>

<p>
By defining both <tt>SWIG_PYTHON_STRICT_BYTE_CHAR</tt> and
<tt>SWIG_PYTHON_STRICT_UNICODE_WCHAR</tt>, Python wrapper code can support
overloads taking both std::string (as Python bytes) and std::wstring
(as Python unicode).
</p>

<H3><a name="Python_2_unicode">36.12.5 Python 2 Unicode</a></H3>


<p>
A Python 3 string is a Unicode string so by default a Python 3 string that contains Unicode
characters passed to C/C++ will be accepted and converted to a C/C++ string
(<tt>char *</tt> or <tt>std::string</tt> types).
A Python 2 string is not a unicode string by default and should a Unicode string be
passed to C/C++ it will fail to convert to a C/C++ string
(<tt>char *</tt> or <tt>std::string</tt> types).
The Python 2 behavior can be made more like Python 3 by defining
<tt>SWIG_PYTHON_2_UNICODE</tt> when compiling the generated C/C++ code.
By default when the following is wrapped:
</p>

<div class="code"><pre>
%module unicode_strings
char *charstring(char *s) {
  return s;
}
</pre></div>

<p>
An error will occur when using Unicode strings in Python 2:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; from unicode_strings import *
&gt;&gt;&gt; charstring("hi")
'hi'
&gt;&gt;&gt; charstring(u"hi")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: in method 'charstring', argument 1 of type 'char *'
</pre></div>

<p>
When the <tt>SWIG_PYTHON_2_UNICODE</tt> macro is added to the generated code:
</p>

<div class="code"><pre>
%module unicode_strings
%begin %{
#define SWIG_PYTHON_2_UNICODE
%}

char *charstring(char *s) {
  return s;
}
</pre></div>

<p>
Unicode strings will be successfully accepted and converted from UTF-8,
but note that they are returned as a normal Python 2 string:
</p>

<div class="targetlang"><pre>
&gt;&gt;&gt; from unicode_strings import *
&gt;&gt;&gt; charstring("hi")
'hi'
&gt;&gt;&gt; charstring(u"hi")
'hi'
&gt;&gt;&gt;
</pre></div>

<p>
Note that defining both <tt>SWIG_PYTHON_2_UNICODE</tt> and
<tt>SWIG_PYTHON_STRICT_BYTE_CHAR</tt> at the same time is not allowed, since
the first is allowing unicode conversion and the second is explicitly
prohibiting it.
</p>

</body>
</html>

<!--  LocalWords:  polymorphism Typemaps STL typemap typemaps Docstring autodoc
 -->
<!--  LocalWords:  docstring SWIG's cxx py GCC linux DLL gcc fPIC Wiki Xlinker
 -->
<!--  LocalWords:  examplemodule DHAVE CONFIG lpython lm ldl mypython lsocket
 -->
<!--  LocalWords:  lnsl lpthread distutils enums namespaces
 -->
