#
# Inception V3 network
# Details are in https://arxiv.org/pdf/1512.00567.pdf
#

command = Train:Eval

deviceId   = "Auto"
precision  = "float"
# traceLevel = 1

RootDir   = "."
ConfigDir = "$RootDir$"
DataDir   = "$RootDir$"
OutputDir = "$RootDir$/Output"
ModelDir  = "$OutputDir$/Model"
stderr    = "$OutputDir$/InceptionV3.log"

ImageH    = 299
ImageW    = 299
ImageC    = 3
NumLabels = 1000

Train = {
    action = "train"
    modelPath="$ModelDir$/InceptionV3"

    BrainScriptNetworkBuilder = {
        include "$ConfigDir$/InceptionBlocks.bs"
        include "$ConfigDir$/InceptionV3.bs"

        imageShape  = $ImageH$:$ImageW$:$ImageC$
        labelDim    = $NumLabels$
        bnTimeConst = 4096
        auxWeight   = Constant(0.3)

        # inputs
        features = Input {imageShape}
        labels   = Input {labelDim}

        # apply model to features
        model = InceptionV3(features, labelDim, bnTimeConst)
        z     = model.z
		    aux   = model.aux

        # connect to system
        ceAux    = CrossEntropyWithSoftmax     (labels, aux)
        ceZ      = CrossEntropyWithSoftmax     (labels, z)
        errs     = ClassificationError         (labels, z)
        top5Errs = ClassificationError         (labels, z, topN=5)  # only used in Eval action
        ce       = auxWeight .* ceAux + ceZ

        featureNodes    = (features)
        labelNodes      = (labels)
        criterionNodes  = (ce)
        evaluationNodes = (errs)  # top5Errs only used in Eval
        outputNodes     = (z)
    }

    SGD = {
        epochSize     = 0
        maxEpochs     = 160
        minibatchSize = 32
        dropoutRate   = 0.8

        gradUpdateType        = "rmsProp"
        normWithAveMultiplier = true
        rms_wgt_inc           = 1.2
        rms_wgt_dec           = 0.75
        rms_wgt_max           = 10.0
        rms_wgt_min           = 0.1
        rms_gamma             = 0.9

        learningRatesPerMB = 0.1
        momentumPerMB      = 0.9

        firstMBsToShowResult = 10 ; numMBsToShowResult = 500

        parallelTrain = {
            parallelizationMethod = "dataParallelSGD"
            parallelizationStartEpoch = 1
            distributedMBReading = true
            dataParallelSGD = { gradientBits = 2 }
        }
    }

    reader = {
        verbosity = 0 ; randomize = true
        deserializers = ({
            type = "ImageDeserializer" ; module = "ImageReader"
            file = "$DataDir$/train_map.txt"
            input = {
                features = { transforms = (
                    { type = "Crop" ; cropType = "random" ; cropRatio = 0.8 ; jitterType = "uniRatio" } :
                    { type = "Scale" ; width = $ImageW$ ; height = $ImageH$ ; channels = $ImageC$ ; interpolations = "linear" } :
                    { type = "Mean" ; meanFile = "$DataDir$/ImageNet1K_mean.xml" } :
                    { type = "Transpose" }
                )}
                labels = { labelDim = $NumLabels$ }
            }
        })
    }
}

# Eval action
Eval = {
    action = "eval"
    evalNodeNames = errs:top5Errs  # also test top-5 error rate
    # Set minibatch size for testing.
    minibatchSize = 32

    reader = {
        verbosity = 0 ; randomize = false
        deserializers = ({
            type = "ImageDeserializer" ; module = "ImageReader"
            file = "$DataDir$/val_map.txt"
            input = {
                features = { transforms = (
                   { type = "Scale" ; width = $ImageW$ ; height = $ImageH$ ; channels = $ImageC$ ; interpolations = "linear" } :
                   { type = "Mean"; meanFile = "$DataDir$/ImageNet1K_mean.xml" } :
                   { type = "Transpose" }
                )}
                labels = { labelDim = $NumLabels$ }
            }
        })
    }
}
